options {
  JAVA_UNICODE_ESCAPE = false;
  ERROR_REPORTING = true;
  STATIC = false;
//  MULTI = true;
  JDK_VERSION = "1.5";
//  VISITOR = true;
//  BUILD_NODE_FILES = true;
//  NODE_FACTORY = false;
//  NODE_USES_PARSER = true;
//  NODE_SCOPE_HOOK = true;
//  NODE_PREFIX = "SQL";
//  DEBUG_PARSER = true;
//  DEBUG_LOOKAHEAD = true;
//  DEBUG_TOKEN_MANAGER = true;
  LOOKAHEAD = 1;
//  CHOICE_AMBIGUITY_CHECK = 3;
//  OTHER_AMBIGUITY_CHECK = 3;
  IGNORE_CASE = true;
}
PARSER_BEGIN(Parser)

package org.ofbiz.entity.sql;

import java.io.*;
import java.util.List;
import java.util.LinkedList;
import java.util.Set;

import javolution.util.FastList;
import javolution.util.FastSet;

import org.ofbiz.base.conversion.ConversionException;
import org.ofbiz.base.conversion.Converter;
import org.ofbiz.base.conversion.Converters;
import org.ofbiz.entity.condition.EntityComparisonOperator;
import org.ofbiz.entity.condition.EntityCondition;
import org.ofbiz.entity.condition.EntityConditionValue;
import org.ofbiz.entity.condition.EntityFieldValue;
import org.ofbiz.entity.condition.EntityOperator;
import org.ofbiz.entity.condition.OrderByItem;
import org.ofbiz.entity.condition.OrderByList;
import org.ofbiz.entity.model.DynamicViewEntity;
import org.ofbiz.entity.model.ModelKeyMap;
import org.ofbiz.entity.model.ModelViewEntity.ModelAlias;

public class Parser {
}

PARSER_END(Parser)
TOKEN_MGR_DECLS: {
	private final LinkedList<Integer> stack = new LinkedList<Integer>();

	void pushState(int newState) {
		stack.add(curLexState);
		SwitchTo(newState);
	}

	void popState() {
		SwitchTo(stack.removeLast());
	}
}

TOKEN: {
	<OPEN_PAREN: "(">
|	<CLOSE_PAREN: ")">
|	<AND: "AND">
|	<OR: "OR">
|	<PERIOD: ".">
|	<JOIN: "JOIN">
|	<LEFT: "LEFT">
|	<RIGHT: "RIGHT">
|	<AS: "AS">
|	<WHERE: "WHERE">
|	<HAVING: "HAVING">
|	<GROUP: "GROUP">
|	<ORDER: "ORDER">
|	<UNION: "UNION">
|	<BY: "BY">
|	<ON: "ON">
|	<LIMIT: "LIMIT">
|	<OFFSET: "OFFSET">
|	<SELECT: "SELECT">
|	<DELETE: "DELETE">
|	<UPDATE: "UPDATE">
|	<RELATION: "RELATION">
|	<TYPE: "TYPE">
|	<TITLE: "TITLE">
|	<SET: "SET">
|	<FROM: "FROM">
|	<SEMI: ";">
|	<STAR: "*">
|	<COMMA: ",">
|	<DESC: "DESC">
|	<ASC: "ASC">
|	<START_DQUOTE: "\""> { pushState(IN_DQUOTE); }
|	<START_SQUOTE: "'"> { pushState(IN_SQUOTE); }
|	<INTEGER:
	"0" (
		"x" (["0"-"9","a"-"b"])+
		| (["0"-"7"])+
	)
	| ["1"-"9"] (["0"-"9"])*
	>
|	<NAME:	(["a"-"z"])+>
//|	<WORD: (~["'", "\"", "/", " ", "\f", "\n", "\r", "\t", "*"])+>
}

<DEFAULT>
SKIP: {
	<SPACE: " " | "\f" | "\n" | "\r" | "\t">
}

<*>
MORE: {
	<COMMENT_START: "/*"> { if (curLexState != IN_COMMENT) pushState(IN_COMMENT); }
}

<IN_COMMENT>
MORE: {
	<(~[])>
|	<COMMENT_END: ("\n" | "\r" | "\r\n")> { popState(); }
}

<IN_DQUOTE,IN_SQUOTE>
TOKEN: {
	<ESCAPED: "\\" ["r", "n", "b", "t", "f"]>
}

<IN_DQUOTE>
TOKEN: {
	<END_DQUOTE: "\""> { popState(); }
}

<IN_SQUOTE>
TOKEN: {
	<ESCAPE_SQUOTE: "''">
|	<END_SQUOTE: "'"> { popState(); }
}

<DEFAULT,IN_DQUOTE,IN_SQUOTE>
TOKEN: {
	<TEXT: (~[])>
}

// -------------------


SQLSelect Select():
{
	EntityCondition condition;
	int i;
	DynamicViewEntity dve = new DynamicViewEntity();
	SQLSelect sqlSelect = new SQLSelect();
	sqlSelect.setDynamicViewEntity(dve);
	List<String> fieldList;
	List<String> orderBy;
}
{
	<SELECT> FieldDefs(dve)
	<FROM> Table(dve)
	( <RELATION> RelationDef(dve) )*
	( <WHERE> condition=ConditionExpression() { sqlSelect.setWhereCondition(condition); } )?
	( <HAVING> condition=ConditionExpression() { sqlSelect.setHavingCondition(condition); } )?
	( <GROUP> <BY> fieldList=FieldList() { dve.setGroupBy(fieldList); } )?
	( <ORDER> <BY> orderBy=OrderByList() { sqlSelect.setOrderBy(orderBy); } )?
	( <OFFSET> i=Integer() { sqlSelect.setOffset(i); } )?
	( <LIMIT> i=Integer() { sqlSelect.setLimit(i); } )?
	<SEMI>
	{ return sqlSelect; }
}

private void RelationDef(DynamicViewEntity dve):
{
	String type = null, title = null, entityName;
	List<ModelKeyMap> keyMaps;
}
{
	( LOOKAHEAD(2) <TYPE> type=NamePart() )?
	( LOOKAHEAD(2) <TITLE> title=NamePart() )?
	entityName=NamePart()
	<ON> keyMaps=KeyMaps("cur", "other") {
		System.err.println("addRelation(" + type + ", " + title + ", " + entityName + ", " + keyMaps + ")");
		dve.addRelation(type, title, entityName, keyMaps);
	}
}
/*
CSSUpdate Update():
{}
{
	<UPDATE> Table()
	( Set() )+
	( <FROM> TableList() )?
	( <WHERE> ConditionExpression() )?
	<SEMI>
}

CSSDelete Delete():
{}
{
	<DELETE> <FROM>	Table()
	( <USING> TableList() )?
	( <WHERE> ConditionExpression() )?
	<SEMI>
}
*/

private void Table(DynamicViewEntity dve):
{
	String leftAlias, rightAlias;
	Boolean relOptional;
	Set<String> availableAliases = FastSet.newInstance();
	List<ModelKeyMap> keyMaps;
}
{
	leftAlias=TableName(dve) { availableAliases.add(leftAlias); }
	(
		relOptional=Joiner() rightAlias=TableName(dve) { availableAliases.add(rightAlias); }
		<ON> keyMaps=KeyMaps(leftAlias, rightAlias) {
    			dve.addViewLink(leftAlias, rightAlias, relOptional, keyMaps);
		}
		
	)*

}

private List<ModelKeyMap> KeyMaps(String leftAlias, String rightAlias):
{
	List<ModelKeyMap> keyMaps = FastList.newInstance();
	ModelKeyMap keyMap;
}
{
	keyMap=KeyMap(leftAlias, rightAlias) { keyMaps.add(keyMap); }
	( <AND> keyMap=KeyMap(leftAlias, rightAlias) { keyMaps.add(keyMap); } )*
	{ return keyMaps; }
}

private ModelKeyMap KeyMap(String leftAlias, String rightAlias):
{
	String alias1, field1;
	String alias2, field2;
	EntityComparisonOperator op;
}
{
	alias1=NamePart() <PERIOD> field1=NamePart()
	op=ComparisonOperator()
	alias2=NamePart() <PERIOD> field2=NamePart()
	{
		if (op != EntityOperator.EQUALS) throw new IllegalArgumentException(op + " not supported");
		if (alias1.equals(leftAlias)) {
			if (!alias2.equals(rightAlias)) throw new IllegalArgumentException("invalid right alias(" + alias2 + "), expected(" + rightAlias + ")");
			return new ModelKeyMap(field1, field2);
		} else if (alias1.equals(rightAlias)) {
			if (!alias2.equals(leftAlias)) throw new IllegalArgumentException("invalid left alias(" + alias2 + "), expected(" + leftAlias + ")");
			return new ModelKeyMap(field2, field1);
		} else {
			throw new IllegalArgumentException("invalid aliases, expected(" + leftAlias + " or " + rightAlias + ")");
		}
	}
}

private String TableName(DynamicViewEntity dve):
{
	String name, alias = null;
}
{
	name=NamePart() ( (<AS>)? alias=NamePart() )?
	{
		if (alias == null) alias = name;
		dve.addMemberEntity(alias, name);
		return alias;
	}
}

private Boolean Joiner():
{}
{
	<LEFT> <JOIN> { return Boolean.TRUE; }
|	<JOIN> { return Boolean.FALSE; }
}

private void FieldDefs(DynamicViewEntity dve):
{}
{
	FieldDef(dve) ( <COMMA> FieldDef(dve) )*
}

private void FieldDef(DynamicViewEntity dve):
{
	List<String> fieldUse;
	String tableAlias, fieldName, fieldAlias = null;
}
{
	tableAlias=NamePart() <PERIOD>
	(
		<STAR> { dve.addAliasAll(tableAlias, null); }
	|	fieldName=NamePart() ( <AS> fieldAlias=NamePart() )? {
			if (fieldAlias == null) {
				dve.addAlias(tableAlias, fieldName);
			} else {
				dve.addAlias(tableAlias, fieldAlias, fieldName, null, null, null, null);
			}
		}
	)
}

private String NamePart():
{}
{
	<NAME> { return getToken(0).image; }
}

private String DQuoted():
{ StringBuilder sb = new StringBuilder(); }
{
	<START_DQUOTE> (<TEXT> { sb.append(getToken(0).image); } | <ESCAPED> { sb.append(getToken(0).image); })* <END_DQUOTE>
	{ return sb.toString(); }
}

private String SQuoted():
{ StringBuilder sb = new StringBuilder(); }
{
	<START_SQUOTE> (
		<TEXT> { sb.append(getToken(0).image); }
	|	<ESCAPED> { sb.append(getToken(0).image); }
	|	<ESCAPE_SQUOTE> { sb.append("'"); }
	)* <END_SQUOTE>
	{ return sb.toString(); }
}

private List<String> FieldList():
{
	List<String> list = FastList.newInstance();
	String n;
}
{
	n=NamePart() { list.add(n); }
	( <COMMA> n=NamePart() { list.add(n); } )*
	{ return list; }
}

private EntityConditionValue FieldUse():
{
	String tableAlias = null, fieldName, s;
}
{
	s=NamePart() { fieldName = s; }
	( <PERIOD> s=NamePart() { tableAlias = fieldName; fieldName = s; } )?
	{ return EntityFieldValue.makeFieldValue(fieldName, tableAlias, null, null); }
}

private List<String> OrderByList():
{
	List<String> orderBy = FastList.newInstance();
	String obi;
}
{
	obi=OrderByItem() { orderBy.add(obi); }
	( <COMMA> obi=OrderByItem() { orderBy.add(obi); } )*
	{ return orderBy; }
}

private String OrderByItem():
{
	StringBuilder sb = new StringBuilder();
	String n;
}
{
	n=NamePart() { sb.append(n); }
	(
		<DESC> { sb.append(" DESC"); } 
		| <ASC> { sb.append(" ASC"); }
	)?
	{ return sb.toString(); }
}

private Integer Integer():
{}
{
	<INTEGER> {
		try {
			Converter<String, Integer> converter = Converters.getConverter(String.class, Integer.class);
			return converter.convert(getToken(0).image);
		} catch (ClassNotFoundException e) {
			return null;
		} catch (ConversionException e) {
			return null;
		}
	}
}

private Object Expression():
{
	EntityConditionValue ecv;
	String s;
	int i;
}
{
	ecv=FieldUse() { return ecv; }
|	i=Integer() { return i; }
|	s=SQuoted() { return s; }
}

public EntityCondition EntityCondition():
{ EntityCondition ec; }
{
	ec=ConditionExpression() <EOF> { return ec; }
}

private EntityCondition ConditionExpression():
{ EntityCondition ec; }
{
	ec=AndExpression() { return ec; }
}

private EntityCondition AndExpression():
{
	List<EntityCondition> list = FastList.newInstance();
	EntityCondition ec;
}
{
	ec=OrExpression() { list.add(ec); }
        ( <AND> ec=OrExpression() { list.add(ec); } )*
	{
		if (list.size() == 1) return list.get(0);
		return EntityCondition.makeCondition(list, EntityOperator.AND);
	}
}

private EntityCondition OrExpression():
{
	List<EntityCondition> list = FastList.newInstance();
	EntityCondition ec;
}
{
	ec=BooleanExpression() { list.add(ec); }
        ( <OR> ec=BooleanExpression() { list.add(ec); } )*
	{
		if (list.size() == 1) return list.get(0);
		return EntityCondition.makeCondition(list, EntityOperator.OR);
	}
}

private EntityCondition BooleanExpression():
{
	Object v1, v2;
	EntityComparisonOperator op;
	EntityCondition ec;
}
{
	v1=Expression() op=ComparisonOperator() v2=Expression()
	{ return EntityCondition.makeCondition(v1, op, v2); }
|	<OPEN_PAREN> ec=AndExpression() <CLOSE_PAREN> { return ec; }
}

private EntityComparisonOperator ComparisonOperator():
{}
{
	( <TEXT> )+ { return EntityOperator.lookupComparison(getToken(0).image); }
}
