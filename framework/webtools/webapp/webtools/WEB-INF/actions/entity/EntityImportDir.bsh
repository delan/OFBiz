/*
 *  Copyright (c) 2003 The Open For Business Project - www.ofbiz.org
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a 
 *  copy of this software and associated documentation files (the "Software"), 
 *  to deal in the Software without restriction, including without limitation 
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 *  and/or sell copies of the Software, and to permit persons to whom the 
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included 
 *  in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
 *  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
 *  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
 *  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT 
 *  OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 
 *  THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * @author Brian Johnson (bmj@camfour.com)
 * @author Ray Barlow (ray.barlow@makeyour-point.com)
 * @author David E. Jones (jonesde@ofbiz.org)
 * @author Jacopo Cappellato (tiz@sastau.it)
 */

import java.util.ArrayList;
import org.ofbiz.base.util.UtilFormatOut;
import org.ofbiz.entity.util.EntitySaxReader;

String path = request.getParameter("path");
boolean mostlyInserts = request.getParameter("mostlyInserts") != null;
boolean keepStamps = request.getParameter("maintainTimeStamps") != null;
boolean createDummyFks = request.getParameter("createDummyFks") != null;
boolean deleteFiles = request.getParameter("deleteFiles") != null;

List messages = new ArrayList();
String txTimeoutStr = UtilFormatOut.checkEmpty(request.getParameter("txTimeout"), "7200");
String filePauseStr = UtilFormatOut.checkEmpty(request.getParameter("filePause"), "0");
Integer txTimeout = null;
try {
    txTimeout = Integer.valueOf(txTimeoutStr);
} catch (Exception e) {
    txTimeout = new Integer(7200);
    errorMessageList.add("ERROR: TX Timeout not a valid number, setting to 7200 seconds (2 hours): " + e.getMessage());
}

Long filePause = null;
try {
    filePause = Long.valueOf(filePauseStr);
} catch (Exception e) {
    filePause = new Long(0);
    errorMessageList.add("ERROR: File Pause not a valid number, setting to 0 seconds (no pause): " + e.getMessage());
}

if (path != null && path.length() > 0) {
    long pauseLong = filePause != null ? filePause.longValue() : 0;
    File baseDir = new File(path);

    if (baseDir.isDirectory() && baseDir.canRead()) {
        File[] fileArray = baseDir.listFiles();
        ArrayList files = new ArrayList(fileArray.length);
        for (int a=0; a<fileArray.length; a++){
            if (fileArray[a].getName().toUpperCase().endsWith("XML")) {
                files.add(fileArray[a]);
            }
        }
        boolean importedOne = false;
        int fileListMarkedSize = files.size();
        int passes = 0;
        for (int a=0; a<files.size(); a++){
            // Infinite loop defense
            if (a == fileListMarkedSize) {
                passes++;
                fileListMarkedSize = files.size();
                messages.add("Pass " + passes + " complete");
                // This means we've done a pass
                if ( false == importedOne ) {
                    // We've failed to make any imports
                    messages.add("Dropping out as we failed to make any imports on the last pass");
                    a = files.size();
                    continue;
                }
                importedOne = false;
            }
            File curFile = (File)files.get(a);
            try{
                URL url = curFile.toURL();
                EntitySaxReader reader = new EntitySaxReader(delegator);
                if (mostlyInserts) {
                    reader.setUseTryInsertMethod(true);
                }
                if (txTimeout != null) {
                    reader.setTransactionTimeout(txTimeout.intValue());
                }
                if (createDummyFks) {
                    reader.setCreateDummyFks(true);
                }
                long numberRead = reader.parse(url);
                messages.add("Got " + numberRead + " entities from " + curFile);
                importedOne = true;
                if (deleteFiles) {
                    curFile.delete();
                }
            } catch (Exception ex){
                messages.add("Error trying to read from " + curFile + ": " + ex);
                if (ex.toString().indexOf("referential integrity violation") > -1 ||
                        ex.toString().indexOf("Integrity constraint violation") > -1){
                    //It didn't work because object it depends on are still
                    //missing from the DB. Retry later.
                    //
                    //FIXME: Of course this is a potential infinite loop.
                    messages.add("Looks like referential integrity violation, will retry");
                    files.add(curFile);
                }
            }

            // pause in between files
            if (pauseLong > 0) {
                Debug.log("Pausing for [" + pauseLong + "] seconds - " + UtilDateTime.nowTimestamp());
                Thread.sleep((pauseLong * 1000));
                Debug.log("Pause finished - " + UtilDateTime.nowTimestamp());
            }
        }
    } else {
        messages.add("path not found or can't be read");
    }
} else {
    messages.add("No path specified, doing nothing.");
}
context.put("messages", messages);
