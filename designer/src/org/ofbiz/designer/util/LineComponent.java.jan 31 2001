package util;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

//this is a superclass for gui objects that have the form of a line extending from one point to another.
//it is capable of performing all the necessary updates to the data and appearance of the component
//when one endpoint or another is moved.  it does not, however, handle any events.  event handlers would presumably be
//in a subclass, where they would have access to inherited methods such as setHead and setTail that could be used to
//do the actual work required in handling any events.
public class LineComponent extends JComponent { 
	
	//holds an object that performs many useful line-related calculations.
	protected Line abstractLine;
	
	//represents how far the clickable area should stand off from the center of the visible line.
	protected static float THE_RADIUS = 5;
	
	//represents how far the borders of the component should stand off from the two endpoints of the line.
	//if this value is not sufficiently large, some of the graphical representation of the line may be clipped
	//by the component bounds.
	protected static int OFFSET_FROM_BORDER = 10;
	
	//constants that help in the establishing the perspective from which
	//line calculations are made in the method getDelta.
	protected static int FROM_HEAD = 1;
	protected static int FROM_TAIL = -1;
	
	//we need names to distiguish the two end points of the line.  head and tail are kind of arbitrary.  think of the
	//head as the end that would have the arrowhead if your graphical representation were to contain an arrowhead.
	protected Point headPoint, tailPoint;
	
	//these four hold the absolute coordinates of the head and the tail (i.e. the coordinates of the line expressed
	//in relation to the origin of the line component's container.)
	protected int headX;
	protected int headY;
	protected int tailX;
	protected int tailY;
	
	//these four hold the relative coordinates of the head and tail (i.e. the coordinates of the line expressed in
	//relation to the origin of the line component.  the head of the line and the origin of the component are not
	//identical because a)the line is offset from the component bounds and b)we may choose to locate the component
	//origin near the tail of the line if the line has negative slope).
	protected int localHeadX;
	protected int localHeadY;
	protected int localTailX;
	protected int localTailY;
	
	protected Color theColor;
	
	//the defaul constructor initialized the head and tail objects so that runtime errors do not result if the head
	//and tail should for some reason be set at different times.
	public LineComponent() {
		headPoint = new Point(0,0);
		tailPoint = new Point(0,0);
		abstractLine = new Line(tailPoint,headPoint);
	}
	
	//instantiates a line component extending from tail to head (remember head is where the arrow would go
	//if we had one.)
	public LineComponent(Point head, Point tail) {
		headPoint = head;
		tailPoint = tail;
		abstractLine = new Line(tailPoint, headPoint);
		updateBounds();
	}
	
	public void setColor(Color aColor) {
		theColor = aColor;
	}
	
	//abstractLine contains a sort of conceptual model of the line on which our component is based.
	//when there have been changed to abstractLine, a lot of data in our line component needs to be updated.
	//other classes that are not subclasses should not call this method directly.  it is used in setHead, setTail,
	//and the like.
	protected void updateBounds() {
		headX = abstractLine.getHeadX();
		headY = abstractLine.getHeadY();
		tailX = abstractLine.getTailX();
		tailY = abstractLine.getTailY();
		
		//the location of the component is not identical to the location of the line.  see the comment at the definition
		//of OFFSET_FROM_BORDER
		setLocation(Math.min(headX, tailX)-OFFSET_FROM_BORDER,Math.min(headY, tailY)-OFFSET_FROM_BORDER);
		
		//a component is necessarily rectangular in shape and has a 0 degree orientation.  we can imagine our line
		//as a diagonal in the component.  we need to size the rectangle so that it can encompass the entire line,
		//in addition to the OFFSET_FROM_BORDER.  the minimum size for the component is twice the size of the offset
		//because we cannot do without the offset.  if we don't allow for the offset, the component could get so small
		//that it clips the graphical representation of the line.
		setSize(Math.abs(headX-tailX)+(OFFSET_FROM_BORDER*2), Math.abs(headY-tailY)+(OFFSET_FROM_BORDER*2));
	
		localHeadX = headX - getX();
		localHeadY = headY - getY();
		localTailX = tailX - getX();
		localTailY = tailY - getY();
		
	}
	
	//overrides the contains methods so that only a small area surrounding the line is clickable, instead of the whole
	//component. the abstractLine object (an instance of the Line class) does all the calculations we need to realize a 
	//rectangle that encloses our line with an offset of  THE_RADIUS.  so we just need to call the appropriate methods
	//of abstractLine.  this can be overidden by subclasses that need a more complicated contains method because their
	//graphical representations require it.
	public boolean contains(int x, int y) {
		return abstractLine.containingRect(THE_RADIUS).contains(x,y);
	}
	
	//creates a minimal graphical representation for the component.  this can be overridden by sublclasses that
	//want fancier graphics.
	public void paintComponent(Graphics g) {
		g.setColor(theColor);
		g.drawLine(localHeadX,localHeadY,localTailX,localTailY);
	}
	
	//effectively recreates the line component using a new tail point and the original head point.
	public void setTail(Point newTail) {
		tailPoint = newTail;
		abstractLine = new Line(newTail, headPoint);
		updateBounds();
	}
	
	//effectively recreates the line component using a new head point and the original tail point.
	public void setHead(Point newHead) {
		headPoint = newHead;
		abstractLine = new Line(tailPoint, newHead);
		updateBounds();
	}
	
	//simultaneously sets the tail and the head points.  here, however, you can pass two rectangles instead of two points.
	//the method then calculates the points at which the line and the near sides of the two rectangles intersect.  then
	//it sets the endpoints of the line to these points.  this is useful when you don't want graphical represenation
	//of the line to be obscured by the components at the head and tail.
	public void setLineOutsideBox(Rectangle headBounds, Rectangle tailBounds) {
		
		//a good way to start a calculation of the intersection of a line and a rectangle is to set the endpoint
		//of the line in the center of the rectangle.  at least then we know the slope of our line is correct.  after
		//that we just need to shorten the line to an endpoint that is on the perimeter of the rectangle.
		headPoint.x = (int)headBounds.getCenterX();
		headPoint.y = (int)headBounds.getCenterY();
		setHead(headPoint);
		
		tailPoint.x = (int)tailBounds.getCenterX();
		tailPoint.y = (int)tailBounds.getCenterY();
		setTail(tailPoint);
		
		
		float lineAngle = abstractLine.getSlopeAngle();
		
		//we will use the slope of the line component's line to adjust the endpoint of the line appropriately once
		//we know the side to which it should be adjusted.
		float slopeRatio;
	
		//its OK to set the slope to 0 when our line is vertical since that will result simply in no adjustment to the
		//x-coordinate of the endpoint.
		if((headX-tailX)==0) {
			slopeRatio =0;
		}
		else {
			slopeRatio = ((float)(tailY-headY))/((float)(tailX-headX));
		}
		
		//here's where all the real work is done.  getDelta returns the
		//desired location of a particular end point of the line in
		//coordinates relative to the center of the rectangle at each end.
		//given the points getDelta returns, we will know exactly how far
		//we should move our endpoints (which we originally placed in the
		//center of the two rectangles.
		Point deltaHead = getDelta(headBounds, lineAngle, slopeRatio, FROM_HEAD);
		Point deltaTail = getDelta(tailBounds, lineAngle, slopeRatio, FROM_TAIL);
			
		//make the appropriate adjustments to the coordinate of headPoint
		headPoint.x += Math.rint(deltaHead.x);
		headPoint.y += Math.rint(deltaHead.y);
		//make the appropriate adjustments to the coordinate of tailPoint
		tailPoint.x += Math.rint(deltaTail.x);
		tailPoint.y += Math.rint(deltaTail.y);
		
		//change the line
		setHead(headPoint);
		setTail(tailPoint);
	}
	
	
	//really the meat and potatoes of the setLineOutsideBox method.
	//takes a rectangle, a line angle in degrees, a slope for the same line,
	//and a direction.  it returns the point on the specified line where, if
	//we follow it in the specified direction from the rectangle's center,
	//it intersects with the rectangle's perimeter.  it returns the point
	//in coordinates relative to the center of the rectangle.
	private Point getDelta(Rectangle bounds, float lineAngle, float slopeRatio, int direction) {
		
		//first we create a diagonal in the rectangle.
		Line diagonal = new Line(0,0,bounds.width,bounds.height);
		
		//we get the slope in degrees of this diagonal so we can compare
		//it to the slope of our main line and see on which side of the
		//rectangle the line extends.
		float diag1 = diagonal.getSlopeAngle();
		
		//we use one diagonal to calculate the other.
		float diag2 = 180-(2*diag1);
		
		//if we imagine our point as originally in the center,
		//these variables will hold the updates that have to be made
		//to the location of that point.
		double deltaX, deltaY;
	
		//line is on top side of rectangle (coming from head)
		if((lineAngle >= diag1) && (lineAngle < (diag1+diag2))) {
			deltaY = -(bounds.getHeight()/2)*direction;
				if(slopeRatio == 0) deltaX = 0;
				else deltaX = (deltaY/slopeRatio);
		}
		
		//line is on right side of rectangle (coming from head)
		else if ((lineAngle > (diag1+diag2)) && (lineAngle <= ((3*diag1)+diag2))) {
				deltaX = (bounds.getWidth()/2)*direction;
				deltaY = (deltaX*slopeRatio);
			}
		
		//line is on bottom side of rectangle (coming from head)
		else if ((lineAngle >= ((3*diag1)+diag2)) && (lineAngle < ((3*diag1)+(2*diag2)))) {
				deltaY = (bounds.getHeight()/2)*direction;
				if(slopeRatio == 0) deltaX = 0;
				else deltaX = (deltaY/slopeRatio);
			}
		
		//line is on left side of rectangle (coming from head)
		else {
				deltaX = -(bounds.getWidth()/2)*direction;
				deltaY = (deltaX*slopeRatio);
		}
		return new Point((int)Math.rint(deltaX), (int)Math.rint(deltaY));
	}
}
