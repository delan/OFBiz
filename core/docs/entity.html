<html>
<head>
<title>Open For Business Entity Engine Guide</title>
</head>

<body>

<h2 align="center">The Open For Business Project: Entity Engine Guide</h2>

<br>Written By: David E. Jones
<br>Email: <a href="mailto:jonesde@ofbiz.org">jonesde@ofbiz.org</a>
<br>Open For Business Site: <a href="http://www.ofbiz.org/">http://www.ofbiz.org</a>
<br>
<A href="http://sf.net/projects/ofbiz"> <IMG src="http://sourceforge.net/sflogo.php?group_id=27173" border="0" alt="SourceForge Logo"></A> 
<br>
Founders and Lead Architects: David E. Jones &amp; Andy Zeneski <br>
Last Updated: November 19, 2001<br>
$Id$ <br>
<hr>
<br>
<h3>Table of Contents</h3>

<ul>
  <li><a href="#Related_Documents">Related Documents</a>
  <li><a href="#Introduction">Introduction</a>
  <li><a href="#Entity_Modeling">Entity Modeling</a>
  <li><a href="#View_Entity_Modeling">View Entity Modeling</a>
  <li><a href="#The_Entity_Engine_API">The Entity Engine API</a>
  <li><a href="#JTA_Support">JTA Support</a>
  <li><a href="#Core_Web_Tools">Core Web Tools</a>
</ul>

<hr>

<h3><a name="Related_Documents">Related Documents:</a></h3>
<hr>
<ul>
  <li><a href="entityconfig.html">Entity Engine Configuration Guide</a></li>
  <li><a href="api/index.html">Core JavaDoc (includes Entity Engine)</a></li>
  <li><a href="/dtds/entitymodel.dtd">Entity Model DTD</a></li>
  <li><a href="/dtds/entitygroup.dtd">Entity Group DTD</a></li>
  <li><a href="/dtds/fieldtypemodel.dtd">Field Type Model DTD</a></li>
</ul>

<hr>
<h3><a name="Introduction">Introduction</a></h3>
<hr>
<p>The Open For Business Entity Engine is a set of tools and patterns used to
model and manage entity specific data. In this context an entity is a piece of
data defined by a set of fields and a set of relations to other entities. This
definition comes from the standard Entity-Relation modeling concepts of
Relational Database Management Systems. The goal of the entity engine is to
simplify the enterprise wide use of entity data. This includes definition,
maintenance, quality assurance, and development of entity related functionality.&nbsp;</p>
<p>The entity engine uses a number of Business Tier and Integration Tier
patterns that will be recognized by most enterprise software programmers. Many
Presentation Tier patterns are also used in the Open For Busienss project, but
only in the servlet controller, not in the entity engine. The patterns used in
the Entity Engine include: Business Delegate, Value Object, Composite Entity
(variation), Value Object Assembler, Service Locator, and Data Access Object.
Implementations of other patterns and more complete implementations of these
Patterns are planned.</p>
<p> Descriptions of these
patterns are all available in the book &quot;Core J2EE Patterns&quot; by Alur,
Crupi, and Malks, published by Sun. You can also find information on these
patterns at the site that contains the early work of the authors before the
published book was finished. See <a href="http://developer.java.sun.com/developer/restricted/patterns/J2EEPatternsAtAGlance.html">http://developer.java.sun.com/developer/restricted/patterns/J2EEPatternsAtAGlance.html</a>.
Note that you need a Java Developers Connection account to view this
information.</p>
<p>&nbsp;In addition there are a number of patterns
used from the upcoming book &quot;EJB
Design Patterns&quot; by <a class="undecorated" href="mailto:floyd@middleware-company.com">Floyd
Marinescu</a> of TheServerSide.com. These include Data Transfer HashMap and
Generic Attribute Access. For unique primary key generation we use an original
pattern we like to call the &quot;Ethernet Key Generation&quot; pattern because
it uses a collision detection mechanism to insure that multiple servers can use a single
database to get banks of unique keys in a database independent way.</p>
<p>The primary goal of the entity engine is to eliminate the need for entity
specific persistence code in as many areas of a transactional application as
possible. Granted that this sort of abstraction is a different issue for
reporting and similar systems, but for transactional systems such as are used on
a day to day basis in all businesses, an entity engine can save a great deal of
development effort and dramatically reduce persistence related bugs in the
system. These types of applications include everything from ecommerce to
accounting to inventory and warehouse management to human resources and so on.
These tools can be useful for reporting and analytical systems, but really
aren't meant to allow for the wide variety of custom queries that often take
place in such tools.</p>
<p>In order to achieve having as little entity specific code as possible, all
value objects are generic, using a map to store the fields values of the entity
instance by name. The get and set methods for the fields take a String with the
fieldName in it which is used to verify that the field is part of the entity,
and then either get or set a value as desired. The danger of this flexibility is
curtailed using a contract between he entity engine and the application, this
is contained in a special XML file.</p>
<p>Instead of writing entity specific code, entity definitions are read from an
XML file and used by the entity engine to enforce a set of rules between the
application and the data source, be it a database or some other source. These XML entity
definitions specify the names of all of the entities and their fields along with
which database tables and columns they correspond to. They are also used to
specify a type for each field which is then looked up in the field types file for
the given data source to find the Java and SQL data types. Relations between
entities are also defined in this XML file. A relation is defined by specifying
the related table, the type of relation (one or many) and the keymaps for the
relation. A title can also be given to the relation which becomes part of its
name to distinguish it from other relations to that specific related
entity.&nbsp;</p>
<p>Using the Entity Engine as an abstraction layer, entity specific code can be
easily created and modified. Code that uses the Entity Engine APIs to interact
with entities can be deployed in various ways so that entity persistence can be
done differently without changing the code that interacts with those entities on
a higher level. An example of the usefulness of this abstraction is that by
changing a configuration file an application written using the Entity Engine
can switch from hitting a database directly through JDBC to using an EJB server
and Entitiy Beans for persistence. The same code could also be used for custom
data sources like legacy systems over HTTP or messaging services through a bit of custom coding within the same
framework.</p>


<hr>
<h3><a name="Entity_Modeling">Entity Modeling</a></h3>
<hr>
<p>The first thing to do when starting work with a new entity is to define or
model that entity. In the OFBiz Entity Engine this is done through two XML
files, one for entity modeling and the other for field type modeling. There are
links to the XML DTDs for these documents in the <a href="#Related Documents">Related
Documents</a> section above. The reason that these two files are separated is
that field type definitions can be database specific. In other words, for a
given entity model definition various field type definitions may exist for
different databases. When a persistence server is defined the field type model
XML file to be used for that server is specified.</p>
<p>The main entity model XML files for Open For Business can be found in <b>ofbiz/commonapp/entitydef/</b>.
Originally all of the entities were in the <b>entitymodel.xml</b> file, but now they are separated into various files
in addition to the <b>entitymodel.xml</b> file. They are all named after the following pattern: <b>entitymodel_*.xml</b></p>

<p>The MySQL field type model XML file for Open For Business can be found in <b>ofbiz/commonapp/entitydef/fieldtypemysql.xml</b>.
There are other database specific field type files for Postgres, Hypersonic, Oracle, et cetera.
From the entity model files and the field type files database tables can be created automatically through
the checkDataSource routine on the GenericHelper inteface. This can be done automatically on startup or through the tools in WebTools.</p>

<p>While tables can be created automatically, data must be loaded from data files. These
files can be either SQL scripts or XML Entity Engine files. All of the type information and other
pre-loaded information such as statuses, enumerations, geo data, etc., are located in
XML Entity Engine files in <b>ofbiz/commonapp/db/</b>. These files can be located and loaded automatically
by the <b>install.jsp</b> page in WebTools. This page looks in the directories specified in
the <b>entityengine.properties</b> file for a given entity group name and finds all .xml and .sql
files. These are listed and confirmation is requested by the page. Clicking on the Yes, Load Now link
will cause these files to attempt to be loaded. Error messages will appear in the page as
well as on the console or in log files. Data files can also be loaded one at a time by specifying the
full path of the .sql or .xml file in the load a single file form. While on the topic, XML Entity Engine files
can also be imported and exported through the import & export pages in WebTools.</p>

<p>As mentioned above an entity consists of a set of fields and a set of
relationships to other entities. In the XML entity definitions each of these are
specified in addition to attributes of the entity itself such as the entity
name, the corresponding table name, the package name for the entity, and meta
data about the entity such as the author, a copyright notice, a description, and
so forth. Here is an example of an XML entity definition:</p>

<pre>    &lt;entity title=&quot;Sample Entity&quot;
            copyright=&quot;Copyright (c) 2001 John Doe Enterprises&quot;
            author=&quot;John Doe&quot; version=&quot;1.0&quot;
            package-name=&quot;org.ofbiz.commonapp.sample&quot;
            entity-name=&quot;SampleEntity&quot;
            table-name=&quot;SAMPLE_ENTITY&quot;&gt;
      &lt;field name=&quot;primaryKeyFieldOne&quot; col-name=&quot;PRIMARY_KEY_FIELD_ONE&quot; type=&quot;id-ne&quot;&gt;&lt;/field&gt;
      &lt;field name=&quot;primaryKeyFieldTwo&quot; type=&quot;id-ne&quot;&gt;&lt;/field&gt;
      &lt;field name=&quot;fieldOne&quot; type=&quot;long-varchar&quot;&gt;&lt;/field&gt;
      &lt;field name=&quot;fieldTwo&quot; type=&quot;long-varchar&quot;&gt;&lt;/field&gt;
      &lt;field name=&quot;foreignKeyOne&quot; type=&quot;id&quot;&gt;&lt;/field&gt;
      &lt;prim-key field=&quot;primaryKeyFieldOne&quot; /&gt;
      &lt;prim-key field=&quot;primaryKeyFieldTwo&quot; /&gt;
      &lt;relation type=&quot;one&quot; rel-entity-name=&quot;OtherSampleEntity&quot;&gt;
        &lt;key-map field-name=&quot;foreignKeyOne&quot; rel-field-name=&quot;primaryKeyOne&quot; /&gt;
      &lt;/relation&gt;
      &lt;relation type=&quot;one&quot; title=&quot;Self&quot; rel-entity-name=&quot;SampleEntity&quot;&gt;
        &lt;key-map field-name=&quot;primaryKeyFieldOne&quot; /&gt;
        &lt;key-map field-name=&quot;primaryKeyFieldTwo&quot; /&gt;
      &lt;/relation&gt;
      &lt;relation type=&quot;many&quot; title=&quot;AllOne&quot; rel-entity-name=&quot;SampleEntity&quot;&gt;
        &lt;key-map field-name=&quot;primaryKeyFieldOne&quot; /&gt;
      &lt;/relation&gt;
    &lt;/entity&gt;</pre>

<p>This is a pretty simple entity that demonstrates a few small points. The meta
data at the top is all optional, and if left unspecified will default to meta
data defined for the entire entity model file. For example the &quot;description&quot;
element was left out, so the ModelReader will use the description specified at
the top of the XML file if one exists. The package-name is used to organize the
entities, and specify a default location for any code that would be entity
specific. This becomes extremely useful when you have an entity model with
hundreds of entities.</p>

<p> Notice
that while the field primaryKeyFieldOne has a column name specified, none of the other
fields do. The col-name and the table-name elements are optional. They can
be derived from the field name or entity name through widely used conventions.
These conventions dramatically simplify the definition of entities. Table and
column names are written in caps with underscores separating the words like
SAMPLE_ENTITY. Entity and field names are written using the Java conventions for
class and field names where all letters are lowercase except for the first
letter of each word, which is uppercase. Entity names correspond to Java classes
to the first letter is upper case but field names correspond to member fields of
a class so the first letter is lower case. For example: SampleEntity and
fieldOne correspond to SAMPLE_ENTITY and FIELD_ONE.</p>
<p>Multiple primary key columns can be specified using multiple &lt;prim-key&gt;
tags specifying the names of the primary key fields.</p>
<p>Field types are specified using a type string, which is defined in a
fieldtypemodel XML file specified by the fieldtypemodel.dtd XML Data Type
Definition. Each type maps to a Java type and an SQL type. Because of this
separation different fieldtypemodel XML files can be specified for different
databases allowing an entitymodel XML file to work with the various databases.
In addition, validators can be specified for a field type or for any field which
denote that the named validator should be called when data is input. These
validators are defined in the class <b>org.ofbiz.core.util.UtilValidate</b> and
follow the definition pattern: [<code>boolean isValid(String in);</code>].</p>
<p>Multiple relations can exist for each entity. Each relation is either of type
'one' or of type 'many' depending on the cardinality of the relation. If the
type is 'one' then the key-map elements must fully specifiy the primary key of
the related entity. If the type is many, the key-map elements do not need to
have any relation to the primary key of the related entity. If multiple
relations to the same related entity are used for a given entity, a title must
be specified to make the relation name unique. By this convention the relation
name is defined as [title][rel-table-name]. For the two SampleEntity relations
their names are SelfSampleEntity and AllOneSampleEntity. For OtherSampleEntity there is no title, so the relation name is simply OtherSampleEntity, or the name
of the related entity.</p>
<p>Key Maps are used to define how the related entity will be looked up. Each
key map specified a field name (field-name) and a related field name (rel-field-name).
If the two column names are the same, the rel-field-name does not have to be
specified.</p>

<hr>
<h3><a name="View_Entity_Modeling">View Entity Modeling</a></h3>
<hr>

<p>In addition to entities that map directly to a single relational table you can create "virtual" or "view" entities that map to a set of other entities.
The idea of a View Entity is the same as the idea of a view in Oracle, Access, or other popular database management systems. View Entities allow
you to combine, or join, entities to make a new entity. The new entity's fields will be aliases of the fields on the original entities. The member entities of the
view will be linked together by creating a set of view-links which contain key-maps, just like relationships do as described above.</p>

<p>The meta data for a view entity is nearly the same as for a normal entity. It has a name, package, description, copyright, author, version, and so forth.
It does not have a table name, since it does not map to a single relational table in the data source. A view entity must also be assigned to a group in the
entity group XML file, just like any normal entity.</p>

<pre>    &lt;view-entity title=&quot;Sample View Entity&quot;
            copyright=&quot;Copyright (c) 2001 John Doe Enterprises&quot;
            author=&quot;John Doe&quot; version=&quot;1.0&quot;
            package-name=&quot;org.ofbiz.commonapp.sample&quot;
            entity-name=&quot;SampleViewEntity&quot;&gt;
      &lt;member-entity entity-alias=&quot;SE&quot; entity-name=&quot;SampleEntity&quot; /&gt;
      &lt;member-entity entity-alias=&quot;OSE&quot; entity-name=&quot;OtherSampleEntity&quot; /&gt;
      &lt;alias entity-alias=&quot;SE&quot; name=&quot;primaryKeyFieldOne&quot; prim-key=&quot;true&quot; /&gt;
      &lt;alias entity-alias=&quot;SE&quot; name=&quot;primaryKeyFieldTwo&quot; prim-key=&quot;true&quot; /&gt;
      &lt;alias entity-alias=&quot;SE&quot; name=&quot;fieldOne&quot; /&gt;
      &lt;alias entity-alias=&quot;SE&quot; name=&quot;fieldTwo&quot; /&gt;
      &lt;alias entity-alias=&quot;OSE&quot; name=&quot;primaryKeyOne&quot; prim-key=&quot;true&quot; /&gt;
      &lt;alias entity-alias=&quot;OSE&quot; name=&quot;otherFieldOne&quot; field=&quot;fieldOne&quot; /&gt;
      &lt;view-link entity-alias=&quot;SE&quot; rel-entity-alias=&quot;OSE&quot;&gt;
        &lt;key-map field-name=&quot;foreignKeyOne&quot; rel-field-name=&quot;primaryKeyOne&quot; /&gt;
      &lt;/view-link&gt;
      &lt;relation type=&quot;one&quot; rel-entity-name=&quot;OtherSampleEntity&quot;&gt;
        &lt;key-map field-name=&quot;primaryKeyOne&quot; /&gt;
      &lt;/relation&gt;
      &lt;relation type=&quot;many&quot; title=&quot;AllOne&quot; rel-entity-name=&quot;SampleEntity&quot;&gt;
        &lt;key-map field-name=&quot;primaryKeyFieldOne&quot; /&gt;
      &lt;/relation&gt;
    &lt;/view-entity&gt;</pre>

<p>Normal entities that will become part of the view entity are referred to as member entities. Each member entity is given an alias and 
is referred to by that alias for the rest of the definition. This allows a single entity to be linked in multiple times.</p>

<p>Rather than specifying fields with a view entity you specify aliases. Each alias is effectively a field in usage and is defined
by being mapped to a field on an aliases member entity. If the field name is that same as the alias name, there is no need to specify it. In
other words if no field name is specified the alias name will be used as the field name to map to on the member entity with the specified
entity-alias.</p>

<p>View links are used to specify the links between the member-entities of the view. They link one entity-alias to another and use
key-maps just like relations. Here the field-name specifies the name of the field on the aliased entity and the rel-field-name the field on
the related aliased entity. As with many other things, the rel-field-name is optional if it is the same as the field-name.</p>

<p>View Entities have primary keys just like normal entities. Specifying that an alias is a primary key is done by using the prim-key attribute.</p>
<p>The primary key for a view entity should include all primary key fields of each
member entity of the view. This means that all of the primary key fields must be aliased, but fields that are used to link the entities need only be aliased
once. For example, if an OrderHeader entity has an orderId primary key and an OrderLine entity has an orderId primary key and an orderLineSeqId
primary key, and the orderId was the mapped key that links the two entities, then the view entity would have two primary keys: orderId and
orderLineSeqId. In this case orderId would only be aliased once since by definition the orderIds from each entity will always be the same since
that is how the entities are linked (or joined).</p>

<p>Relationships are specified the same way with view entities as they are with normal entities. That key-map attributes are still called
field-name and rel-field-name but in the case of view entities the field name is actually the alias name that will be looked up.</p>

<hr>
<h3><a name="The_Entity_Engine_API">The Entity Engine API</a></h3>
<hr>
<p>The Entity Engine classes in the package <b> org.ofbiz.core.entity</b> define the
API used to interact with Entity Engine entity data. From a users point of view
only three classes really need to be understood. They are <b>GenericDelegator</b>,
<b>GenericValue</b> and <b>GenericPK</b>. The <b>GenericDelegator</b> class, usually used with the
instance name '<b>delegator</b>', is used to do create, find, store and other operations on a
<b>GenericValue</b> object. Once a <b> GenericValue</b> object is created it will contain a
reference to the delegator that created it and through this reference it knows how
to store, remove and do other operations without requiring a program to invoke methods on the delegator
itself.</p>

<p>I've been trying to think of how best to present information about this API,
but short of writing a number of documents about the specific usage of each
piece, there is not much that is useful that I could write here. I recommend
reading through the JavaDocs for the core module, specifically the <b>
org.ofbiz.core.entity</b> package, and browsing through the eCommerce and other applications
which make heavy use of this API.</p>

<p>A few quick notes to help you get started might be in order. Rather than
trying to construct a GenericValue or a GenericPK yourself, you should use the <b>makeValue</b>
and <b>makePK</b> methods on the <b>GenericDelegator</b>. These create an object
without persisting it and allow you to add to it and create or store it later
using their own <b>create</b> method, or calling the <b>create</b> method on the
<b>delegator</b> object.</p>

<p>Value instances can be retrieved from the database with the <b>findByPrimaryKey</b>
methods, or a collection can be retrieved using the <b>findAll</b> or <b>findByAnd</b> methods.</p>

<p>There are two main types of findByAnd methods. Each type has a number of variations
that may include the use of a cache, and may accept an orderBy field list. The two
main types accept different field lists. One accepts a Map of fields and finds entities
by anding together expressions where each named field must equal the corresponding value
in the map. The other type of findByAnd accepts a list of <b>EntityExpr</b> objects which
are used to specify small expressions that will be anded together. Each EntityExpr specifies
a field name, an operation, and a value for the field.</p>

<p>For storing multiple entities the <b>GenericValue</b> class has methods
called <b>preStoreOther</b> and <b>preStoreOthers</b> which take one and many
(respectively) <b>GenericValue</b> instances and store them in the same database
transaction when the primary entity is created or stored. Actually, to say that
it stores them is incorrect. It checks to see if they exist and if so does an
update, if not it does an insert. This may be optimized in the future for speed
by allowing you to specify whether it should be inserted or updated based on
prior knowledge of the existence if that entity.</p>

<p>You can also store multiple entities in a single call, and transaction, through the
delegator.storeAll method, which acts nearly the same as the preStore methods, but does
not use a single value object to attach the others to.<p>

<p>Removal of entities is done through the <b>remove</b> method on either the <b>delegator</b>,
or the <b>GenericValue</b>.</p>

<hr>
<h3><a name="JTA_Support">JTA Support</a></h3>
<hr>

<p>The Entity Engine JTA Support is simple to use, but has a few complications in configuration.
The support runs through an API and a Factory class so that no direct contact with the
particular JTA implementation is necessary. The TransactionFactory class can be used to
get the two main objects needed for JTA use: UserTransaction and TransactionManager. The
current implementation supports the Tyrex JTA/JTS implementation. To use a different
implementation simply change the TransactionFactory class, everything else uses that. 
That's the tricky configuration part, if you aren't using Tyrex. For Tyrex make sure a domain
configuration XML file called tyrexdomain.xml must be on the running classpath.</p>

<p>To demarcate transactions you can use the TransactionUtil class which wraps the UserTransaction 
class and only throws GenericEntityExceptions, well, and runtime exceptions. The basic methods needed are 
begin(), commit(), and rollback(), but the rest are included and can be very useful. A transaction
is attached to the current thread so it is not necessary to pass it around all over the place.
After beginning a transaction make sure it is always either committed or rolled back. This is 
normally done by committing at the end of a try block and and rolling back in each catch block. 
You can also use the standard UserTransaction object by getting one from the TransactionFactory.</p>

<hr>
<h3><a name="Core_Web_Tools">Core Web Tools</a></h3>
<hr>

<p>The WebTools web application contains a number of useful tools for working
with the entity engine. These include a cross linked reference to the entity
definitions, a tool for editing entity and relation definitions, and a JSP which
acts as an XML template and also saves the XML entity definitions to their corresponding files. </p>

<p>There is also a JSP that acts as a front end to the routines which checks the
current state of the database table definitions and reports any differences.
Where possible tables or columns which are missing can be added to the database.
This is the same routine which optionally runs when the server loads and
optionally creates missing tables and columns.</p>

<p>The entity code generator has been removed from the project, or deprecated if
you will, because of the next generation entity tool which is the entity engine
described herein. There are still some occasions where the use of templates to
create entity specific code or other text is still useful, and in fact,
necessary. One example of this is the JSP which creates the XML for the entity
definitions from those definitions, and is used for writing out the XML after
entity definitions have changed. Other uses for templates include manually
generating database specific table creation SQL and quick start JSPs and event
handlers which allow for finding, viewing and editing entity specific data.
These can be used as starting points for task specific applications.</p>

<p>Where entity data editing is not task specific, but instead is entity
specific, the Entity Data Maintenance pages in WebTools can be used. They are
dynamic pages that rely on the in memory entity definitions to create forms for
the entering of data, and event for handing the entered data (including
validators specified in the entity definition), and finding specific entities by
any of the fields on the entity, or finding any relation entity instances for a
given entity instance. For instance, when viewing the OrderHeader entity all of
the relations to that entity can be viewed as well, including links to edit and
view them. These related entities would include OrderType (one relation),
OrderLine (many relation), and many others.</p>

<p>Data in the database can be imported from and exported to Entity Engine XML files
in the import and export pages. Importing data causes corresponding entity instances
to either be created or updated, depending on whether or not they already exist. The
Export page allows you to specify which entities you want to export the data for by
using a big list of check boxes, one for each entity. For more granular control over
exported data, the Entity Data Maintenance pages mentioned above would be the place
to look (not yet finished though...).</p>

</body>

</html>
