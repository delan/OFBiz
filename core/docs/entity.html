<html>
<head>
<title>Open For Business Entity Engine</title>
      <title>Postal Address Entity</title>
      <package-name>
</head>

<body>

<h2 align="center">The Open For Business Project: Entity Engine</h2>

<br>Written By: David E. Jones
<br>Email: <a href="mailto:jonesde@ofbiz.org">jonesde@ofbiz.org</a>
<br>Open For Business Site: <a href="http://www.ofbiz.org/">http://www.ofbiz.org</a>
<br><A href="http://sf.net/projects/ofbiz"> <IMG src="http://sourceforge.net/sflogo.php?group_id=27173" border="0" alt="SourceForge Logo"></A>
<br>
Last Updated: September 15, 2001<br>
$Id$ <br>
<h3>Table of Contents</h3>

<ul>
	<li><a href="#Related Documents">Related Documents</a>
	<li><a href="#Introduction">Introduction</a>
	<li><a href="#Entity Modeling">Entity Modeling</a>
	<li><a href="#The Generic Entity">The Generic Entity</a>
	<li><a href="#CommonApp Tools">CommonApp Tools</a>
</ul>

<hr>

<h3><a name="Related Documents">Related Documents:</a></h3>
<hr>
<ul>
  <li><a href="api/index.html">Core JavaDoc (including Entity Engine)</a></li>
  <li><a href="entitymodel.dtd">Entity Model DTD</a></li>
  <li><a href="entitygroup.dtd">Entity Group DTD</a></li>
  <li><a href="fieldtypemodel.dtd">Field Type Model DTD</a></li>
</ul>

<hr>
<h3><a name="Introduction">Introduction</a></h3>
<hr>
<p>The Open For Business Entity Engine is a set of tools and patterns used to
model and manage entity specific data. In this context an entity is a piece of
data defined by a set of fields and a set of relations to other entities. This
definition comes from the standard Entity-Relation modeling concepts of
Relational Database Management Systems. The goal of the entity engine is to
simplify the enterprise wide use of entity data. This includes definition,
maintenance, quality assurance, and development of entity related functionality.&nbsp;</p>
<p>The entity engine uses a number of Business Tier and Integration Tier
patterns that will be recognized by most enterprise software programmers. Many
Presentation Tier patterns are also used in the Open For Busienss project, but
only in the servlet controller, not in the entity engine. The patterns used in
the Entity Engine include: Business Delegate, Value Object, Composite Entity
(variation), Value Object Assembler, Service Locator, and Data Access Object.
Implementations of other patterns and more complete implementations of these
Patterns are planned.</p>
<p> Descriptions of these
patterns are all available in the book &quot;Core J2EE Patterns&quot; by Alur,
Crupi, and Malks, published by Sun. You can also find information on these
patterns at the site that contains the early work of the authors before the
published book was finished. See <a href="http://developer.java.sun.com/developer/restricted/patterns/J2EEPatternsAtAGlance.html">http://developer.java.sun.com/developer/restricted/patterns/J2EEPatternsAtAGlance.html</a>.
Note that you need a Java Developers Connection account to view this
information.</p>
<p>&nbsp;In addition there are a number of patterns
used from the upcoming book &quot;EJB
Design Patterns&quot; by <a class="undecorated" href="mailto:floyd@middleware-company.com">Floyd
Marinescu</a> of TheServerSide.com. These include Data Transfer HashMap and
Generic Attribute Access. For unique primary key generation we use an original
pattern we like to call the &quot;Ethernet Key Generation&quot; pattern because
it uses a collision detection mechanism to insure that multiple servers can use a single
database to get banks of unique keys in a database independent way.</p>
<p>The primary goal of the entity engine is to eliminate the need for entity
specific persistence code in as many areas of a transactional application as
possible. Granted that this sort of abstraction is a different issue for
reporting and similar systems, but for transactional systems such as are used on
a day to day basis in all businesses, an entity engine can save a great deal of
development effort and dramatically reduce persistence related bugs in the
system. These types of applications include everything from ecommerce to
accounting to inventory and warehouse management to human resources and so on.
These tools can be useful for reporting and analytical systems, but really
aren't meant to allow for the wide variety of custom queries that often take
place in such tools.</p>
<p>In order to achieve having as little entity specific code as possible, all
value objects are generic, using a map to store the fields values of the entity
instance by name. The get and set methods for the fields take a String with the
fieldName in it which is used to verify that the field is part of the entity,
and then either get or set a value as desired. The danger of this flexibility is
curtailed using a contract between he entity engine and the application, this
is contained in a special XML file.</p>
<p>Instead of writing entity specific code, entity definitions are read from an
XML file and used by the entity engine to enforce a set of rules between the
application and the data source, be it a database or some other source. These XML entity
definitions specify the names of all of the entities and their fields along with
which database tables and columns they correspond to. They are also used to
specify a type for each field which is then looked up in the field types file for
the given data source to find the Java and SQL data types. Relations between
entities are also defined in this XML file. A relation is defined by specifying
the related table, the type of relation (one or many) and the keymaps for the
relation. A title can also be given to the relation which becomes part of its
name to distinguish it from other relations to that specific related
entity.&nbsp;</p>
<p>Using the Entity Engine as an abstraction layer, entity specific code can be
easily created and modified. Code that uses the Entity Engine APIs to interact
with entities can be deployed in various ways so that entity persistence can be
done differently without changing the code that interacts with those entities on
a higher level. An example of the usefulness of this abstraction is that by
changing a configuration file an application written using the Entity Engine
can switch from hitting a database directly through JDBC to using an EJB server
and Entitiy Beans for persistence. The same code could also be used for custom
data sources like legacy systems over HTTP or messaging services through a bit of custom coding within the same
framework.</p>
<p>The basic tools in the package can be divided into three interacting
packages. The first is the package used to define entity models. The second is
the Generic Entity which is a set of Java code used to implement persistence and
other entity management features. The third is the Web-based Tool Set in the
CommonApp module.</p>
<p>The configuration of the Entity Engine is done through a simple properties
file called <b> servers.properties</b> that must exist somewhere on the classpath. This
properties file is used to define parameters for persistence servers such as EJB
server parameters or JDBC server parameters. It is also used to specify which
XML entity, entity group, and field type model files will be used for that server.
The default file for the OFBiz distribution can be found in <b>ofbiz/commonapp/etc/servers.properties</b>.</p>

<p>Each application that uses the Entity Engine does so through a <b>GenericDelegator</b>
instance. The delegator name must be passed to the static factory method which
is then passed to the constructor if a new instance is needed. This delegator
name is used to look up settings for that delegator in the <b>servers.properties</b>
file. Each delegator uses an entity model XML file and an entity group XML file
which specifies a group name for each named entity in the entity model file. The
<b>servers.properties</b> file contains the settings which map each group name
to a <b>GenericHelper</b> for that group. <b>GenericHelper</b> is an interface
that must be implemented for each type of data source (ie: JDBC, EJB, SOAP,
HTTP, et cetera).&nbsp;</p>

<p>The setting for each named <b>GenericHelper</b> are specified in the <b>servers.properties</b>
file. For a JDBC helper these would include database connection parameters such
as either the JNDI data source name or the JDBC parameters including the driver
name, the JDBC URI, and the username and password for the database. An EJB
helper would contain the context provider URL, the initial context factory, and
the URL package prefixes.</p>

<p>The <b>GenericDelegator</b> is the primary access method for Entity Engine
services. Each service request is dispatched to the helper that corresponds to
the entity that the service is requested for according to the group name of the
entity specified in the entity group XML file and the helper for that group
specified in the <b>servers.properties</b> file. The default entity group XML
file for the OFBiz entity model can be found in <b>ofbiz/commonapp/entitydef/entitygroup.xml</b>.</p>

<hr>
<h3><a name="Entity Modeling">Entity Modeling</a></h3>
<hr>
<p>The first thing to do when starting work with a new entity is to define or
model that entity. In the OFBiz Entity Engine this is done through two XML
files, one for entity modeling and the other for field type modeling. There are
links to the XML DTDs for these documents in the <a href="#Related Documents">Related
Documents</a> section above. The reason that these two files are separated is
that field type definitions can be database specific. In other words, for a
given entity model definition various field type definitions may exist for
different databases. When a persistence server is defined the field type model
XML file to be used for that server is specified.</p>
<p>The main entity model XML file for Open For Business can be found in <b>ofbiz/commonapp/entitydef/entitymodel.xml</b>.
The MySQL field type model XML file for Open For Business can be found in <b>ofbiz/commonapp/entitydef/fieldtypemysql.xml</b>.
From these two files the SQL code used to define tables and populate security
settings for the entities can be automatically generated through the tools in
commonapp. In addition to these generated SQL scripts there are two others that
must be run for commonapp. The first is <b>ofbiz/commonapp/db/commonapp-data-mysql.sql</b>
and it contains sample data and administration accounts for commonapp, and can
be used to get other applications started as well. The second is <b>ofbiz/commonapp/db/datamodel-data.sql</b>
which has all of the entity type definitions which correspond to the entities
definted in <b>entitymodel.xml</b>. When I say entity type definitions, I am referring
to the entity types used in the entity extensibility pattern defined in the
Entity Overview document on the OFBiz website.</p>
<p>As mentioned above an entity consists of a set of fields and a set of
relations to other entities. In the XML entity definitions each of these things
is specified in addition to attributes of the entity itself such as the entity
name, the corresponding table name, the package name for the entity, and meta
data about the entity such as the author, a copyright notice, a description, and
so forth. Here is an example of an XML entity definition:</p>

<pre>    &lt;entity title=&quot;Sample Entity&quot;
            copyright=&quot;Copyright (c) 2001 John Doe Enterprises&quot;
            author=&quot;John Doe&quot; version=&quot;1.0&quot;
            package-name=&quot;org.ofbiz.commonapp.sample&quot;
            entity-name=&quot;SampleEntity&quot;
            table-name=&quot;SAMPLE_ENTITY&quot;&gt;
      &lt;field name=&quot;primaryKeyFieldOne&quot; col-name=&quot;PRIMARY_KEY_FIELD_ONE&quot; type=&quot;id-ne&quot;&gt;&lt;/field&gt;
      &lt;field name=&quot;primaryKeyFieldTwo&quot; type=&quot;id-ne&quot;&gt;&lt;/field&gt;
      &lt;field name=&quot;fieldOne&quot; type=&quot;long-varchar&quot;&gt;&lt;/field&gt;
      &lt;field name=&quot;fieldTwo&quot; type=&quot;long-varchar&quot;&gt;&lt;/field&gt;
      &lt;field name=&quot;foreignKeyOne&quot; type=&quot;id&quot;&gt;&lt;/field&gt;
      &lt;prim-key field=&quot;primaryKeyFieldOne&quot; /&gt;
      &lt;prim-key field=&quot;primaryKeyFieldTwo&quot; /&gt;
      &lt;relation type=&quot;one&quot; rel-entity-name=&quot;otherSampleEntity&quot;&gt;
        &lt;key-map field-name=&quot;foreignKeyOne&quot; rel-field-name=&quot;primaryKeyOne&quot; /&gt;
      &lt;/relation&gt;
      &lt;relation type=&quot;one&quot; title=&quot;Self&quot; rel-entity-name=&quot;SampleEntity&quot;&gt;
        &lt;key-map field-name=&quot;primaryKeyFieldOne&quot; /&gt;
        &lt;key-map field-name=&quot;primaryKeyFieldTwo&quot; /&gt;
      &lt;/relation&gt;
      &lt;relation type=&quot;many&quot; title=&quot;AllOne&quot; rel-entity-name=&quot;SampleEntity&quot;&gt;
        &lt;key-map field-name=&quot;primaryKeyFieldOne&quot; /&gt;
      &lt;/relation&gt;
    &lt;/entity&gt;</pre>

<p>This is a pretty simple entity that demonstrates a few small points. The meta
data at the top is all optional, and if left unspecified will default to meta
data defined for the entire entity model file. For example the &quot;description&quot;
element was left out, so the ModelReader will use the description specified at
the top of the XML file if one exists. The package-name is used to organize the
entities, and specify a default location for any code that would be entity
specific. This becomes extremely useful when you have an entity model with
hundreds of entities.</p>

<p> Notice
that while the field primaryKeyFieldOne has a column name specified, none of the other
fields do. The col-name and the table-name elements are optional. They can
be derived from the field name or entity name through widely used conventions.
These conventions dramatically simplify the definition of entities. Table and
column names are written in caps with underscores separating the words like
SAMPLE_ENTITY. Entity and field names are written using the Java conventions for
class and field names where all letters are lowercase except for the first
letter of each word, which is uppercase. Entity names correspond to Java classes
to the first letter is upper case but field names correspond to member fields of
a class so the first letter is lower case. For example: SampleEntity and
fieldOne correspond to SAMPLE_ENTITY and FIELD_ONE.</p>
<p>Multiple primary key columns can be specified using multiple &lt;prim-key&gt;
tags specifying the names of the primary key fields.</p>
<p>Field types are specified using a type string, which is defined in a
fieldtypemodel XML file specified by the fieldtypemodel.dtd XML Data Type
Definition. Each type maps to a Java type and an SQL type. Because of this
separation different fieldtypemodel XML files can be specified for different
databases allowing an entitymodel XML file to work with the various databases.
In addition, validators can be specified for a field type or for any field which
denote that the named validator should be called when data is input. These
validators are defined in the class <b>org.ofbiz.core.util.UtilValidate</b> and
follow the definition pattern: [<code>boolean isValid(String in);</code>].</p>
<p>Multiple relations can exist for each entity. Each relation is either of type
'one' or of type 'many' depending on the cardinality of the relation. If the
type is 'one' then the key-map elements must fully specifiy the primary key of
the related entity. If the type is many, the key-map elements do not need to
have any relation to the primary key of the related entity. If multiple
relations to the same related entity are used for a given entity, a title must
be specified to make the relation name unique. By this convention the relation
name is defined as [title][rel-table-name]. For the two SampleEntity relations
their names are SelfSampleEntity and AllOneSampleEntity. For OtherSampleEntity there is no title, so the relation name is simply OtherSampleEntity, or the name
of the related entity.</p>
<p>Key Maps are used to define how the related entity will be looked up. Each
key map specified a field name (field-name) and a related field name (rel-field-name).
If the two column names are the same, the rel-field-name does not have to be
specified.</p>

<hr>
<h3><a name="The Generic Entity">The Generic Entity</a></h3>
<hr>
<p>The Generic Entity classes in the package <b> org.ofbiz.core.entity</b> define the
API used to interact with Entity Engine entity data. From a users point of view
only three classes really need to be understood. They are <b>GenericDelegator</b>,
<b>
GenericValue</b> and <b>GenericPK</b>. The <b>GenericDelegator</b> class, usually used with the
instance name '<b>delegator</b>', is used to do create, find, store and other operations on a
<b>
GenericValue</b> object. Once a <b> GenericValue</b> object is created it will contain a
reference to the delegator that created it and through this reference it knows how
to store, remove and do other operations without invoking methods on the delegator
itself.</p>

<p>I've been trying to think of how best to present information about this API,
but short of writing a number of documents about the specific usage of each
piece, there is not much that is useful that I could write here. I recommend
reading through the JavaDocs for the core module, specifically the <b>
org.ofbiz.core.entity</b> package, and browsing through the eCommerce application
which makes heavy use of this API.</p>

<p>A few quick notes to help you get started might be in order. Rather than
trying to construct a GenericValue or a GenericPK yourself, you should use the <b>makeValue</b>
and <b>makePK</b> methods on the <b>GenericDelegator</b>. These create an object
without persisting it and allow you to add to it and create or store it later
using their own <b>create</b> method, or calling the <b>create</b> method on the
<b>delegator</b> object.</p>

<p>Value instances can be retrieved from the database with the <b>findByPrimaryKey</b>
method, or a collection can be retrieved using the <b>findByAnd</b> method.</p>

<p>For storing multiple entities the <b>GenericValue</b> class has methods
called <b>preStoreOther</b> and <b>preStoreOthers</b> which take one and many
(respectively) <b>GenericValue</b> instances and store them in the same database
transaction when the primary entity is created or stored. Actually, to say that
it stores them is incorrect. It checks to see if they exist and if so does an
update, if not it does an insert. This may be optimized in the future for speed
by allowing you to specify whether it should be inserted or updated based on
prior knowledge of the existence if that entity.</p>

<p>Removal of entities is done through the <b>remove </b>method on either the <b>delegator</b>,
or the <b>GenericValue</b>.</p>

<hr>
<h3><a name="CommonApp Tools">CommonApp Tools</a></h3>
<hr>

<p>The CommonApp web application contains a number of useful tools for working
with the entity engine. These include a cross linked reference to the entity
definitions, a tool for editing entity and relation definitions, and a JSP which
acts as an XML template saving the XML entity definitions. </p>
<p>There is also a JSP that acts as a front end to the routines which checks the
current state of the database table definitions and reports any differences.
Where possible tables or columns which are missing can be added to the database.
This is the same routine which optionally runs when the server loads and
optionally creates missing tables and fields.</p>
<p>The entity code generator has been removed from the project, or deprecated if
you will, because of the next generation entity tool which is the entity engine
described herein. There are still some occasions where the use of templates to
create entity specific code or other text is still useful, and in fact,
necessary. One example of this is the JSP which creates the XML for the entity
definitions from those definitions, and is used for writing out the XML after
entity definitions have changed. Other uses for templates include manually
generating database specific table creation SQL and quick start JSPs and event
handlers which allow for finding, viewing and editing entity specific data.
These can be used as starting points for task specific applications.</p>
<p>Where entity data editing is not task specific, but instead is entity
specific, the Entity Data Maintenance pages in CommonApp can be used. They are
dynamic pages that rely on the in memory entity definitions to create forms for
the entering of data, and event for handing the entered data (including
validators specified in the entity definition), and finding specific entities by
any of the fields on the entity, or finding any relation entity instances for a
given entity instance. For instance, when viewing the OrderHeader entity all of
the relations to that entity can be viewed as well, including links to edit and
view them. These related entities would include OrderType (one relation),
OrderLine (many relation), and many others.</p>

</body>

</html>
