<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <title>Open For Business Services Framework</title>

</head>
<body>

<h2 align="Center">The Open For Business Project: Services Framework</h2>
<br>
  Written By: Andy Zeneski<br>
  E-mail: <a href="mailto:jaz@ofbiz.org">jaz@ofbiz.org</a>
<br>
  Open For Business Site: <a href="http://www.ofbiz.org/">http://www.ofbiz.org</a>
<br>
<a href="http://sf.net/projects/ofbiz"><img src="http://sourceforge.net/sflogo.php?group_id=27173" border="0" alt="SourceForge Logo">
</a>
<br>
  Founders and Lead Architects: David E. Jones &amp; Andy Zeneski <br>
  Last Updated: January 16, 2003<br>
  $Id$<br>
<hr><br>
<h3>Table of Contents</h3>
<ul>
  <li><a href="#Related_Documents">Related Documents</a></li>
  <li><a href="#Introduction">Introduction</a> </li>
  <li><a href="#ServiceDispatcher">Service Dispatcher</a> </li>
  <li><a href="#DispatchContext">Dispatch Context</a> </li>
  <li><a href="#ServiceEngine">Service Engine</a> </li>
  <li><a href="#JobScheduler">Job Scheduler</a> </li>
  <li><a href="#ServiceDefinition">Service Definition</a></li>
  <li><a href="#Usage">Usage</a></li>
  <li><a href="#Advanced">Advanced:</a></li>
  <ul>
    <li><a href="#Interfaces">Interfaces</a></li>    
    <li><a href="#ECAs">ECAs</a></li>
    <li><a href="#Groups">Service Groups</a></li>
    <li><a href="#Route">Route Services</a></li>
    <li><a href="#HTTP">HTTP Services</a></li>
    <li><a href="#JMS">JMS Services</a></li>    
  </ul>
</ul>
<hr>
<h3><a name="Related_Documents">Related Documents:</a></h3>
<hr>
<ul>
  <li><a href="api/index.html">Core JavaDoc (including Service Engine)</a></li>
  <li><a href="serviceconfig.html">Service Engine Configuration Guild</a></li>
  <li><a href="/dtds/services.dtd">Services Definition DTD</a></li>
</ul>
<hr>
<h3><a name="Introduction">Introduction</a>
</h3>
<hr>
<p>The Services Framework is new to OFBiz in Version 2. Services are defined as
  independent pieces of logic which when placed together can be used to process
  many different types of business requirements. Services can be of many different
  types: Workflow, Rules, Java, SOAP, BeanShell, etc. A service with the type
  Java is much like an event where it is a static method, however with the Services
  Framework we do not limit to web based applications. Services require input
  parameters to be in a Map and the results are returned in a Map as well. This
  is nice since a Map can be serialized and stored or passed via HTTP (SOAP).
  Services are defined through the <a href="#ServiceDefinition">Service Definition</a>
  and are assigned to a specific <a href="#ServiceEngine">Service Engine</a>.
  Each <a href="#ServiceEngine">Service Engine</a> is responsible for invoking
  the defined service in an appropriate way. Since services are not tied to web
  based applications this allows services to run when there is no response object
  available. This allows services to be scheduled to run at specific times to
  run in the background via the <a href="#JobScheduler">Job Scheduler</a>.</p>
<p>Services have the ability to call other services. So, chaining small services
  together to accomplish a larger task makes reusing existing services much easier.
  Services which are used in different applications can be defined only once by
  creating Global Service Definition files or services specific to an application
  can be restricted and available only to that application. </p>
<p>When used in a web application services are available to web events, which
  allow events to stay small and reuse existing logic in the Services Framework.
  Also, services can be defined as 'exportable' which means they are allowed to
  be accessed by outside parties. Currently there is a SOAP EventHandler which
  allows services to be made available via SOAP. Other forms of remote invocation
  may be added to the framework in the future. </p>
<hr>
<h3><a name="ServiceDispatcher">Service Dispatcher</a> </h3>
<hr>
<p>The Service Dispatcher handles dispatching services to the appropriate <a href="#ServiceEngine">Service
  Engine</a> where it is then invoked. There is exactly one ServiceDispatcher
  for each Entity Delegator. If there are multiple delegators in an application
  there will also be multiple dispatchers. The ServiceDispatcher is accessed via
  a LocalDispatcher. There can be many LocalDispatchers associated with a ServiceDispatcher.
  Each LocalDispatcher is uniquely named and contains its own list of service
  definitions. When creating an instance of a LocalDispatcher, a <a href="#DispatchContext">DispatchContext
  </a>is also created and passed to the ServiceEngine.</p>
<p>A LocalDispatcher is associated with an application. Applications never talk
  directly to the ServiceDispatcher. The LocalDispatcher contains an API for invoking
  services, which are routed through the ServiceDispather. However, applications
  may be running in different threads then the actual ServiceDispatcher, so it
  is left to the LocalDispatcher to keep a <a href="#DispatchContext">DispatchContext</a>
  which among other things keeps a reference to the applications classloader.</p>
<hr>
<h3><a name="DispatchContext">Dispatch Context</a>
</h3>
<hr>
<p>The DispatchContext is created by the LocalDispatcher upon instantiation. This
  is the runtime dispatcher context. It contains necessary information to process
  services for each dispatcher. This context contains the reference to each of
  the service definition files, the classloader which should be used for invocation,
  a reference to the delegator and its dispatcher along with a 'bag' of user defined
  attributes. This context is passed on to each service when invoked and is used
  by the dispatcher to determine the service's model.<br>
</p>
<hr>
<h3><a name="ServiceEngine">ServiceEngine</a>
</h3>
<hr>
<p>This is where the service is actually invoked. Each service has an engine name
  assigned in its definition. This engine name is mapped via the servicesengine.xml
  file and is instantiated by the GenericEngineFactory when called upon. Third-party
  engines are supported and must follow the GenericEngine interface when implemented.
  See the Service Engine configuration guild for details on defining engines.</p>

<p>It is the job of the engine to handle invocation of both synchronous and asynchronous
  services. Engines which use the <a href="#JobScheduler">Job Scheduler</a> for
  asynchronous services can extend the GenericAsyncEngine.<br>
  <br>
</p>
<hr>
<h3><a name="JobScheduler">Job Scheduler</a>
</h3>
<hr>
<p>The overhauled job scheduler is now integrated with the services framework.
  This is the most appropriate place for a scheduler. Since it cannot be guarantee
  that a HttpServletRequest and HttpServletResponse object will be available when
  a job is ready to run it does not make sense to integrate with the web controller.
  Plus, this feature is most useful if it were not limited to web environments.
</p>
<p>The scheduler is a multithreaded component with a single thread used for job
  managing/scheduling and separate threads used for invocation of each service.
  When a job is scheduled to run, the scheduler will call the service dispatcher
  associated with the job to invoke the service in its own thread. This will prevent
  long or time consuming jobs from slowing down other jobs in the queue.</p>
<p>The scheduler now supports the iCalendar rule structure for recurrence. The
  jobs are no longer stored in an XML file and is part of a ServiceDispatcher.
  There is one Job Scheduler for each ServiceDispatcher (which means there is
  only one per GenericDelegator as well).</p>
<p><b>How it works:</b></p>
<p>The best usage example of the scheduler is an asynchronous service call. When
  an asynchronous service is invoked, it is passed to the Job Scheduler to be
  queued to run. A recurrence entry is created (RecurrenceInfo and RecurrenceRule
  entities are created), the job is stored, (JobSandbox entity is created) and
  the context (Map) is serialized and stored (RuntimeData entity is created).
  The scheduler then adds the job to the top of the list of scheduled jobs (asynchronous
  services do not have any delay time) and invoked.</p>
<p>Jobs are no longer defined in an XML file. This has been moved to the JobSandbox
  entity. There is a web based client in planning for adding predefined jobs to
  the queue, but currently the entities will have to be created by hand.</p>
<hr>
<h3><a name="ServiceDefinition">Service Definition</a></h3>
<hr>
<p>Services are defined in <i>Service Definition Files.</i> There are global definition
  files used for all service dispatchers as well as individual files associated
  only with a single dispatcher. When a LocalDispatcher is created it is passed
  a Collection of Arils which point to these definition files. These files are
  composed using XML and defined the necessary information needed to invoke a
  service. The <a href="/dtds/services.dtd">DTD</a> of this file can be found
  <a href="/dtds/services.dtd">here</a>.</p>
<p>Services are defined with a unique name, associated to a specific service engine
  and the input and output parameters are defined explicitly. Below is an example
  of a service definition:</p>
<pre>
&lt;service name=&quot;userLogin&quot; engine=&quot;java&quot;
  location=&quot;org.ofbiz.commonapp.security.login.LoginServices&quot; invoke=&quot;userLogin&quot;&gt;
    &lt;description&gt;Authenticate a username/password; create a UserLogin object&lt;/description&gt;
    &lt;attribute name=&quot;login.username&quot; type=&quot;String&quot; mode=&quot;IN&quot;/&gt;
    &lt;attribute name=&quot;login.password&quot; type=&quot;String&quot; mode=&quot;IN&quot;/&gt;
    &lt;attribute name=&quot;userLogin&quot; type=&quot;org.ofbiz.core.entity.GenericValue&quot; mode=&quot;OUT&quot; optional=&quot;true&quot;/&gt;
&lt;/service&gt;
</pre>
<p><b>SERVICE ELEMENT:</b></p>
<ul>
  <li><b>name</b> - The unique name of the service </li>
  <li><b>engine</b> - The name of the engine (defined in servicesengine.xml)</li>
  <li><b>location </b>- The location or package of the service's class</li>
  <li><b>invoke</b> - The method name of the service</li>
  <li><b>auth</b> - Does this service require authorization (true/<u>false</u>)</li>
  <li><b>export</b> - Is this service allowed to be accessed via SOAP/HTTP/JMS (true/<u>false</u>)</li>
  <li><b>validate</b> - Do we validate the attributes found below for name and
    type matching (<u>true</u>/false)</li>
</ul>
<p><b>IMPLEMENTS ELEMENT:</b></p>
<ul>
  <li><b>sevice</b> - The name of the service which this service implements. All attributes are inherited</li>
</ul>
<p><b>ATTRIBUTE ELEMENT:</b></p>
<ul>
  <li><b>name</b> - The name of this attribute</li>
  <li><b>type</b> - The object type (String, java.util.Date, etc.)</li>
  <li><b>mode</b> - Is this an input or output parameter or both (IN/OUT/INOUT)</li>
  <li><b>optional</b> - Is this parameter optional (true/<u>false</u>)
    <p><font size="-1">*underlined values are defaults</font></p>
  </li>
</ul>
<p>Above you can see the name of this service is <i>userLogin</i> and it uses
  the <i>java</i> engine. This service expects two <b>required</b> IN parameters:
  <i>login.username</i> and <i>login.password</i>. Required parameters are tested
  before the service is invoked. If the parameters does not match by name and
  object type the service is not invoked. Parameters which may or may not be sent
  to the service should be defined as <b>optional</b>. After the service is invoked,
  the OUT parameters are tested. Only required parameters are tested, however
  if a parameter is passed which is not defined as optional or required it will
  cause the service to fail. This service has not required OUT parameters so,
  the result is simply returned.</p>
<hr>
<h3><a name="Usage">Usage</a></h3>
<hr>
<p>Internal Usage of the Services Framework is quite simple. In a Web Application
  the LocalDispatcher is stored in the ServletContext which can be accessed via
  the Session object in an Event. For non-web based applications you simply create
  a delegator object (see the Entity Engine docs) define a Collection of URLs
  where service definitions can be found and then create a new instance of the
  LocalDispatcher: </p>
<pre>
GenericDelegator delegator = GenericDelegator.getGenericDelegator("default");
Collection definitionFiles = null; // We will use only the global here
LocalDispatcher dispatcher = new LocalDispatcher(&quot;UniqueName&quot;,delegator,definitionFiles);
</pre>
<p><b>Now we have a dispatcher which we can use to invoke services. To invoke the
  test service create a Map for the context which contains the IN parameter <i>message</i>
  then invoke the service:</b></p>
<pre>
Map context = UtilMisc.toMap(&quot;message&quot;,&quot;This is a test.&quot;);
Map result = null;
try {
  result = dispatcher.runSync(&quot;testScv&quot;,context);
}
catch (GenericServiceException e) {
  e.printStackTrace();
}
if (result != null)
  System.out.println("Result from service: " + (String) result.get("resp"));
</pre>
<p>Now look at the console and see what the test service has echoed.</p>

<p>*** The test service is located in core/docs/examples/ServiceTest.java you must compile this and place it in the classpath.</p>
<p><b>To schedule a service to run at a later time or to repeat use the:</b></p>
<pre>
// This example will schedule a job to run now.
Map context = UtilMisc.toMap(&quot;message&quot;,&quot;This is a test.&quot;);
try {
  long startTime = (new Date()).getTime();
  dispatcher.schedule(&quot;testScv&quot;, context, startTime);
}
catch (GenericServiceException e) {
  e.printStackTrace();
}

// This example will schedule a service to run now and repeat once every 5 seconds a total of 10 times.
Map context = UtilMisc.toMap(&quot;message&quot;,&quot;This is a test.&quot;);
try {
  long startTime = (new Date()).getTime();
  int frequency = RecurrenceRule.SECONDLY;
  int interval = 5;
  int count = 10;
  dispatcher.schedule(&quot;testScv&quot;, context, startTime, frequency, interval, count);
}
catch (GenericServiceException e) {
  e.printStackTrace();
}
</pre>

<hr>
<h3><a name="Advanced">Advanced</a></h3>
<hr>
<p>There have been a number of 'Advanced' features added to the service engine. You will find examples,
definitions and information on each below.</p>
  
<hr>
<h3><a name="Interfaces">Interfaces</a></h3>
<hr>
<p>The <code>interface</code> service engine has been implemented to help with defining services which share
a number of the same parameters. An <code>interface</code> service cannot be invoked, but rather is a 
defined service which other services inherit from. Each <code>interface</code> service will be defined
using the <code>interface</code> engine for example:</p>  
<pre>
&lt;service name=&quot;testInterface&quot; engine=&quot;interface&quot; location=&quot;&quot; invoke=&quot;&quot;&gt;
    &lt;description&gt;A test interface service&lt;/description&gt;
    &lt;attribute name=&quot;partyId&quot; type=&quot;String&quot; mode=&quot;IN&quot;/&gt;
    &lt;attribute name=&quot;partyTypeId&quot; type=&quot;String&quot; mode=&quot;IN&quot;/&gt;
    &lt;attribute name=&quot;userLoginId&quot; type=&quot;org.ofbiz.core.entity.GenericValue&quot; mode=&quot;OUT&quot; optional=&quot;true&quot;/&gt;
&lt;/service&gt;
</pre>
<p> **Note that the <code>location</code> and the <code>invoke</code> fields are required in the DTD, so we
simply leave these as empty strings when used as an <code>interface</code>.</p>

<p>Now, that we have an <code>interface</code> we need to defined a service which <code>implements</code> 
this <code>interface</code></p>

<pre>
&lt;service name=&quot;testExample1&quot; engine=&quot;simple&quot; 
		location=&quot;org/ofbiz/commonapp/common/SomeTestFile.xml&quot; invoke=&quot;testExample1&quot;&gt;
    &lt;description&gt;A test service which implements testInterface&lt;/description&gt;
    &lt;implements service=&quot;testInterface&quot;/&gt;   
&lt;/service&gt;
</pre>

<p>The <code>testExample1</code> service will have the exact same required and optional attributes as the
<code>testInterface</code> service. Any service which implements <code>testInterface</code> will also inherit
the parameters/attributes. If needed additional attributes can be added to a specific service by including
the <code>attribute</code> tag along with the <code>implements</code> tag. You may also override an attribute
by re-defining it after the <code>implements</code> tag.</p>
  
<hr>
<h3><a name="ECAs">ECAs</a></h3>
<hr>
<p>ECA (Event Condition Action) is much like a trigger. When a service is called a lookup is preformed to see
if any ECAs are defined for this <code>event</code>. Events include before authentication, before IN parameter 
validation, before actual service invocation, before OUT parameter validation, before transaction commit, or 
before the service returns. Next each <code>condition</code> in the ECA definition is evaluated and if all 
come back as true, each <code>action</code> is preformed. An <code>action</code> is just a service which must 
be defined to work with the parameters already in the service's context. There are no limit to the number
of conditions or actions each ECA may define.</p>

<pre>
&lt;service-eca&gt;
    &lt;eca service=&quot;testScv&quot; event=&quot;commit&quot;&gt;
        &lt;condition field-name=&quot;message&quot; operator=&quot;equals&quot; value=&quot;12345&quot;/&gt;
        &lt;action service=&quot;testBsh&quot; mode=&quot;sync&quot;/&gt;
    &lt;/eca&gt;
&lt;/service-eca&gt;
</pre>

<p><code><b><u>eca</u></b></code> tag:</p>
<table cellpadding='2' cellspacing='0' border='1'>
<tr>
    <td><b>Attribute&nbsp;Name</b></td>
    <td><b>Required?</b></td>
    <td><b>Description</b></td>
</tr>
<tr>
    <td>service</td><td>Y</td>
    <td>The name of the service this ECA is attached to.</td>
</tr>
<tr>
    <td>event</td><td>Y</td>
    <td>The event on which this ECA will run can be (before):
    <code>auth, in-validate, out-validate, invoke, commit, or return</code>.</td>
</tr>
<tr>
    <td>run-on-error</td><td>N</td>
    <td>Should this ECA run if there is an error in the service (default <u>false</u>)</td>
</tr>
</table>

<p>The <code>eca</code> element should also have 0 or more <code>condition</code> or <code>condition-field</code>
elements and 1 or more <code>action</code> elements.</p>

<p><code><b><u>condition</u></b></code> tag</p>
<table cellpadding='2' cellspacing='0' border='1'>
<tr>
    <td><b>Attribute&nbsp;Name</b></td>
    <td><b>Required?</b></td>
    <td><b>Description</b></td>
</tr>
<tr>
    <td>map-name</td><td>N</td>
    <td>The name of the service context field that contains the map that the 
    field to be validated will come from. If not specified the field-name will
    be treated as a service context field name (an env-name).</td>
</tr>
<tr>
    <td>field-name</td><td>Y</td>
    <td>The name of the map field that will be compared.</td>
</tr>
<tr>
    <td>operator</td><td>Y</td>
    <td>Specified the comparison operator must be one of the following:
    less, greater, less-equals, greater-equals, equals, not-equals, or contains.</td>
</tr>
<tr>
    <td>value</td><td>Y</td>
    <td>The value that the field will compared to. Must be a String, but can be
    converted to other types.</td>
</tr>
<tr>
    <td>type</td><td>N</td>
    <td>The data type to use for the comparison. Must be one of the following:
    String, Double, Float, Long, Integer, Date, Time, or Timestamp. If no type
    is specified the default will be String.</td>
</tr>
<tr>
    <td>format</td><td>N</td>
    <td>A format specifier to use when converting String objects to other data
    types, mainly Date, Time and Timestamp.</td>
</tr>
</table>

<p><code><b><u>condition-field</u></b></code> tag</p>
<table cellpadding='2' cellspacing='0' border='1'>
<tr>
    <td><b>Attribute&nbsp;Name</b></td>
    <td><b>Required?</b></td>
    <td><b>Description</b></td>
</tr>
<tr>
    <td>map-name</td><td>N</td>
    <td>The name of the service context field that contains the map that the 
    field to be validated will come from. If not specified the field-name will
    be treated as a method environment field name (an env-name).</td>
</tr>
<tr>
    <td>field-name</td><td>Y</td>
    <td>The name of the map field that will be compared.</td>
</tr>
<tr>
    <td>operator</td><td>Y</td>
    <td>Specified the comparison operator must be one of the following:
    less, greater, less-equals, greater-equals, equals, not-equals, or contains.</td>
</tr>
<tr>
    <td>to-map-name</td><td>N</td>
    <td>The name of the service context field that contains the map that the 
    field to be compared will come from. If left empty will default to the map-name, 
    or the method environment if map-name is also unspecified.</td>
</tr>
<tr>
    <td>to-field-name</td><td>N</td>
    <td>The name of the to-map field that the main field will be compared to.
    If left empty will default to the field-name.</td>
</tr>
<tr>
    <td>type</td><td>N</td>
    <td>The data type to use for the comparison. Must be one of the following:
    String, Double, Float, Long, Integer, Date, Time, or Timestamp. If no type
    is specified the default will be String.</td>
</tr>
<tr>
    <td>format</td><td>N</td>
    <td>A format specifier to use when converting String objects to other data
    types, mainly Date, Time and Timestamp.</td>
</tr>
</table>

<p><code><b><u>action</u></b></code> tag</p>
<table cellpadding='2' cellspacing='0' border='1'>
<tr>
    <td><b>Attribute&nbsp;Name</b></td>
    <td><b>Required?</b></td>
    <td><b>Description</b></td>
</tr>
<tr>
    <td>service</td><td>N</td>
    <td>The name of the service this <code>action</code> will invoke.</td>
</tr>
<tr>
    <td>mode</td><td>Y</td>
    <td>The mode in which this service should be invoked. Can be sync or async. Note
    that async actions will not update the context even when set to true.</td>
</tr>
<tr>
    <td>result-to-context</td><td>N</td>
    <td>Should the results of the <code>action service</code> update the main service's context.
    Default <code><u>true</u></code>.</td>
</tr>
<tr>
    <td>ignore-error</td><td>N</td>
    <td>Ignore any errors caused by the action service. If <code> the error will cause the 
    origional service to fail. Default <code><u>true</u></code>.</td>
</tr>
</table>
  
<hr>
<h3><a name="Groups">Service Groups</a></h3>
<hr>
<p>Service groups are a set of services which should run when calling the initial service. You define
a service using the <code>group</code> service engine, and include all the parameters/attributes needed
for all the services in the group. The <code>location</code> attribute is not needed for <code>group</code>
services, the <code>invoke</code> attribute defines the name of the <code>group</code> to run. 
When this service is invoked the group is called and the services defined in the group are called as defined. </p>  

<p>The group definition is very simple, it contains a group elements along with 1 or more service elements.
The group element contains a <code>name</code> attribute and a <code>mode</code> attribute used to define how
the group will function. The service element is much like the <code>action</code> element in an ECA,
the difference being the default value for result-to-context.</p>

<pre>
&lt;service-group&gt;
    &lt;group name=&quot;testGroup&quot; send-mode=&quot;all&quot;&gt;
        &lt;service name=&quot;testScv&quot; mode=&quot;sync&quot;/&gt;
        &lt;service name=&quot;testBsh&quot; mode=&quot;sync&quot;/&gt;
    &lt;/group&gt;
&lt;/service-group&gt;
</pre>
  
<p><code><b><u>group</u></b></code> tag</p>
<table cellpadding='2' cellspacing='0' border='1'>
<tr>
    <td><b>Attribute&nbsp;Name</b></td>
    <td><b>Required?</b></td>
    <td><b>Description</b></td>
</tr>
<tr>
    <td>name</td><td>Y</td>
    <td>The name of the service this <code>action</code> will invoke.</td>
</tr>
<tr>
    <td>send-mode</td><td>N</td>
    <td>The mode in which the service(s) should be invoked. The options are:
    none, all, first-available, random, or round-robin. The default is <code><u>all</u></code>.</td>
</tr>
</table>

<p><code><b><u>service</u></b></code> tag</p>
<table cellpadding='2' cellspacing='0' border='1'>
<tr>
    <td><b>Attribute&nbsp;Name</b></td>
    <td><b>Required?</b></td>
    <td><b>Description</b></td>
</tr>
<tr>
    <td>service</td><td>N</td>
    <td>The name of the service this <code>action</code> will invoke.</td>
</tr>
<tr>
    <td>mode</td><td>Y</td>
    <td>The mode in which this service should be invoked. Can be sync or async. Note
    that async actions will not update the context even when set to true.</td>
</tr>
<tr>
    <td>result-to-context</td><td>N</td>
    <td>Should the results of the <code>action service</code> update the main service's context.
    Default <code><u>false</u></code>.</td>
</tr>
</table>
  
<hr>
<h3><a name="Route">Route Services</a></h3>
<hr>
<p>Route services are defined using the <code>route</code> service engine. When a <code>route</code> 
service is called, there is no invoke preformed, but all ECAs defined will run during the proper events.
This type of serivce is not used very often, but can be used to 'route' to other services by utilizing the 
ECA options available to services.</p>

<hr>
<h3><a name="HTTP">HTTP Services</a></h3>
<hr>
<p>Using HTTP services is a way of invoking remote services defined on other systems. The local definition 
should match that of the remote definition, but the <code>engine</code> used should be <code>http</code>, 
the <code>location</code> should be a fully qualified URL to the httpService event running on the remote
system, and the <code>invoke</code> should be the name of the service on the remote system you are requesting 
to be run. The remote system must have the httpService event mounted for HTTP services to be accepted. 
By default the commonapp web application has this event mounted to recieve requests for services. 
Services on the remote system must have <code>export</code> set to <code>true</code> in order to allow the 
service to be run remotely. HTTP services by nature are synchronous.</p>
  
<hr>
<h3><a name="JMS">JMS Services</a></h3>
<hr>
<p>JMS services are much like HTTP services, except the service request is sent to a JMS topic/queue. 
The <code>engine</code> should be set to <code>jms</code>, the <code>location</code> should be the 
name of the jms-service defined in the serviceengine.xml file (see <a href="serviceconfig.html#JMS">Service
Config</a> document), and the <code>invoke</code> should be the name of the service on the remote system
you are requesting to run. JMS services by nature are asynchronous.</p>
    
<hr>
<p><br>
</p>
<h3>&nbsp;</h3>
</body>
</html>
