/*
 *  Copyright (c) 2003 The Open For Business Project - www.ofbiz.org
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a 
 *  copy of this software and associated documentation files (the "Software"), 
 *  to deal in the Software without restriction, including without limitation 
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 *  and/or sell copies of the Software, and to permit persons to whom the 
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included 
 *  in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
 *  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
 *  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
 *  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT 
 *  OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 
 *  THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *@author     Andy Zeneski
 *@version    $Revision: 1.6 $
 *@since      2.1
*/

import org.ofbiz.base.util.*;
import org.ofbiz.entity.*;
import org.ofbiz.service.*;
import org.ofbiz.product.product.ProductContentWrapper;
import org.ofbiz.product.catalog.*;
import org.ofbiz.product.store.*;

String buildNext(Map map, List order, String current, String prefix, Map featureTypes) {
    keySet = map.keySet();
    ct = 0;
    i = keySet.iterator();
    buf = new StringBuffer();
    buf.append("function list" + current + prefix + "() { ");
    buf.append("document.forms[\"addform\"].elements[\"" + current + "\"].options.length = 1;");
    buf.append("document.forms[\"addform\"].elements[\"" + current + "\"].options[0] = new Option(\"" + featureTypes.get(current) + "\",\"\",true,true);");
    while (i.hasNext()) {
        key = i.next();
        value = map.get(key);        
        optValue = null;
        if (order.indexOf(current) == (order.size()-1)) {
            optValue = value.iterator().next();
        } else {
            optValue = prefix + "_" + ct;
        }
        buf.append("document.forms[\"addform\"].elements[\"" + current + "\"].options[" + (ct + 1) + "] = new Option(\"" + key + "\",\"" + optValue + "\");");
        ct++;
    }
    buf.append(" }");
    if (order.indexOf(current) < (order.size()-1)) {
        i2 = keySet.iterator();
        ct = 0;
        while (i2.hasNext()) {
            nextOrder = order.get(order.indexOf(current)+1);
            key = i2.next();
            value = map.get(key);
            newPrefix = prefix + "_" + ct;
            buf.append(buildNext(value, order, nextOrder, newPrefix, featureTypes));
        }
    }
    return buf.toString();
}    

dispatcher = request.getAttribute("dispatcher");
delegator = request.getAttribute("delegator");
userLogin = session.getAttribute("userLogin");
requestParams = UtilHttp.getParameterMap(request);

// get the shopping lists for the user (if logged in)
if (userLogin != null) {
    shoppingLists = delegator.findByAnd("ShoppingList", UtilMisc.toMap("partyId", userLogin.getString("partyId")), UtilMisc.toList("listName"));
    context.put("shoppingLists", shoppingLists);        
}

// set the content path prefix
contentPathPrefix = CatalogWorker.getContentPathPrefix(request); 
request.setAttribute("contentPathPrefix", contentPathPrefix);

// get the product detail information
product = request.getAttribute("product");
if (product != null) {
    productId = product.getString("productId");        
    request.setAttribute("product_id", productId);        
    productTypeId = product.getString("productTypeId");  
    featureTypes = new HashMap();
    featureOrder = new LinkedList();

    // make the productContentWrapper
    ProductContentWrapper productContentWrapper = new ProductContentWrapper(product, request);
    request.setAttribute("productContentWrapper", productContentWrapper);

    // get next/previous information for category
    categoryId = requestParams.get("category_id");
    if (categoryId == null) categoryId = product.getString("primaryProductCategoryId");
    if (categoryId != null) request.setAttribute("categoryId", categoryId);

    Map catNextPreviousResult = null;
    if (categoryId != null) {
        catNextPreviousResult = dispatcher.runSync("getPreviousNextProducts", UtilMisc.toMap("categoryId", categoryId, "productId", productId));
        if (catNextPreviousResult != null) {
            request.setAttribute("category", catNextPreviousResult.get("category"));
            request.setAttribute("previousProductId", catNextPreviousResult.get("previousProductId"));
            request.setAttribute("nextProductId", catNextPreviousResult.get("nextProductId"));
        }
    }

    // get the product price
    catalogId = CatalogWorker.getCurrentCatalogId(request);
    webSiteId = CatalogWorker.getWebSiteId(request);
    currentCatalogId = CatalogWorker.getCurrentCatalogId(request);
    autoUserLogin = request.getSession().getAttribute("autoUserLogin");
    fieldMap = UtilMisc.toMap("product", product, "prodCatalogId", catalogId, "webSiteId", webSiteId
        , "currencyUomId", UtilHttp.getCurrencyUom(session), "autoUserLogin", autoUserLogin);
    priceMap = dispatcher.runSync("calculateProductPrice", fieldMap);
    request.setAttribute("priceMap", priceMap);
    
    productStore = ProductStoreWorker.getProductStore(request);
    productStoreId = productStore.getString("productStoreId");

    // get the product review(s)
    reviews = product.getRelated("ProductReview", null, UtilMisc.toList("-postedDateTime"));
    request.setAttribute("productReviews", reviews);
    
    // Special Variant Code 
    if ("Y".equals(product.getString("isVirtual"))) {
        featureMap = dispatcher.runSync("getProductFeatureSet", UtilMisc.toMap("productId", productId));
        featureSet = featureMap.get("featureSet");
        if (featureSet != null && featureSet.size() > 0) {
            variantTreeMap = dispatcher.runSync("getProductVariantTree", UtilMisc.toMap("productId", productId, "featureOrder", featureSet, "productStoreId", productStoreId));
            variantTree = variantTreeMap.get("variantTree");
            imageMap = variantTreeMap.get("variantSample");                        
            request.setAttribute("variantTree", variantTree);
            request.setAttribute("varientTreeSize", new Integer(variantTree.size()));
            request.setAttribute("variantSample", imageMap);
            request.setAttribute("variantSampleKeys", imageMap.keySet());
            request.setAttribute("variantSampleSize", new Integer(imageMap.size()));
            request.setAttribute("featureSet", featureSet);
            if (variantTree != null && variantTree.size() > 0) {         
                featureOrder = new LinkedList(featureSet);                         
                foi = featureOrder.iterator();
                while (foi.hasNext()) {
                    featureKey = foi.next();
                    featureValue = delegator.findByPrimaryKeyCache("ProductFeatureType", UtilMisc.toMap("productFeatureTypeId", featureKey));
                    fValue = featureValue.get("description") != null ? featureValue.getString("description") : featureValue.getString("productFeatureTypeId");
                    featureTypes.put(featureKey, fValue);
                }
            } 
            request.setAttribute("featureTypes", featureTypes);
            request.setAttribute("featureOrder", featureOrder);
            request.setAttribute("featureOrderFirst", featureOrder.get(0));
         
            jsBuf = new StringBuffer();            
            jsBuf.append("<script language=\"JavaScript\">");
            jsBuf.append("var IMG = new Array(" + variantTree.size() + ");"); 
            jsBuf.append("var OPT = new Array(" + featureOrder.size() + ");");            
            for (li = 0; li < featureOrder.size(); li++) {
                jsBuf.append("OPT[" + li + "] = \"" + featureOrder.get(li) + "\";");                  
            }
            
            // build the top level             
            topLevelName = featureOrder.get(0);
            jsBuf.append("function list" + topLevelName + "() {");
            jsBuf.append("document.forms[\"addform\"].elements[\"" + topLevelName + "\"].options.length = 1;");
            jsBuf.append("document.forms[\"addform\"].elements[\"" + topLevelName + "\"].options[0] = new Option(\"" + featureTypes.get(topLevelName) + "\",\"\",true,true);");                               
            if (variantTree != null) {
                vTreeKeySet = variantTree.keySet();
                vti = vTreeKeySet.iterator();
                counter = 0;
                while (vti.hasNext()) {
                    key = vti.next();
                    value = variantTree.get(key);
                    opt = null;
                    if (featureOrder.size() == 1)
                        opt = value.iterator().next();
                    else
                        opt = "" + counter;                 
                    jsBuf.append("document.forms[\"addform\"].elements[\"" + topLevelName + "\"].options[" + (counter+1) + "] = new Option(\"" + key + "\",\"" + opt + "\");");
                    jsBuf.append("IMG[" + counter + "] = \"" + imageMap.get(key).getString("largeImageUrl") +"\";");                
                    counter++;
                }
            }                    
            jsBuf.append("}");                        
   
            // build dynamic lists             
            if (variantTree != null) {
                topLevelKeys = variantTree.keySet();
                tli = topLevelKeys.iterator();
                topLevelKeysCt = 0;
                while (tli.hasNext()) {
                    cnt = "" + topLevelKeysCt; 
                    varTree = variantTree.get(tli.next());
                    if (varTree instanceof Map) {
                        jsBuf.append(buildNext(varTree, featureOrder, featureOrder.get(1), cnt, featureTypes));             
                    }
                    topLevelKeysCt++;
                }
            }
            jsBuf.append("function findIndex(name) { for (i=0; i<OPT.length; i++) { if (OPT[i] == name) return i; } return -1; }");    
            jsBuf.append("function getList(name, value, src) { var value2 = 'NULL'; currentOrderIndex = findIndex(name);");                    
            jsBuf.append("if (src == 1 && OPT.length == 1) { value2 = document.forms[\"addform\"].elements[name].options[(value*1)+1].value;");                        
            jsBuf.append("} if (currentOrderIndex < 0 || value == \"\") return; if (currentOrderIndex < (OPT.length - 1) || OPT.length == 1) {");                        
            jsBuf.append("if (IMG[value] != null) { if (document.images['mainImage'] != null) document.images['mainImage'].src = IMG[value];");
            jsBuf.append("document.addform." + topLevelName + ".selectedIndex = (value*1)+1;");
            jsBuf.append("} if (OPT.length != 1) { eval(\"list\" + OPT[currentOrderIndex+1] + value + \"()\");");                        
            jsBuf.append("document.addform.add_product_id.value = 'NULL'; } else { if (value2 == 'NULL')");
            jsBuf.append("value2 = value; document.addform.add_product_id.value = value2;");
            jsBuf.append("} } else { document.addform.add_product_id.value = value; } }");
            jsBuf.append("</script>");  
            
            request.setAttribute("virtualJavaScript", jsBuf.toString());          
        }
    } 

    // get product associations
    obsoleteProducts = dispatcher.runSync("getAssociatedProducts", UtilMisc.toMap("productId", productId, "type", "PRODUCT_OBSOLESCENCE", "checkViewAllow", Boolean.TRUE, "prodCatalogId", currentCatalogId));
    request.setAttribute("obsoleteProducts", obsoleteProducts.get("assocProducts"));
    crossSellProducts = dispatcher.runSync("getAssociatedProducts", UtilMisc.toMap("productId", productId, "type", "PRODUCT_COMPLEMENT", "checkViewAllow", Boolean.TRUE, "prodCatalogId", currentCatalogId));
    request.setAttribute("crossSellProducts", crossSellProducts.get("assocProducts")); 
    upSellProducts = dispatcher.runSync("getAssociatedProducts", UtilMisc.toMap("productId", productId, "type", "PRODUCT_UPGRADE", "checkViewAllow", Boolean.TRUE, "prodCatalogId", currentCatalogId));
    request.setAttribute("upSellProducts", upSellProducts.get("assocProducts"));
    obsolenscenseProducts = dispatcher.runSync("getAssociatedProducts", UtilMisc.toMap("productIdTo", productId, "type", "PRODUCT_OBSOLESCENCE", "checkViewAllow", Boolean.TRUE, "prodCatalogId", currentCatalogId));
    request.setAttribute("obsolenscenseProducts", obsolenscenseProducts.get("assocProducts"));                 
}
