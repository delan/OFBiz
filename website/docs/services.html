<html>
<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<title>The Open For Business Project: Service Engine Guide</title>
</head>
<body>
<table width="100%">
<tbody>
<tr>
<td align="left" valign="center" width="50%"> <a
href="http://www.ofbiz.org"><img
src="http://www.ofbiz.org/images/ofbiz_logo.jpg"
alt="The Open For Business Project" border="0"></a> </td>
<td align="right" valign="center" width="50%"> <a
href="http://sf.net/projects/ofbiz"><img
src="http://sourceforge.net/sflogo.php?group_id=27173"
alt="SourceForge Logo" border="0" height="31" width="88"></a> <a
href="http://www.ofbiz.org"><img
src="http://www.ofbiz.org/images/ofbiz_powered.gif" border="0"
width="88"></a> </td>
</tr>
</tbody>
</table>
<hr class="sepbar">
<h2 align="center">The Open For Business Project: Service Engine Guide</h2>
<div class="contenttext">Written by: Andy Zeneski, <a
href="mailto:jaz@ofbiz.org">jaz@ofbiz.org</a></div>
<div class="contenttext">Edited by: Les Austin<br>
Last Updated: August 06, 2004<br>
</div>
<!-- $Id: services.html,v 1.3 2004/08/06 23:57:19 jonesde Exp $ -->
<hr class="sepbar"><br>
<h3>Table of Contents</h3>
<ul>
<li><a href="#Related_Documents">Related Documents</a></li>
<li><a href="#Introduction">Introduction</a> </li>
<li><a href="#ServiceDispatcher">Service Dispatcher</a> </li>
<li><a href="#DispatchContext">Dispatch Context</a> </li>
<li><a href="#ServiceEngine">Service Engine</a> </li>
<li><a href="#JobScheduler">Job Scheduler</a> </li>
<li><a href="#ServiceDefinition">Service Definition</a></li>
<li><a href="#Usage">Usage</a></li>
<li><a href="#Advanced">Advanced:</a></li>
<ul>
<li><a href="#Interfaces">Interfaces</a></li>
<li><a href="#ECAs">ECAs</a></li>
<li><a href="#Groups">Service Groups</a></li>
<li><a href="#Route">Route Services</a></li>
<li><a href="#HTTP">HTTP Services</a></li>
<li><a href="#JMS">JMS Services</a></li>
</ul>
</ul>
<hr class="sepbar">
<h3><a name="Related_Documents">Related Documents:</a></h3>
<hr class="sepbar">
<ul>
<li><a href="api/index.html">Core JavaDoc (including Service Engine)</a></li>
<li><a href="serviceconfig.html">Service Engine Configuration Guild</a></li>
<li><a href="/dtds/services.dtd">Services Definition DTD</a></li>
</ul>
<hr class="sepbar">
<h3><a name="Introduction">Introduction</a>
</h3>
<hr class="sepbar">
<p class="contenttext">The Services Framework is new to OFBiz in
Version 2. Services are defined as independent pieces of logic which
when placed together can be used to process many different types of
business requirements. Services can be of many different types:
Workflow, Rules, Java, SOAP, BeanShell, etc. A service with the type
Java is much like an event where it is a static method, however with
the Services Framework we do not limit to web based applications.
Services require input parameters to be in a Map and the results are
returned in a Map as well. This is nice since a Map can be serialized
and stored or passed via HTTP (SOAP). <br>
</p>
<p class="contenttext">Services are defined through the <a
href="#ServiceDefinition">Service Definition</a> and are assigned to a
specific <a href="#ServiceEngine">Service Engine</a>. Each <a
href="#ServiceEngine">Service Engine</a> is responsible for invoking
the defined service in an appropriate way. Since services are not tied
to web based applications this allows services to run when there is no
response object available. This allows services to be scheduled to run
at specific times to run in the background via the <a
href="#JobScheduler">Job Scheduler</a>.</p>
<p class="contenttext">Services have the ability to call other
services. So, chaining small services together to accomplish a larger
task makes reusing existing services much easier. Services which are
used in different applications can be defined only once by creating
Global Service Definition files or services specific to an application
can be restricted and available only to that application. </p>
<p class="contenttext">When used in a web application services are
available to web events, which allow events to stay small and reuse
existing logic in the Services Framework. Also, services can be defined
as 'exportable' which means they are allowed to be accessed by outside
parties. Currently there is a SOAP EventHandler which allows services
to be made available via SOAP. Other forms of remote invocation may be
added to the framework in the future. </p>
<hr class="sepbar">
<h3><a name="ServiceDispatcher">Service Dispatcher</a> </h3>
<hr class="sepbar">
<p class="contenttext">The Service Dispatcher handles dispatching
services to the appropriate <a href="#ServiceEngine">Service Engine</a>
where it is then invoked. There is exactly one ServiceDispatcher for
each Entity Delegator. If there are multiple delegators in an
application there will also be multiple dispatchers. The
ServiceDispatcher is accessed via a LocalDispatcher. There can be many
LocalDispatchers associated with a ServiceDispatcher. Each
LocalDispatcher is uniquely named and contains its own list of service
definitions. When creating an instance of a LocalDispatcher, a <a
href="#DispatchContext">DispatchContext </a>is also created and
passed to the ServiceEngine.</p>
<p class="contenttext">A LocalDispatcher is associated with an
application. Applications never talk directly to the ServiceDispatcher.
The LocalDispatcher contains an API for invoking services, which are
routed through the ServiceDispather. However, applications may be
running in different threads than the actual ServiceDispatcher, so it
is left to the LocalDispatcher to keep a <a href="#DispatchContext">DispatchContext</a>
which among other things keeps a reference to the applications
classloader.</p>
<hr class="sepbar">
<h3><a name="DispatchContext">Dispatch Context</a>
</h3>
<hr class="sepbar">
<p class="contenttext">The DispatchContext is created by the
LocalDispatcher upon instantiation. This is the runtime dispatcher
context. It contains necessary information to process services for each
dispatcher. This context contains the reference to each of the service
definition files, the classloader which should be used for invocation,
a reference to the delegator and its dispatcher along with a 'bag' of
user defined attributes. This context is passed on to each service when
invoked and is used by the dispatcher to determine the service's model.<br>
</p>
<hr class="sepbar">
<h3><a name="ServiceEngine">ServiceEngine</a>
</h3>
<hr class="sepbar">
<p class="contenttext">This is where the service is actually invoked.
Each service has an engine name assigned in its definition. This engine
name is mapped via the servicesengine.xml file and is instantiated by
the GenericEngineFactory when called upon. Third-party engines are
supported and must follow the GenericEngine interface when implemented.
See the Service Engine Configuration Guide for details on defining
engines.</p>
<p class="contenttext">It is the job of the engine to handle invocation
of both synchronous and asynchronous services. Engines which use the <a
href="#JobScheduler">Job Scheduler</a> for asynchronous services can
extend the GenericAsyncEngine.<br>
<br>
</p>
<hr class="sepbar">
<h3><a name="JobScheduler">Job Scheduler</a>
</h3>
<hr class="sepbar">
<p class="contenttext">The overhauled job scheduler is now integrated
with the services framework. This is the most appropriate place for a
scheduler. Since it cannot be guarantee that an HttpServletRequest and
HttpServletResponse object will be available when a job is ready to
run, it does not make sense to integrate with the web controller. Plus,
this feature is most useful when not limited to web environments.
</p>
<p class="contenttext">The scheduler is a multithreaded component with
a single thread used for job managing/scheduling and separate threads
used for invocation of each service. When a job is scheduled to run,
the scheduler will call the service dispatcher associated with the job
to invoke the service in its own thread. This will prevent long or time
consuming jobs from slowing down other jobs in the queue.</p>
<p class="contenttext">The scheduler now supports the iCalendar rule
structure for recurrence. The jobs are no longer stored in an XML file
and each is part of a ServiceDispatcher. There is one Job Scheduler for
each ServiceDispatcher (which means there is only one per
GenericDelegator as well).</p>
<p class="contenttext"><b>How it works:</b></p>
<p class="contenttext">The best usage example of the scheduler is an
asynchronous service call. When an asynchronous service is invoked, it
is passed to the Job Scheduler to be queued to run. A recurrence entry
is created (RecurrenceInfo and RecurrenceRule entities are created),
the job is stored, (JobSandbox entity is created) and the context (Map)
is serialized and stored (RuntimeData entity is created). The scheduler
then adds the job to the top of the list of scheduled jobs
(asynchronous services do not have any delay time) and invoked.</p>
<p class="contenttext">Jobs are no longer defined in an XML file. This
has been moved to the JobSandbox entity. There is a web based client in
planning for adding predefined jobs to the queue, but currently the
entities will have to be created by hand.</p>
<hr class="sepbar">
<h3><a name="ServiceDefinition">Service Definition</a></h3>
<hr class="sepbar">
<p class="contenttext">Services are defined in <i>Service Definition
Files.</i> There are global definition files used for all service
dispatchers as well as individual files associated only with a single
dispatcher. When a LocalDispatcher is created it is passed a Collection
of Arils which point to these definition files. These files are
composed using XML and define the necessary information needed to
invoke a service. The <a href="/dtds/services.dtd">DTD</a> of this
file can be found <a href="/dtds/services.dtd">here</a>.</p>
<p class="contenttext">Services are defined with a unique name,
associated to a specific service engine and the input and output
parameters are defined explicitly. Below is an example of a service
definition:</p>
<pre>&lt;service name="userLogin" engine="java"<br> location="org.ofbiz.commonapp.security.login.LoginServices" invoke="userLogin"&gt;<br> &lt;description&gt;Authenticate a username/password; create a UserLogin object&lt;/description&gt;<br> &lt;attribute name="login.username" type="String" mode="IN"/&gt;<br> &lt;attribute name="login.password" type="String" mode="IN"/&gt;<br> &lt;attribute name="userLogin" type="org.ofbiz.entity.GenericValue" mode="OUT" optional="true"/&gt;<br>&lt;/service&gt;<br></pre>
<p class="contenttext"><b>SERVICE ELEMENT:</b></p>
<ul>
<li><b>name</b> - The unique name of the service </li>
<li><b>engine</b> - The name of the engine (defined in
servicesengine.xml)</li>
<li><b>location </b>- The location or package of the service's class</li>
<li><b>invoke</b> - The method name of the service</li>
<li><b>auth</b> - Does this service require authorization (true/<u>false</u>)</li>
<li><b>export</b> - Is this service allowed to be accessed via
SOAP/HTTP/JMS (true/<u>false</u>)</li>
<li><b>validate</b> - Do we validate the attributes found below for
name and type matching (<u>true</u>/false)</li>
</ul>
<p class="contenttext"><b>IMPLEMENTS ELEMENT:</b></p>
<ul>
<li><b>service</b> - The name of the service which this service
implements. All attributes are inherited</li>
</ul>
<p class="contenttext"><b>ATTRIBUTE ELEMENT:</b></p>
<ul>
<li><b>name</b> - The name of this attribute</li>
<li><b>type</b> - The object type (String, java.util.Date, etc.)</li>
<li><b>mode</b> - Is this an input or output parameter or both
(IN/OUT/INOUT)</li>
<li><b>optional</b> - Is this parameter optional (true/<u>false</u>)
<p class="contenttext"><font size="-1">*underlined values are
defaults</font></p>
</li>
</ul>
<p class="contenttext">Above you can see the name of this service is <i>userLogin</i>
and it uses the <i>java</i> engine. This service expects two <b>required</b>
IN parameters: <i>login.username</i> and <i>login.password</i>.
Required parameters are tested before the service is invoked. If the
parameters does not match by name and object type the service is not
invoked. Parameters which may or may not be sent to the service should
be defined as <b>optional</b>. After the service is invoked, the OUT
parameters are tested. Only required parameters are tested, however if
a parameter is passed which is not defined as optional or required it
will cause the service to fail. This service has not required OUT
parameters, so the result is simply returned.</p>
<hr class="sepbar">
<h3><a name="Usage">Usage</a></h3>
<hr class="sepbar">
<p class="contenttext">Internal Usage of the Services Framework is
quite simple. In a Web Application the LocalDispatcher is stored in the
ServletContext which can be accessed via the Session object in an
Event. For non-web based applications you simply create a
GenericDispatcher: </p>
<pre>GenericDelegator delegator = GenericDelegator.getGenericDelegator("default");<br>LocalDispatcher dispatcher = new GenericDispatcher("UniqueName",delegator);<br></pre>
<p class="contenttext"><b>Now we have a dispatcher which we can use to
invoke services. To invoke the test service create a Map for the
context which contains the IN parameter <i>message</i> then invoke the
service:</b></p>
<pre>Map context = UtilMisc.toMap("message","This is a test.");<br>Map result = null;<br>try {<br> result = dispatcher.runSync("testScv",context);<br>}<br>catch (GenericServiceException e) {<br> e.printStackTrace();<br>}<br>if (result != null)<br> System.out.println("Result from service: " + (String) result.get("resp"));<br></pre>
<p class="contenttext">Now look at the console and see what the test
service has echoed.</p>
<p class="contenttext">*** The test service is located in
core/docs/examples/ServiceTest.java You must compile this and place it
in the classpath.</p>
<p class="contenttext"><b>To schedule a service to run at a later time
or to repeat use this:</b></p>
<pre>// This example will schedule a job to run now.<br>Map context = UtilMisc.toMap("message","This is a test.");<br>try {<br> long startTime = (new Date()).getTime();<br> dispatcher.schedule("testScv", context, startTime);<br>}<br>catch (GenericServiceException e) {<br> e.printStackTrace();<br>}<br><br>// This example will schedule a service to run now and repeat once every 5 seconds a total of 10 times.<br>Map context = UtilMisc.toMap("message","This is a test.");<br>try {<br> long startTime = (new Date()).getTime();<br> int frequency = RecurrenceRule.SECONDLY;<br> int interval = 5;<br> int count = 10;<br> dispatcher.schedule("testScv", context, startTime, frequency, interval, count);<br>}<br>catch (GenericServiceException e) {<br> e.printStackTrace();<br>}<br></pre>
<hr class="sepbar">
<h3><a name="Advanced">Advanced</a></h3>
<hr class="sepbar">
<p class="contenttext">There have been a number of 'Advanced' features
added to the service engine. You will find examples,
definitions and information on each below.</p>
<hr class="sepbar">
<h3><a name="Interfaces">Interfaces</a></h3>
<hr class="sepbar">
<p class="contenttext">The <code>interface</code> service engine has
been implemented to help with defining services which share
a number of the same parameters. An <code>interface</code> service
cannot be invoked, but rather is a defined service which other services
inherit from. Each <code>interface</code> service will be defined
using the <code>interface</code> engine, for example:</p>
<pre>&lt;service name="testInterface" engine="interface" location="" invoke=""&gt;<br> &lt;description&gt;A test interface service&lt;/description&gt;<br> &lt;attribute name="partyId" type="String" mode="IN"/&gt;<br> &lt;attribute name="partyTypeId" type="String" mode="IN"/&gt;<br> &lt;attribute name="userLoginId" type="org.ofbiz.entity.GenericValue" mode="OUT" optional="true"/&gt;<br>&lt;/service&gt;<br></pre>
<p class="contenttext"> **Note that the <code>location</code> and the <code>invoke</code>
fields are required in the DTD, so we
simply leave these as empty strings when used as an <code>interface</code>.</p>
<p class="contenttext">Now that we have an <code>interface</code> we
need to define a service which <code>implements</code> this <code>interface</code></p>
<pre>&lt;service name="testExample1" engine="simple" <br> location="org/ofbiz/commonapp/common/SomeTestFile.xml" invoke="testExample1"&gt;<br> &lt;description&gt;A test service which implements testInterface&lt;/description&gt;<br> &lt;implements service="testInterface"/&gt; <br>&lt;/service&gt;<br></pre>
<p class="contenttext">The <code>testExample1</code> service will have
the exact same required and optional attributes as the
<code>testInterface</code> service. Any service which implements <code>testInterface</code>
will also inherit
the parameters/attributes. If needed, additional attributes can be
added to a specific service by including
the <code>attribute</code> tag along with the <code>implements</code>
tag. You may also override an attribute
by re-defining it after the <code>implements</code> tag.</p>
<hr class="sepbar">
<h3><a name="ECAs">ECAs</a></h3>
<hr class="sepbar">
<p class="contenttext">ECA (Event Condition Action) is much like a
trigger. When a service is called, a lookup is performed to see
if any ECAs are defined for this <code>event</code>. Events include
before authentication, before IN parameter validation, before actual
service invocation, before OUT parameter validation, before transaction
commit, or before the service returns. Next each <code>condition</code>
in the ECA definition is evaluated and if all come back as true, each <code>action</code>
is performed. An <code>action</code> is just a service which must be
defined to work with the parameters already in the service's context.
There are no limit to the number
of conditions or actions each ECA may define.</p>
<pre>&lt;service-eca&gt;<br> &lt;eca service="testScv" event="commit"&gt;<br> &lt;condition field-name="message" operator="equals" value="12345"/&gt;<br> &lt;action service="testBsh" mode="sync"/&gt;<br> &lt;/eca&gt;<br>&lt;/service-eca&gt;<br></pre>
<p class="contenttext"><code><b><u>eca</u></b></code> tag:</p>
<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td><b>Attribute&nbsp;Name</b></td>
<td><b>Required?</b></td>
<td><b>Description</b></td>
</tr>
<tr>
<td>service</td>
<td>Y</td>
<td>The name of the service this ECA is attached to.</td>
</tr>
<tr>
<td>event</td>
<td>Y</td>
<td>The event on which this ECA will run can be (before): <code>auth,
in-validate, out-validate, invoke, commit, or return</code>.</td>
</tr>
<tr>
<td>run-on-error</td>
<td>N</td>
<td>Should this ECA run if there is an error in the service
(default <u>false</u>)</td>
</tr>
</tbody>
</table>
<p class="contenttext">The <code>eca</code> element should also have 0
or more <code>condition</code> or <code>condition-field</code>
elements and 1 or more <code>action</code> elements.</p>
<p class="contenttext"><code><b><u>condition</u></b></code> tag</p>
<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td><b>Attribute&nbsp;Name</b></td>
<td><b>Required?</b></td>
<td><b>Description</b></td>
</tr>
<tr>
<td>map-name</td>
<td>N</td>
<td>The name of the service context field that contains the map
that the field to be validated will come from. If not specified the
field-name will be treated as a service context field name (an
env-name).</td>
</tr>
<tr>
<td>field-name</td>
<td>Y</td>
<td>The name of the map field that will be compared.</td>
</tr>
<tr>
<td>operator</td>
<td>Y</td>
<td>Specified the comparison operator must be one of the
following: less, greater, less-equals, greater-equals, equals,
not-equals, or contains.</td>
</tr>
<tr>
<td>value</td>
<td>Y</td>
<td>The value that the field will compared to. Must be a String,
but can be converted to other types.</td>
</tr>
<tr>
<td>type</td>
<td>N</td>
<td>The data type to use for the comparison. Must be one of the
following: String, Double, Float, Long, Integer, Date, Time, or
Timestamp. If no type is specified the default will be String.</td>
</tr>
<tr>
<td>format</td>
<td>N</td>
<td>A format specifier to use when converting String objects to
other data types, mainly Date, Time and Timestamp.</td>
</tr>
</tbody>
</table>
<p class="contenttext"><code><b><u>condition-field</u></b></code> tag</p>
<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td><b>Attribute&nbsp;Name</b></td>
<td><b>Required?</b></td>
<td><b>Description</b></td>
</tr>
<tr>
<td>map-name</td>
<td>N</td>
<td>The name of the service context field that contains the map
that the field to be validated will come from. If not specified the
field-name will be treated as a method environment field name (an
env-name).</td>
</tr>
<tr>
<td>field-name</td>
<td>Y</td>
<td>The name of the map field that will be compared.</td>
</tr>
<tr>
<td>operator</td>
<td>Y</td>
<td>Specified the comparison operator must be one of the
following: less, greater, less-equals, greater-equals, equals,
not-equals, or contains.</td>
</tr>
<tr>
<td>to-map-name</td>
<td>N</td>
<td>The name of the service context field that contains the map
that the field to be compared will come from. If left empty will
default to the map-name, or the method environment if map-name is also
unspecified.</td>
</tr>
<tr>
<td>to-field-name</td>
<td>N</td>
<td>The name of the to-map field that the main field will be
compared to. If left empty will default to the field-name.</td>
</tr>
<tr>
<td>type</td>
<td>N</td>
<td>The data type to use for the comparison. Must be one of the
following: String, Double, Float, Long, Integer, Date, Time, or
Timestamp. If no type is specified the default will be String.</td>
</tr>
<tr>
<td>format</td>
<td>N</td>
<td>A format specifier to use when converting String objects to
other data types, mainly Date, Time and Timestamp.</td>
</tr>
</tbody>
</table>
<p class="contenttext"><code><b><u>action</u></b></code> tag</p>
<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td><b>Attribute&nbsp;Name</b></td>
<td><b>Required?</b></td>
<td><b>Description</b></td>
</tr>
<tr>
<td>service</td>
<td>N</td>
<td>The name of the service this <code>action</code> will invoke.</td>
</tr>
<tr>
<td>mode</td>
<td>Y</td>
<td>The mode in which this service should be invoked. Can be sync
or async. Note that async actions will not update the context even when
set to true.</td>
</tr>
<tr>
<td>result-to-context</td>
<td>N</td>
<td>Should the results of the <code>action service</code> update
the main service's context. Default <code><u>true</u></code>.</td>
</tr>
<tr>
<td>ignore-error</td>
<td>N</td>
<td>Ignore any errors caused by the action service. If <code>true</code>
the error will cause the original service to fail. Default <code><u>true</u></code>.</code></td>
</tr>
<tr>
<td>persist</td>
<td>N</td>
<td>The action service store / run. Can be true or false. Only
effective when mode is async. Default <code><u>false</u></code>.</td>
</tr>
</tbody>
</table>
<hr class="sepbar">
<h3><a name="Groups">Service Groups</a></h3>
<hr class="sepbar">
<p class="contenttext">Service groups are a set of services which
should run when calling the initial service. You define
a service using the <code>group</code> service engine, and include all
the parameters/attributes needed
for all the services in the group. The <code>location</code> attribute
is not needed for <code>group</code>
services, the <code>invoke</code> attribute defines the name of the <code>group</code>
to run. When this service is invoked the group is called and the
services defined in the group are called as defined. </p>
<p class="contenttext">The group definition is very simple, it contains
a group elements along with 1 or more service elements.
The group element contains a <code>name</code> attribute and a <code>mode</code>
attribute used to define how
the group will function. The service element is much like the <code>action</code>
element in an ECA,
the difference being the default value for result-to-context.</p>
<pre>&lt;service-group&gt;<br> &lt;group name="testGroup" send-mode="all"&gt;<br> &lt;service name="testScv" mode="sync"/&gt;<br> &lt;service name="testBsh" mode="sync"/&gt;<br> &lt;/group&gt;<br>&lt;/service-group&gt;<br></pre>
<p class="contenttext"><code><b><u>group</u></b></code> tag</p>
<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td><b>Attribute&nbsp;Name</b></td>
<td><b>Required?</b></td>
<td><b>Description</b></td>
</tr>
<tr>
<td>name</td>
<td>Y</td>
<td>The name of the service this <code>action</code> will invoke.</td>
</tr>
<tr>
<td>send-mode</td>
<td>N</td>
<td>The mode in which the service(s) should be invoked. The
options are: none, all, first-available, random, or round-robin. The
default is <code><u>all</u></code>.</td>
</tr>
</tbody>
</table>
<p class="contenttext"><code><b><u>service</u></b></code> tag</p>
<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td><b>Attribute&nbsp;Name</b></td>
<td><b>Required?</b></td>
<td><b>Description</b></td>
</tr>
<tr>
<td>service</td>
<td>N</td>
<td>The name of the service this <code>action</code> will invoke.</td>
</tr>
<tr>
<td>mode</td>
<td>Y</td>
<td>The mode in which this service should be invoked. Can be sync
or async. Note that async actions will not update the context even when
set to true.</td>
</tr>
<tr>
<td>result-to-context</td>
<td>N</td>
<td>Should the results of the <code>action service</code> update
the main service's context. Default <code><u>false</u></code>.</td>
</tr>
</tbody>
</table>
<hr class="sepbar">
<h3><a name="Route">Route Services</a></h3>
<hr class="sepbar">
<p class="contenttext">Route services are defined using the <code>route</code>
service engine. When a <code>route</code> service is called, there is
no invoke performed, but all ECAs defined will run during the proper
events.
This type of service is not used very often, but can be used to 'route'
to other services by utilizing the ECA options available to services.</p>
<hr class="sepbar">
<h3><a name="HTTP">HTTP Services</a></h3>
<hr class="sepbar">
<p class="contenttext">Using HTTP services is a way of invoking remote
services defined on other systems. The local definition should match
that of the remote definition, but the <code>engine</code> used should
be <code>http</code>, the <code>location</code> should be a fully
qualified URL to the httpService event running on the remote
system, and the <code>invoke</code> should be the name of the service
on the remote system you are requesting to be run. The remote system
must have the httpService event mounted for HTTP services to be
accepted. By default the commonapp web application has this event
mounted to receive requests for services. Services on the remote system
must have <code>export</code> set to <code>true</code> in order to
allow the service to be run remotely. HTTP services by nature are
synchronous.</p>
<hr class="sepbar">
<h3><a name="JMS">JMS Services</a></h3>
<hr class="sepbar">
<p class="contenttext">JMS services are much like HTTP services, except
the service request is sent to a JMS topic/queue. The <code>engine</code>
should be set to <code>jms</code>, the <code>location</code> should
be the name of the jms-service defined in the serviceengine.xml file
(see <a href="serviceconfig.html#JMS">Service
Config</a> document), and the <code>invoke</code> should be the name
of the service on the remote system
you are requesting to run. JMS services by nature are asynchronous.</p>
<hr class="sepbar">
<p class="contenttext"><br>
</p>
<h3>&nbsp;</h3>
</body>
</html>

