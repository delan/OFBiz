<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>The Open For Business Project: Scalability Plan</title>
  <link rel="stylesheet" href="images/maincss.css" type="text/css">
</head>

<body>

<table width='100%'>
  <tr>
    <td width='50%' align='left' valign='center'>
        <a href="http://www.ofbiz.org"><img src="images/ofbiz_logo.jpg"  border="0" alt='The Open For Business Project'></a>
    </td>
    <td width='50%' align='right' valign='center'>
        <a href="http://sf.net/projects/ofbiz"><img src="http://sourceforge.net/sflogo.php?group_id=27173" width="88" height="31" border="0" alt="SourceForge Logo"></a> 
        <a href="http://www.ofbiz.org"><img src="images/ofbiz_powered.gif" width="88" border="0"></a>
    </td>
  </tr>
</table>
<hr class='sepbar'>

<h2 align="center">The Open For Business Project: Scalability Plan</h2>
 
<div class='contenttext'>Written By: David E. Jones, <a href="mailto:jonesde@ofbiz.org">jonesde@ofbiz.org</a></div>
<div class='contenttext'>Last Updated: May 17, 2001</div>

<br>
<h3>Web Load Handling Tiers</h3>
<p>Web, or HTTP, based traffic can be load balanced and accelerated at many
different points between the user and the database.&nbsp; This is a list of the
main touch points, some of which are optional.</p>
<ol>
  <li>HTML Client
    <ol>
      <li>Pages and images are often cached on the client; for dynamic pages
        this may be good to turn off so that the user always gets the freshest
        version from the server</li>
      <li>Simple fail-over can be done on this level manually by giving the user
        multiple URLs for the application</li>
    </ol>
  </li>
  <li>Edge Router (optional)
    <ol>
      <li>An edge router allows for wide are distributed server farms where a
        user is automatically forwarded to the nearest (fastest) farm</li>
    </ol>
  </li>
  <li>IP Accelerator (optional)
    <ol>
      <li>Sits in front of an HTTP or other server and handles IP connections
        for the server, maintaining a single connection to the server</li>
      <li>Some IP accelerators can be clustered for load balancing on this level
        and for high availability</li>
      <li>Some can load balance over multiple HTTP servers</li>
      <li>Some vendors that do this include: <a href="http://www.alacritech.com">www.alacritech.com</a>,
        <a href="http://www.netscaler.com">www.netscaler.com</a>, <a href="http://www.packeteer.com">www.packeteer.com</a>,
        <a href="http://www.redlinenetworks.com">www.redlinenetworks.com</a>&nbsp;</li>
    </ol>
  </li>
  <li>HTTP Server - Apache (optional)
    <ol>
      <li>Can be skipped by setting up Tomcat to listen on the desired port</li>
      <li>Has plugins to support connection to Tomcat: AJP12 (ad-hoc
        connection), AJP13 (maintained connection), JNI (fast direct calls), LB
        (load balancing) (see the <a href="http://jakarta.apache.org/tomcat/jakarta-tomcat/src/doc/mod_jk-howto.html">mod_jk</a>
        and <a href="http://jakarta.apache.org/tomcat/jakarta-tomcat/src/doc/Tomcat-Workers-HowTo.html">workers</a>
        howtos for more information)</li>
      <li>Plugin can support load balancing among multiple Tomcat servers, many
        Tomcat instances to one Apache instance and one site</li>
      <li>Plugin can also support multiple virtual hosted sites targeting
        different Tomcat servers, many Tomcat instances to one Apache instance
        and many sites</li>
    </ol>
  </li>
  <li>Servlet Engine - Tomcat
    <ol>
      <li>Many Tomcat instances to one JBoss instance is easy because EJBs are
        made to be destributed and can be called from anywhere</li>
      <li>Can hit database directly with JDBC, or go through JBoss EJB container</li>
      <li>Data from the database can be cached at this level for highest speed
        but least shared read access</li>
    </ol>
  </li>
  <li>EJB Container - JBoss (optional)
    <ol>
      <li>Can be skipped using JDBC from a servlet</li>
      <li>JBoss and Tomcat can run one-to-one on the same machine</li>
      <li>Many JBoss instances to one Tomcat instances is difficult now until
        JBoss finishes their clustering support</li>
      <li>An EJB could be custom created to support fail-over to another
        database with Bean Managed Persistense, or with Container Managed
        Persistence multiple entity bean pools could be created and pointed at
        different databases and writes could go to all databases and reads could
        come from any, maybe with a round-robin or load querying scheme
        (whatever it is, it would have to be coded manually)</li>
      <li>Data from the database can be, and by default in most EJB containers
        usually is, cached at this level for faster speed than database hits,
        but slower and more shared or shareable than servlet level caching</li>
    </ol>
  </li>
  <li>RDBMS
    <ol>
      <li>Some databases support clustering, data synchronization and failover,
        but these are not common features and are very proprietary</li>
      <li>Different database tables can be stored on different machines; for
        example the catalog on one database server and the user information on
        another and logging information on another</li>
    </ol>
  </li>
</ol>
<h3>Performance Trade-Offs</h3>
<h5><B>Scalability 
vs. Performance</B></h5>
<P>Components 
should be designed with scalability, or the support of many users, in 
mind.  Where options are available to implement a procedure or data 
structure to support high performance or scalability, scalability should 
be chosen even if performance if negatively affected.&nbsp; However, if no real
scalability issues get in the way, performance should be optimized as much as is
needed for the application.</P>
<h5><B>Maintainability 
vs. Performance</B></h5>
<P>Sometimes 
design choices for procedure and data structures emphasize maintainability 
or performance, but do not support both well and present a trade-off 
situation.  In these cases maintainability, or customizability, should 
be the most important factor.  In cases where a certain design causes 
an unreasonable decrease in performance, or where timing constraints 
are not being met, optimization may be done after the fact to tune the 
application, minimizing as much as possible the decrease in maintainability 
and customizability.</P>


    

    
  

</body></html>

