<?xml version="1.0" encoding="UTF-8" ?>
<!--
 *  Copyright (c) 2003-2005 The Open For Business Project - www.ofbiz.org
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included
 *  in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 *  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 *  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 *  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
 *  OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
 *  THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * @author     Andy Zeneski (jaz@ofbiz.org)
 * @version    $Rev$
 * @since      2.2
-->

<simple-methods xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
        xsi:noNamespaceSchemaLocation="http://www.ofbiz.org/dtds/simple-methods.xsd">
    <simple-method method-name="createReturnHeader" short-description="Create a ReturnHeader">
        <now-timestamp-to-env env-name="nowTimestamp"/>

        <if>
            <condition>
                <and>
                    <not><if-has-permission permission="ORDERMGR" action="_CREATE"/></not>
                    <not><if-compare-field field-name="partyId" map-name="userLogin" operator="equals" to-field-name="fromPartyId" to-map-name="parameters"/></not>
                </and>
            </condition>
            <then>
                <add-error><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunCreateReturnHeader"/></add-error>
            </then>
        </if>

        <if-empty field-name="parameters.toPartyId">
            <!-- no toPartyId was specified.  use destination facility to determine the party of the return -->
            <if-not-empty field-name="parameters.destinationFacilityId">
                <entity-one entity-name="Facility" value-name="destinationFacility" auto-field-map="false">
                    <field-map field-name="facilityId" env-name="parameters.destinationFacilityId"/>
                </entity-one>
                <set from-field="destinationFacility.ownerPartyId" field="parameters.toPartyId"/>
            </if-not-empty>
        <else>
            <!-- make sure that the party to return to is an INTERNAL_ORGANIZATIO or stop 
            TODO: if we want to implement returns to vendor later, simply change this to make sure that EITHER fromPartyId or toPartyId
            is an internal organization, and possibly also do a security check on the user -->
            <entity-one entity-name="PartyRole" value-name="partyRole" use-cache="true" auto-field-map="false">
                <field-map field-name="partyId" env-name="parameters.toPartyId"/>
                <field-map field-name="roleTypeId" value="INTERNAL_ORGANIZATIO"/>
            </entity-one>
            <if-empty field-name="partyRole">
                <add-error><fail-message message="Error: a return must be to a party in the role of internal organization"/></add-error>
            </if-empty>
         </else>
        </if-empty>
        <check-errors/>

        <!-- check the needs (auto) inventory receive flag (default to no) -->
        <if-empty field-name="parameters.needsInventoryReceive">
            <set field="parameters.needsInventoryReceive" value="N"/>
        </if-empty>

        <make-value value-name="newEntity" entity-name="ReturnHeader"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>

        <!-- If PartyAcctgPreference.useInvoiceIdForReturns is Y, get the ID from the getNextInvoiceId service -->
        <entity-one entity-name="PartyAcctgPreference" value-name="partyAcctgPreference" auto-field-map="false">
            <field-map field-name="partyId" env-name="parameters.toPartyId"/>
        </entity-one>
        <if-compare field-name="partyAcctgPreference.useInvoiceIdForReturns" operator="equals" value="Y">
            <set field="getNextInvoiceIdMap.partyId" from-field="parameters.toPartyId"/>
            <call-service service-name="getNextInvoiceId" in-map-name="getNextInvoiceIdMap">
                <result-to-field result-name="invoiceId" field-name="newEntity.returnId"/>
            </call-service>        
            
            <else>
                <sequenced-id-to-env sequence-name="ReturnHeader" env-name="newEntity.returnId"/>
            </else>            
        </if-compare>
        <field-to-result field-name="newEntity.returnId" result-name="returnId"/>
        
        <if>
            <condition>
                <not><if-has-permission permission="ORDERMGR" action="_CREATE"/></not>
            </condition>
            <then>
                <set field="newEntity.statusId" value="RETURN_REQUESTED"/>
                <set from-field="nowTimestamp" field="newEntity.entryDate"/>
            </then>
        </if>

        <if-empty field-name="newEntity.entryDate">
            <set from-field="nowTimestamp" field="newEntity.entryDate"/>
        </if-empty>

        <if-empty field-name="newEntity.statusId">
            <set value="RETURN_REQUESTED" field="newEntity.statusId"/>
        </if-empty>
        <set field="newEntity.createdBy" from-field="userLogin.userLoginId"/>

        <create-value value-name="newEntity"/>
        <set field="responseMessage" value="Return Request #${newEntity.returnId} was created successfully."/>
        <field-to-result field-name="responseMessage" result-name="successMessage"/>
    </simple-method>
    <simple-method method-name="updateReturnHeader" short-description="Update a ReturnHeader">
        <check-permission permission="ORDERMGR" action="_UPDATE"><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunUpdateReturnHeader"/></check-permission>
        <check-errors/>

        <set from-field="parameters.returnId" field="lookupPKMap.returnId"/>
        <find-by-primary-key entity-name="ReturnHeader" map-name="lookupPKMap" value-name="returnHeader"/>

        <!-- test the total return amount vs the total order amount -->
        <if-compare field-name="parameters.statusId" value="RETURN_ACCEPTED" operator="equals">
            <!-- get orderId from each ReturnItem: return may be assosicated with many different orders -->
            <entity-condition entity-name="ReturnItem" list-name="returnItems" distinct="true">
                <condition-expr field-name="returnId" operator="equals" env-name="returnHeader.returnId"/>
                <select-field field-name="orderId"/>
            </entity-condition>
            <!-- check them all to make sure that the return total does not exceed order total.  -->
            <iterate entry-name="returnItem" list-name="returnItems">
                <if-not-empty field-name="returnItem.orderId">
                    <set field="returnTotalCtx.orderId" from-field="returnItem.orderId"/>
                    <!-- no adjustment needed: adjustment is passed in to calculate the effect of an additional item on return total.  -->
                    <calculate field-name="returnTotalCtx.adjustment"><number value="0.0"/></calculate>
                    <call-service service-name="getOrderAvailableReturnedTotal" in-map-name="returnTotalCtx">
                        <result-to-field result-name="availableReturnTotal" field-name="availableReturnTotal"/>
                        <result-to-field result-name="returnTotal" field-name="returnTotal"/>
                        <result-to-field result-name="orderTotal" field-name="orderTotal"/>
                    </call-service>
                    <log level="info" message="Available amount for return (order #${returnItem.orderId}) : ${availableReturnTotal} [orderTotal = ${orderTotal} / returnTotal = ${returnTotal}]"/>
                    <if-compare field-name="availableReturnTotal" operator="less" value="0" type="Double">
                        <add-error><fail-property resource="OrderErrorUiLabels" property="OrderReturnPriceCannotExceedTheOrderTotal"/></add-error>
                    </if-compare>
                    <else>
                        <log level="info" message="Not an order based returnItem; unable to check valid amounts!"/>
                    </else>
                </if-not-empty>    
            </iterate>
            <check-errors/>
        </if-compare>

        <field-to-result field-name="returnHeader.statusId" result-name="currentStatusId"/>
        <set-nonpk-fields map-name="parameters" value-name="returnHeader"/>
        <store-value value-name="returnHeader"/>
    </simple-method>

    <simple-method method-name="createReturnItem" short-description="Create Return Item">
        <set field="lookupPKMap.returnId" from-field="parameters.returnId"/>
        <find-by-primary-key entity-name="ReturnHeader" map-name="lookupPKMap" value-name="returnHeader"/>

        <if>
          <condition>
            <and>
              <not><if-has-permission permission="ORDERMGR" action="_CREATE"/></not>
              <not><if-compare-field field-name="partyId" map-name="userLogin" operator="equals" to-field-name="fromPartyId" to-map-name="returnHeader"/></not>
            </and>
          </condition>
          <then>
            <add-error><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunCreateReturnItem"/></add-error>
          </then>
        </if>
        <check-errors/>

        <if-empty field-name="returnItemTypeId"  map-name="parameters">
            <if-not-empty field-name="returnItemMapKey" map-name="parameters">
                <!-- find the item mapping -->
            </if-not-empty>
        </if-empty>

        <if-empty field-name="returnItemTypeId" map-name="parameters">
            <add-error><fail-message message="Return Item Type is not defined for this item; or no mapping was found."/></add-error>
            <check-errors/>
        </if-empty>

        <if-compare field-name="returnQuantity" map-name="parameters" operator="equals" value="0" type="Double">
            <add-error><fail-property resource="OrderErrorUiLabels" property="OrderNoReturnQuantityAvailablePreviousReturnsMayExist"/></add-error>
            <check-errors/>
        </if-compare>

        <!-- setup some default values for protection -->
        <set field="returnableQuantity" value="0" type="Double"/>
        <set field="returnablePrice" value="0" type="Double"/>

        <!-- if an orderItemSeqId or orderAdjustmentId is provided, then find the corresponding orderItem or orderAdjustment -->
        <if-not-empty field-name="parameters.orderItemSeqId">
            <make-value value-name="itemLookup" entity-name="OrderItem"/>
            <set-pk-fields map-name="parameters" value-name="itemLookup"/>
            <if-not-empty field-name="parameters.orderItemSeqId">
                <find-by-primary-key entity-name="OrderItem" value-name="orderItem" map-name="itemLookup"/>
                <log level="info" message="Return item is an OrderItem - ${orderItem.orderItemSeqId}"/>
            </if-not-empty>
        </if-not-empty>

        <if-not-empty field-name="parameters.orderAdjustmentId">
            <make-value value-name="adjLookup" entity-name="OrderAdjustment"/>
            <set-pk-fields value-name="adjLookup" map-name="parameters"/>
            <if-not-empty field-name="parameters.orderAdjustmentId">
                <find-by-primary-key map-name="adjLookup" value-name="orderAdjustment" entity-name="OrderAdjustment"/>
                <log level="info" message="Return item is an OrderAdjustment - ${orderAdjustment.orderAdjustmentId}"/>
            </if-not-empty>
        </if-not-empty>

        <!-- get the returnableQuantity and returnablePrice: for orderItems, it's found by getReturnableQuantity; for adjustments, 
             either order adjustments or manual adjustments, it's always 1 and based on input parameter --> 
        <if-not-empty field-name="orderItem">
            <set field="serviceContext.orderItem" from-field="orderItem"/>
            <call-service service-name="getReturnableQuantity" in-map-name="serviceContext">
                <result-to-field result-name="returnableQuantity" field-name="returnableQuantity"/>
                <result-to-field result-name="returnablePrice" field-name="returnablePrice"/>
            </call-service>
        </if-not-empty>

        <if-not-empty field-name="orderAdjustment">
            <set field="returnableQuantity" value="1" type="Double"/>
            <set field="returnablePrice" from-field="parameters.returnPrice" type="Double"/>
            <log level="info" message="set return price to the input amount : ${returnablePrice}"/>
        </if-not-empty>

        <if-compare field-name="returnItemTypeId" value="RETURN_MAN_ADJ" operator="equals">
            <set field="returnableQuantity" value="1" type="Double"/>
            <set field="returnablePrice" from-field="orderAdjustment.amount" type="Double"/>
            <log level="info" message="set return price to adjustment amount : ${returnablePrice}"/>
        </if-compare>

        <if-compare field-name="returnableQuantity" value="0" operator="greater" type="Double">
            <!-- the user is only allowed to set a returnPrice if he has ORDERMGR_CREATE privilege, otherwise only the returnablePrice
                 calculated by service is used -->
            <if>
                <condition>
                      <not><if-has-permission permission="ORDERMGR" action="_CREATE"/></not>
                </condition>
                <then>
                      <set from-field="returnablePrice" field="parameters.returnPrice"/>
                </then>
            </if>

            <!-- make sure the returnQuantity is not greater than the returnableQuantity from service or the quantity on the original orderItem -->
            <if-compare-field field-name="returnQuantity" map-name="parameters" operator="greater" to-field-name="returnableQuantity" type="Double">
                <add-error><fail-property resource="OrderErrorUiLabels" property="OrderRequestedReturnQuantityNotAvailablePreviousReturnsMayExist"/></add-error>
            </if-compare-field>

            <!-- SC 20060202: Is this really needed?  Or does the above duplicate it.  If not, we should remove it -->
            <if-not-empty field-name="orderItem">
                <if-compare-field field-name="returnQuantity" map-name="parameters" operator="greater" to-field-name="quantity" to-map-name="orderItem" type="Double">
                    <add-error><fail-property resource="OrderErrorUiLabels" property="OrderReturnQuantityCannotExceedTheOrderedQuantity"/></add-error>
                </if-compare-field>
            </if-not-empty>

            <!-- Workaround for bug: returnPrice=16.99, returnablePrice=16.9894 => OrderReturnPriceCannotExceedThePurchasePrice -->
            <set field="epsilon" value="0.01" type="Double"/>
            <set field="zero" value="0.0" type="Double"/>
            <calculate field-name="returnPriceDelta" type="Double">
                <calcop operator="subtract">
                    <calcop operator="get" field-name="returnPrice" map-name="parameters"/>
                    <calcop operator="get" field-name="returnablePrice"/>
                </calcop>
            </calculate>
            <if-compare-field field-name="returnPriceDelta" operator="less" to-field-name="zero" type="Double">
                <calculate field-name="returnPriceDelta" type="Double"><calcop field-name="returnPriceDelta" operator="negative"/></calculate>
            </if-compare-field>

            <if-compare-field field-name="returnPriceDelta" operator="greater-equals" to-field-name="epsilon" type="Double">
                <add-error><fail-property resource="OrderErrorUiLabels" property="OrderReturnPriceCannotExceedThePurchasePrice"/></add-error>
            </if-compare-field>
            <check-errors/>

            <else>
                <!-- if returnable quantity is zero, then this operation is only allowed for adjustment and shipping -->
                <if>
                    <condition>
                    	<and>
                           <if-compare field-name="returnItemTypeId" map-name="parameters" operator="not-equals" type="String" value="RETURN_MAN_ADJ"/>                    	
                           <if-compare field-name="returnItemTypeId" map-name="parameters" operator="not-equals" type="String" value="RITM_SHIPPING_CHRG"/>                    	                           
                        </and>
                    </condition>
                    <then>
                        <log level="error" message="Illegal returnItemType for ${parameters}"/>
                        <add-error><fail-property resource="OrderErrorUiLabels" property="OrderIllegalReturnItemTypePassed"/></add-error>
                    <check-errors/>
                        
                    </then>
                </if>
            </else>
        </if-compare>

        <make-value value-name="newEntity" entity-name="ReturnItem"/>
        <!-- do a lookup to find the existing returnItems on this return, order by returnItemSeqId DESC, then get the first one
             and add 1 to returnItemSeqId to get the new returnItemSeqId -->
        <set from-field="parameters.returnId" field="newEntity.returnId"/>
        <set from-field="parameters.returnId" field="lookupMap.returnId"/>
        <string-to-list string="-returnItemSeqId" list-name="orderBy"/>
        <find-by-and entity-name="ReturnItem" list-name="currentItems" map-name="lookupMap" order-by-list-name="orderBy"></find-by-and>
        <if-empty field-name="currentItems">
            <set value="1" field="newEntity.returnItemSeqId"/>
        <else>
           <first-from-list entry-name="newestItem" list-name="currentItems"/>
           <calculate field-name="returnItemSeqId" map-name="newEntity" type="Integer">
               <calcop field-name="returnItemSeqId" map-name="newestItem" operator="add">
                   <number value="1"/>
               </calcop>
           </calculate>
        </else>
        </if-empty>
        <to-string field-name="returnItemSeqId" map-name="newEntity" numeric-padding="5"/>

        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>
        <set field="newEntity.statusId" value="RETURN_REQUESTED"/>  <!-- default status for new return items -->
        <field-to-result field-name="returnItemSeqId" map-name="newEntity" result-name="returnItemSeqId"/>
        <log level="info" message="Return Item Seq ID: ${newEntity.returnItemSeqId}"/>
        <create-value value-name="newEntity"/>
    </simple-method>
    <simple-method method-name="updateReturnItem" short-description="Update Return Item">
        <check-permission permission="ORDERMGR" action="_UPDATE"><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunUpdateReturnHeader"/></check-permission>
        <check-errors/>

        <set from-field="parameters.returnId" field="lookupPKMap.returnId"/>
        <set from-field="parameters.returnItemSeqId" field="lookupPKMap.returnItemSeqId"/>
        <find-by-primary-key entity-name="ReturnItem" map-name="lookupPKMap" value-name="returnItem"/>

        <field-to-result field-name="returnItem.statusId" result-name="currentStatusId"/>
        <set-nonpk-fields map-name="parameters" value-name="returnItem"/>
        <store-value value-name="returnItem"/>
    </simple-method>
    <simple-method method-name="updateReturnItemsStatus" short-description="Update Return Items Status">
        <check-permission permission="ORDERMGR" action="_UPDATE"><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunUpdateReturnHeader"/></check-permission>
        <check-errors/>

        <set from-field="parameters.returnId" field="lookupPKMap.returnId"/>
        <find-by-and entity-name="ReturnItem" map-name="lookupPKMap" list-name="returnItems"/>
        <iterate entry-name="item" list-name="returnItems">
            <set field="item.statusId" from-field="parameters.statusId"/>
        </iterate>
        <store-list list-name="returnItems"/>
    </simple-method>
    <simple-method method-name="removeReturnItem" short-description="Remove Return Item">
        <check-permission permission="ORDERMGR" action="_DELETE"><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunRemoveQuoteItem"/></check-permission>
        <check-errors/>

        <set from-field="parameters.returnId" field="headerPKMap.returnId"/>
        <find-by-primary-key entity-name="ReturnHeader" map-name="headerPKMap" value-name="returnHeader"/>
        <if-compare field-name="statusId" map-name="returnHeader" operator="not-equals" type="String" value="RETURN_REQUESTED">
            <add-error><fail-property resource="OrderErrorUiLabels" property="OrderCannotRemoveItemsOnceReturnIsApproved"/></add-error>
            <check-errors/>
        </if-compare>

        <set from-field="parameters.returnId" field="lookupPKMap.returnId"/>
        <set from-field="parameters.returnItemSeqId" field="lookupPKMap.returnItemSeqId"/>
        <find-by-primary-key entity-name="ReturnItem" map-name="lookupPKMap" value-name="returnItem"/>

        <remove-value value-name="returnItem"/>
    </simple-method>

    <simple-method method-name="updateReturnStatusFromReceipt" short-description="Update Return Status From ShipmentReceipt">
        <check-permission permission="ORDERMGR" action="_UPDATE"><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunUpdateReturnHeader"/></check-permission>
        <check-errors/>

        <set from-field="parameters.returnId" field="lookupPKMap.returnId"/>
        <find-by-primary-key entity-name="ReturnHeader" map-name="lookupPKMap" value-name="returnHeader"/>
        <find-by-and entity-name="ShipmentReceipt" map-name="lookupPKMap" list-name="shipmentReceipts"/>
        <iterate list-name="shipmentReceipts" entry-name="receipt">
          <if-empty field-name="${receipt.returnItemSeqId}" map-name="totalsMap">
            <calculate field-name="${receipt.returnItemSeqId}" map-name="totalsMap">
              <number value="0"/>
            </calculate>
          </if-empty>
          <calculate field-name="${receipt.returnItemSeqId}" map-name="totalsMap" type="Double">
            <calcop field-name="${receipt.returnItemSeqId}" map-name="totalsMap" operator="add">
              <calcop field-name="quantityAccepted" map-name="receipt" operator="get"/>
              <calcop field-name="quantityRejected" map-name="receipt" operator="get"/>
            </calcop>
          </calculate>
          <set from-field="receipt.returnId" field="newLookupMap.returnId"/>
          <set from-field="receipt.returnItemSeqId" field="newLookupMap.returnItemSeqId"/>
          <find-by-primary-key entity-name="ReturnItem" map-name="newLookupMap" value-name="returnItem"/>
          <if-compare-field field-name="returnQuantity" map-name="returnItem" operator="greater-equals" to-field-name="${receipt.returnItemSeqId}" to-map-name="totalsMap" type="Double">
            <!-- update the status for the item -->
            <set field="returnItem.statusId" value="RETURN_RECEIVED"/>
            <store-value value-name="returnItem"/>
            <!-- create status change history -->
            <make-value entity-name="ReturnStatus" value-name="newValue"/>
            <sequenced-id-to-env sequence-name="ReturnStatus" env-name="returnStatusId"/>
            <set from-field="returnStatusId" field="newValue.returnStatusId"/>

            <set from-field="returnItem.returnItemSeqId" field="newValue.returnId"/>
            <set from-field="returnItem.returnId" field="newValue.returnId"/>
            <set from-field="returnItem.statusId" field="newValuereturnId.returnId"/>

            <now-timestamp-to-env env-name="nowTimestamp"/>
            <set from-field="nowTimestamp" field="newValue.statusDatetime"/>

            <create-value value-name="newValue"/>
          </if-compare-field>
        </iterate>

        <!-- check to see if all items have been received -->
        <set value="true" field="allReceived"/>
        <find-by-and entity-name="ReturnItem" map-name="lookupPKMap" list-name="allReturnItems"/>
        <iterate list-name="allReturnItems" entry-name="item">
          <if-compare field-name="statusId" map-name="item" operator="not-equals" value="RETURN_RECEIVED">
            <if-not-empty field-name="orderItemSeqId" map-name="item">
                <!-- non-order items (i.e. adjustments) are not received -->
                <set value="false" field="allReceived"/>
            </if-not-empty>
          </if-compare>
        </iterate>
        <if-compare field-name="allReceived" operator="equals" value="true">
          <!-- update the return header -->
          <set field="returnHeaderCtx.statusId" value="RETURN_RECEIVED"/>
          <set from-field="returnHeader.returnId" field="returnHeaderCtx.returnId"/>
          <call-service service-name="updateReturnHeader" in-map-name="returnHeaderCtx"/>
          <!-- create the status history -->
          <make-value entity-name="ReturnStatus" value-name="newValue"/>
          <sequenced-id-to-env sequence-name="ReturnStatus" env-name="returnStatusId"/>
          <set from-field="returnStatusId" field="newValue.returnStatusId"/>

          <set from-field="returnHeader.returnId" field="newValue.returnId"/>
          <set value="RETURN_RECEIVED" field="newValue.statusId"/>

          <now-timestamp-to-env env-name="nowTimestamp"/>
          <set from-field="nowTimestamp" field="newValue.statusDatetime"/>

          <create-value value-name="newValue"/>
        </if-compare>

        <!-- return the current return header status -->
        <field-to-result field-name="statusId" map-name="returnHeader" result-name="returnHeaderStatus"/>
    </simple-method>
    
    <simple-method method-name="quickReturnFromOrder" short-description="Create Quick Return From Order">
        <if>
          <condition>
            <and>
              <not><if-has-permission permission="ORDERMGR" action="_CREATE"/></not>
              <not><if-compare-field field-name="partyId" map-name="userLogin" operator="equals" to-field-name="fromPartyId" to-map-name="parameters"/></not>
            </and>
          </condition>
          <then>
            <add-error><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunQuickReturnFromOrder"/></add-error>
          </then>
        </if>
        <check-errors/>

        <!-- get primary information from the order header -->
        <entity-one entity-name="OrderHeader" value-name="orderHeader">
            <field-map env-name="parameters.orderId" field-name="orderId"/>
        </entity-one>

        <!-- find the bill to customer; for return's fromPartyId -->
        <entity-condition entity-name="OrderRole" list-name="orderRoles">
            <condition-list combine="and">
                <condition-expr field-name="orderId" operator="equals" env-name="orderHeader.orderId"/>
                <condition-expr field-name="roleTypeId" operator="equals" value="BILL_TO_CUSTOMER"/>
            </condition-list>
        </entity-condition>
        <first-from-list entry-name="orderRole" list-name="orderRoles"/>

        <!-- create the return header -->
        <set from-field="orderHeader.originFacilityId" field="createHeaderCtx.destinationFacilityId"/>
        <set from-field="orderRole.partyId" field="createHeaderCtx.fromPartyId"/>
        <set value="Y" field="updateHeaderCtx.needsInventoryReceive"/>
        <set from-field="parameters.returnHeaderTypeId" field="createHeaderCtx.returnHeaderTypeId"/>

        <!-- get the return to party from the product store -->
        <get-related-one relation-name="ProductStore" value-name="orderHeader" to-value-name="productStore"/>
        <set from-field="productStore.payToPartyId" field="createHeaderCtx.toPartyId"/>

        <if-empty field-name="destinationFacilityId" map-name="createHeaderCtx">
            <get-related-one value-name="orderHeader" relation-name="ProductStore" to-value-name="productStore"/>
            <set from-field="productStore.inventoryFacilityId" field="createHeaderCtx.destinationFacilityId"/>
        </if-empty>
 
        <!-- copy over the currency of the order to the currency of the return -->
        <set from-field="orderHeader.currencyUom" field="createHeaderCtx.currencyUomId"/>

        <call-service service-name="createReturnHeader" in-map-name="createHeaderCtx" include-user-login="true">
            <result-to-field result-name="returnId"/>
        </call-service>

        <!-- get the available to return order items -->
        <entity-condition entity-name="OrderItem" list-name="orderItems">
            <condition-list combine="and">
                <condition-expr field-name="orderId" operator="equals" env-name="orderHeader.orderId"/>
                <condition-expr field-name="statusId" operator="equals" value="ITEM_COMPLETED"/>
            </condition-list>
        </entity-condition>

        <if-empty field-name="returnReasonId" map-name="parameters">
            <set value="RTN_NOT_WANT" field="parameters.returnReasonId"/>
        </if-empty>
        <if-empty field-name="returnTypeId" map-name="parameters">
            <set value="RTN_REFUND" field="parameters.returnTypeId"/>
        </if-empty>

        <!-- create the return items -->
        <calculate field-name="returnTotal" type="Double"><number value="0.0"/></calculate>
        <iterate entry-name="orderItem" list-name="orderItems">
<!--            <set value="ITEM" field="newItemCtx.returnItemType"/> -->
            <field-to-field field-name="returnId" to-map-name="newItemCtx"/>
            <field-to-field field-name="returnReasonId" map-name="parameters" to-map-name="newItemCtx"/>
            <field-to-field field-name="returnTypeId" map-name="parameters" to-map-name="newItemCtx"/>

            <if-not-empty field-name="orderItem.productId">
                <env-to-field env-name="orderItem.productId" field-name="productId"  map-name="newItemCtx"/>
            </if-not-empty>

            <env-to-field env-name="orderItem.orderId" field-name="orderId" map-name="newItemCtx"/>
            <env-to-field env-name="orderItem.orderItemSeqId" field-name="orderItemSeqId" map-name="newItemCtx"/>
            <env-to-field env-name="orderItem.itemDescription" field-name="description" map-name="newItemCtx"/>

            <!-- get the returnable price and quantity -->
            <field-to-field field-name="orderItem" to-map-name="itemCheckMap"/>
            <call-service service-name="getReturnableQuantity" in-map-name="itemCheckMap">
                <result-to-field result-name="returnableQuantity" field-name="returnQuantity" map-name="newItemCtx"/>
                <result-to-field result-name="returnablePrice" field-name="returnPrice" map-name="newItemCtx"/>
            </call-service>

            <!-- add in the item amount for a calc total -->
            <calculate field-name="returnTotal">
                <calcop field-name="returnTotal" operator="add">
                    <calcop operator="multiply">
                        <calcop operator="get" field-name="returnPrice" map-name="newItemCtx"/>
                        <calcop operator="get" field-name="returnQuantity" map-name="newItemCtx"/>
                    </calcop>
                </calcop>
            </calculate>

            <!-- get the matching return item type from the order item type -->

            <set from-field="orderItem.orderItemTypeId" field="orderItemTypeId"/>
            <if-compare field-name="orderItemTypeId" value="PRODUCT_ORDER_ITEM" operator="equals">
            <!-- Check if orderItemTypeId equals PRODUCT_ORDER_ITEM, if so, use ProductType and ReturnItemTypeMap to get ReturnItemType-->
                <entity-one entity-name="Product" value-name="product">
                    <field-map field-name="productId" env-name="orderItem.productId"/>
                    <select-field field-name="productTypeId"/>
                </entity-one>
                <entity-one entity-name="ReturnItemTypeMap" value-name="returnItemTypeMapping">
            	    <field-map env-name="product.productTypeId" field-name="returnItemMapKey"/>
                </entity-one>
            <else>
            <!-- if not, try the ReturnItemTypeMap, but this may not actually work, so log a warning -->
                <log level="warning" message="Trying to find returnItemtype from ReturnItemTypeMap with orderItemtypeId [${orderItem.orderItemTypeId}] for order item [${orderItem}]"/> 
                <entity-one entity-name="ReturnItemTypeMap" value-name="returnItemTypeMapping">
                   <field-map env-name="orderItemTypeId" field-name="returnItemMapKey"/>
                </entity-one>
            </else>
            </if-compare>

            <if-empty field-name="returnItemTypeId" map-name="returnItemTypeMapping" >
                <add-error><fail-message message="No matching return item type map found for order item: [${orderItem}]"/></add-error>
                <check-errors/>
            <else>
                <set from-field="returnItemTypeMapping.returnItemTypeId" field="newItemCtx.returnItemTypeId"/>
            </else>
            </if-empty>

            <!-- create the return item -->
            <call-service service-name="createReturnItem" in-map-name="newItemCtx" include-user-login="true"/>
        </iterate>

        <!-- get the order shipping total -->
        <field-to-field field-name="orderId" map-name="orderHeader" to-map-name="shippingCtx"/>
        <call-service service-name="getOrderShippingAmount" in-map-name="shippingCtx" include-user-login="true">
            <result-to-field result-name="shippingAmount"/>
        </call-service>
        <log level="always" message="Order #${orderHeader.orderId} shipping total - ${shippingAmount}"/>

        <!-- create the shipping return adjustment -->
        <if-compare field-name="shippingAmount" operator="greater" value="0.00" type="Double">
            <log level="always" message="shipping amount is greater than 0"/>

            <string-to-field string="Shipping Adjustment" field-name="description" map-name="shipItemCtx"/>
            <string-to-field string="RITM_SHIPPING_CHRG" field-name="returnItemTypeId" map-name="shipItemCtx"/>

            <field-to-field field-name="returnId" to-map-name="shipItemCtx"/>
            <field-to-field field-name="returnReasonId" map-name="parameters" to-map-name="shipItemCtx"/>
            <field-to-field field-name="returnTypeId" map-name="parameters" to-map-name="shipItemCtx"/>
            <field-to-field field-name="orderId" map-name="orderHeader" to-map-name="shipItemCtx"/>

            <env-to-field env-name="orderHeader.orderId" field-name="orderId" map-name="shipItemCtx"/>
            <env-to-field env-name="shippingAmount" field-name="returnPrice" map-name="shipItemCtx"/>

            <calculate field-name="returnQuantity" map-name="shipItemCtx" type="Double">
                <number value="1"/>
            </calculate>

            <!-- add in the item amount for a calc total -->
            <calculate field-name="returnTotal" type="Double">
                <calcop field-name="returnTotal" operator="add">
                    <calcop operator="multiply">
                        <calcop operator="get" field-name="returnPrice" map-name="shipItemCtx"/>
                        <calcop operator="get" field-name="returnQuantity" map-name="shipItemCtx"/>
                    </calcop>
                </calcop>
            </calculate>

            <!-- create the shipping adjustment return item -->
            <call-service service-name="createReturnItem" in-map-name="shipItemCtx" include-user-login="true"/>
        </if-compare>

        <!-- get the order total - return total diff -->
        <calculate field-name="totalDiff" type="Double" decimal-format="##0.00">
            <calcop operator="subtract">
                <calcop operator="get" field-name="grandTotal" map-name="orderHeader"/>
                <calcop operator="get" field-name="returnTotal"/>
            </calcop>
        </calculate>
        <log level="always" message="OrderTotal [${orderHeader.grandTotal}] - ReturnTotal [${returnTotal}] Diff = [${totalDiff}]"/>

        <!-- create the balance adjustment -->
        <if-compare field-name="totalDiff" operator="not-equals" value="0" type="Double">
            <log level="always" message="diff amount is not 0"/>

            <string-to-field string="Balance Adjustment" field-name="description" map-name="balanceItemCtx"/>
            <string-to-field string="RETURN_MAN_ADJ" field-name="returnItemTypeId" map-name="balanceItemCtx"/>

            <field-to-field field-name="returnId" to-map-name="balanceItemCtx"/>
            <field-to-field field-name="returnReasonId" map-name="parameters" to-map-name="balanceItemCtx"/>
            <field-to-field field-name="returnTypeId" map-name="parameters" to-map-name="balanceItemCtx"/>
            <field-to-field field-name="orderId" map-name="orderHeader" to-map-name="balanceItemCtx"/>

            <env-to-field env-name="orderHeader.orderId" field-name="orderId" map-name="balanceItemCtx"/>
            <env-to-field env-name="totalDiff" field-name="returnPrice" map-name="balanceItemCtx"/>

            <calculate field-name="returnQuantity" map-name="balanceItemCtx" type="Double">
                <number value="1"/>
            </calculate>

            <!-- create the shipping adjustment return item -->
            <call-service service-name="createReturnItem" in-map-name="balanceItemCtx" include-user-login="true"/>
        </if-compare>

        <!-- update the header status -->
        <string-to-field string="RETURN_ACCEPTED" field-name="statusId" map-name="updateHeaderCtx"/>
        <field-to-field field-name="returnId" to-map-name="updateHeaderCtx"/>
        <call-service service-name="updateReturnHeader" in-map-name="updateHeaderCtx" include-user-login="true"/>

        <!-- auto-receive this return if we passed in the flag -->
        <if-compare field-name="receiveReturn" map-name="parameters" operator="equals" value="true" type="Boolean">
            <field-to-field field-name="returnId" to-map-name="receiveCtx"/>
            <call-service service-name="quickReceiveReturn" in-map-name="receiveCtx"/>
        <else>
            <!-- update the header status -->
            <log level="info" message="Receive flag not set; will handle receiving on entity-sync"/>            
        </else>
        </if-compare>

        <field-to-result field-name="returnId"/>
    </simple-method>
</simple-methods>
