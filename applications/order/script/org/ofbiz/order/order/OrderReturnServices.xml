<?xml version="1.0" encoding="UTF-8" ?>
<!--
 *  Copyright (c) 2003-2005 The Open For Business Project - www.ofbiz.org
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included
 *  in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 *  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 *  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 *  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
 *  OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
 *  THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * @author     Andy Zeneski (jaz@ofbiz.org)
 * @version    $Rev$
 * @since      2.2
-->

<simple-methods xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
        xsi:noNamespaceSchemaLocation="http://www.ofbiz.org/dtds/simple-methods.xsd">
    <simple-method method-name="createReturnHeader" short-description="Create a ReturnHeader">
        <now-timestamp-to-env env-name="nowTimestamp"/>

        <if>
            <condition>
                <and>
                    <not><if-has-permission permission="ORDERMGR" action="_CREATE"/></not>
                    <not><if-compare-field field-name="partyId" map-name="userLogin" operator="equals" to-field-name="fromPartyId" to-map-name="parameters"/></not>
                </and>
            </condition>
            <then>
                <add-error><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunCreateReturnHeader"/></add-error>
            </then>
        </if>

        <if-empty field-name="parameters.toPartyId">
            <!-- no toPartyId was specified.  use destination facility to determine the party of the return -->
            <if-not-empty field-name="parameters.destinationFacilityId">
                <entity-one entity-name="Facility" value-name="destinationFacility" auto-field-map="false">
                    <field-map field-name="facilityId" env-name="parameters.destinationFacilityId"/>
                </entity-one>
                <set from-field="destinationFacility.ownerPartyId" field="parameters.toPartyId"/>
            </if-not-empty>
        <else>
            <!-- make sure that the party to return to is an INTERNAL_ORGANIZATIO or stop 
            TODO: if we want to implement returns to vendor later, simply change this to make sure that EITHER fromPartyId or toPartyId
            is an internal organization, and possibly also do a security check on the user -->
            <entity-one entity-name="PartyRole" value-name="partyRole" use-cache="true" auto-field-map="false">
                <field-map field-name="partyId" env-name="parameters.toPartyId"/>
                <field-map field-name="roleTypeId" value="INTERNAL_ORGANIZATIO"/>
            </entity-one>
            <if-empty field-name="partyRole">
                <add-error><fail-message message="Error: a return must be to a party in the role of internal organization"/></add-error>
            </if-empty>
         </else>
        </if-empty>
        <check-errors/>

        <!-- check the needs (auto) inventory receive flag (default to no) -->
        <if-empty field-name="parameters.needsInventoryReceive">
            <set field="parameters.needsInventoryReceive" value="N"/>
        </if-empty>

        <make-value value-name="newEntity" entity-name="ReturnHeader"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>

        <!-- If PartyAcctgPreference.useInvoiceIdForReturns is Y, get the ID from the getNextInvoiceId service -->
        <entity-one entity-name="PartyAcctgPreference" value-name="partyAcctgPreference" auto-field-map="false">
            <field-map field-name="partyId" env-name="parameters.toPartyId"/>
        </entity-one>
        <if-compare field-name="partyAcctgPreference.useInvoiceIdForReturns" operator="equals" value="Y">
            <set field="getNextInvoiceIdMap.partyId" from-field="parameters.toPartyId"/>
            <call-service service-name="getNextInvoiceId" in-map-name="getNextInvoiceIdMap">
                <result-to-field result-name="invoiceId" field-name="newEntity.returnId"/>
            </call-service>        
            
            <else>
                <sequenced-id-to-env sequence-name="ReturnHeader" env-name="newEntity.returnId"/>
            </else>            
        </if-compare>
        <field-to-result field-name="newEntity.returnId" result-name="returnId"/>
        
        <if>
            <condition>
                <not><if-has-permission permission="ORDERMGR" action="_CREATE"/></not>
            </condition>
            <then>
                <set field="newEntity.statusId" value="RETURN_REQUESTED"/>
                <set from-field="nowTimestamp" field="newEntity.entryDate"/>
            </then>
        </if>

        <if-empty field-name="newEntity.entryDate">
            <set from-field="nowTimestamp" field="newEntity.entryDate"/>
        </if-empty>

        <if-empty field-name="newEntity.statusId">
            <set value="RETURN_REQUESTED" field="newEntity.statusId"/>
        </if-empty>
        <set field="newEntity.createdBy" from-field="userLogin.userLoginId"/>

        <create-value value-name="newEntity"/>
        <set field="responseMessage" value="Return Request #${returnId} was created successfully."/>
        <field-to-result field-name="responseMessage" result-name="successMessage"/>
    </simple-method>
    <simple-method method-name="updateReturnHeader" short-description="Update a ReturnHeader">
        <check-permission permission="ORDERMGR" action="_UPDATE"><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunUpdateReturnHeader"/></check-permission>
        <check-errors/>

        <set from-field="parameters.returnId" field="lookupPKMap.returnId"/>
        <find-by-primary-key entity-name="ReturnHeader" map-name="lookupPKMap" value-name="returnHeader"/>

        <field-to-result field-name="returnHeader.statusId" result-name="currentStatusId"/>
        <set-nonpk-fields map-name="parameters" value-name="returnHeader"/>
        <store-value value-name="returnHeader"/>
    </simple-method>

    <simple-method method-name="createReturnItem" short-description="Create Return Item">
        <set field="lookupPKMap.returnId" from-field="parameters.returnId"/>
        <find-by-primary-key entity-name="ReturnHeader" map-name="lookupPKMap" value-name="returnHeader"/>

        <if>
          <condition>
            <and>
              <not><if-has-permission permission="ORDERMGR" action="_CREATE"/></not>
              <not><if-compare-field field-name="partyId" map-name="userLogin" operator="equals" to-field-name="fromPartyId" to-map-name="returnHeader"/></not>
            </and>
          </condition>
          <then>
            <add-error><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunCreateReturnItem"/></add-error>
          </then>
        </if>
        <check-errors/>

        <if-empty field-name="returnItemTypeId"  map-name="parameters">
            <if-not-empty field-name="returnItemMapKey" map-name="parameters">
                <!-- find the item mapping -->
            </if-not-empty>
        </if-empty>

        <if-empty field-name="returnItemTypeId" map-name="parameters">
            <add-error><fail-message message="Return Item Type is not defined for this item; or no mapping was found."/></add-error>
            <check-errors/>
        </if-empty>

        <if-compare field-name="returnQuantity" map-name="parameters" operator="equals" value="0" type="Double">
            <add-error><fail-property resource="OrderErrorUiLabels" property="OrderNoReturnQuantityAvailablePreviousReturnsMayExist"/></add-error>
            <check-errors/>
        </if-compare>

        <!-- setup some default values for protection -->
        <set field="returnableQuantity" value="0" type="Double"/>
        <set field="returnablePrice" value="0" type="Double"/>

        <if-not-empty field-name="parameters.orderItemSeqId">
            <make-value value-name="itemLookup" entity-name="OrderItem"/>
            <set-pk-fields map-name="parameters" value-name="itemLookup"/>
            <if-not-empty field-name="parameters.orderItemSeqId">
                <find-by-primary-key entity-name="OrderItem" value-name="orderItem" map-name="itemLookup"/>
                <log level="always" message="Return item is an OrderItem - ${orderItem.orderItemSeqId}"/>
            </if-not-empty>
        </if-not-empty>

        <if-not-empty field-name="parameters.orderAdjustmentId">
            <make-value value-name="adjLookup" entity-name="OrderAdjustment"/>
            <set-pk-fields value-name="adjLookup" map-name="parameters"/>
            <if-not-empty field-name="parameters.orderAdjustmentId">
                <find-by-primary-key map-name="adjLookup" value-name="orderAdjustment" entity-name="OrderAdjustment"/>
                <log level="always" message="Return item is an OrderAdjustment - ${orderAdjustment.orderAdjustmentId}"/>
            </if-not-empty>
        </if-not-empty>

        <if-not-empty field-name="orderItem">
            <set field="serviceContext.orderItem" from-field="orderItem"/>
            <call-service service-name="getReturnableQuantity" in-map-name="serviceContext">
                <result-to-field result-name="returnableQuantity" field-name="returnableQuantity"/>
                <result-to-field result-name="returnablePrice" field-name="returnablePrice"/>
            </call-service>
        </if-not-empty>

        <if-not-empty field-name="orderAdjustment">
            <set field="returnableQuantity" value="1" type="Double"/>
            <set field="returnablePrice" from-field="parameters.returnPrice" type="Double"/>
            <log level="always" message="set return price to the input amount : ${returnablePrice}"/>
        </if-not-empty>

        <if-compare field-name="returnItemTypeId" value="RETURN_MAN_ADJ" operator="equals">
            <set field="returnableQuantity" value="1" type="Double"/>
            <set field="returnablePrice" from-field="orderAdjustment.amount" type="Double"/>
            <log level="always" message="set return price to adjustment amount : ${returnablePrice}"/>
        </if-compare>

        <if-compare field-name="returnableQuantity" value="0" operator="greater" type="Double">
            <if>
                <condition>
                      <not><if-has-permission permission="ORDERMGR" action="_CREATE"/></not>
                </condition>
                <then>
                      <set from-field="returnablePrice" field="parameters.returnPrice"/>
                </then>
            </if>

            <if-compare-field field-name="returnQuantity" map-name="parameters" operator="greater" to-field-name="returnableQuantity" type="Double">
                <add-error><fail-property resource="OrderErrorUiLabels" property="OrderRequestedReturnQuantityNotAvailablePreviousReturnsMayExist"/></add-error>
            </if-compare-field>

            <if-not-empty field-name="orderItem">
                <if-compare-field field-name="returnQuantity" map-name="parameters" operator="greater" to-field-name="quantity" to-map-name="orderItem" type="Double">
                    <add-error><fail-property resource="OrderErrorUiLabels" property="OrderReturnQuantityCannotExceedTheOrderedQuantity"/></add-error>
                </if-compare-field>
            </if-not-empty>

            <!-- Workaround for bug: returnPrice=16.99, returnablePrice=16.9894 => OrderReturnPriceCannotExceedThePurchasePrice -->
            <set field="epsilon" value="0.01" type="Double"/>
            <set field="zero" value="0.0" type="Double"/>
            <calculate field-name="returnPriceDelta" type="Double">
                <calcop operator="subtract">
                    <calcop operator="get" field-name="returnPrice" map-name="parameters"/>
                    <calcop operator="get" field-name="returnablePrice"/>
                </calcop>
            </calculate>
            <if-compare-field field-name="returnPriceDelta" operator="less" to-field-name="zero" type="Double">
                <calculate field-name="returnPriceDelta" type="Double"><calcop field-name="returnPriceDelta" operator="negative"/></calculate>
            </if-compare-field>

            <if-compare-field field-name="returnPriceDelta" operator="greater-equals" to-field-name="epsilon" type="Double">
                <add-error><fail-property resource="OrderErrorUiLabels" property="OrderReturnPriceCannotExceedThePurchasePrice"/></add-error>
            </if-compare-field>
            <check-errors/>

            <else>
                <if-compare field-name="returnItemTypeId" map-name="parameters" operator="not-equals" type="String" value="RETURN_MAN_ADJ">
                    <add-error><fail-property resource="OrderErrorUiLabels" property="OrderIllegalReturnItemTypePassed"/></add-error>
                    <check-errors/>
                </if-compare>
            </else>
        </if-compare>

        <!-- test the total return amount vs the total order amount -->
        <if-not-empty field-name="parameters.orderId">
            <set field="returnTotalCtx.adjustment" from-field="parameters.returnPrice"/>
            <set field="returnTotalCtx.orderId" from-field="parameters.orderId"/>
            <call-service service-name="getOrderAvailableReturnedTotal" in-map-name="returnTotalCtx">
                <result-to-field result-name="availableReturnTotal" field-name="availableReturnTotal"/>
                <result-to-field result-name="returnTotal" field-name="returnTotal"/>
                <result-to-field result-name="orderTotal" field-name="orderTotal"/>
            </call-service>
            <log level="always" message="Available amount for return (order #${parameters.orderId}) : ${availableReturnTotal} [${orderTotal} / ${returnTotal} / ${parameters.returnPrice}]"/>
            <if-compare field-name="availableReturnTotal" operator="less" value="0" type="Double">
                <add-error><fail-property resource="OrderErrorUiLabels" property="OrderReturnPriceCannotExceedTheOrderTotal"/></add-error>
            </if-compare>
        <else>
            <log level="always" message="Not an order based return; unable to check valid amounts!"/>
        </else>
        </if-not-empty>
        <check-errors/>

        <make-value value-name="newEntity" entity-name="ReturnItem"/>
        <set from-field="parameters.returnId" field="newEntity.returnId"/>
        <set from-field="parameters.returnId" field="lookupMap.returnId"/>
        <string-to-list string="-returnItemSeqId" list-name="orderBy"/>
        <find-by-and entity-name="ReturnItem" list-name="currentItems" map-name="lookupMap" order-by-list-name="orderBy"></find-by-and>
        <if-empty field-name="currentItems">
            <set value="1" field="newEntity.returnItemSeqId"/>
        <else>
           <first-from-list entry-name="newestItem" list-name="currentItems"/>
           <calculate field-name="returnItemSeqId" map-name="newEntity" type="Integer">
               <calcop field-name="returnItemSeqId" map-name="newestItem" operator="add">
                   <number value="1"/>
               </calcop>
           </calculate>
        </else>
        </if-empty>
        <to-string field-name="returnItemSeqId" map-name="newEntity" numeric-padding="5"/>

        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>
        <set field="newEntity.statusId" value="RETURN_REQUESTED"/>
        <field-to-result field-name="returnItemSeqId" map-name="newEntity" result-name="returnItemSeqId"/>
        <log level="always" message="Return Item Seq ID: ${newEntity.returnItemSeqId}"/>
        <create-value value-name="newEntity"/>
    </simple-method>
    <simple-method method-name="updateReturnItem" short-description="Update Return Item">
        <check-permission permission="ORDERMGR" action="_UPDATE"><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunUpdateReturnHeader"/></check-permission>
        <check-errors/>

        <set from-field="parameters.returnId" field="lookupPKMap.returnId"/>
        <set from-field="parameters.returnItemSeqId" field="lookupPKMap.returnItemSeqId"/>
        <find-by-primary-key entity-name="ReturnItem" map-name="lookupPKMap" value-name="returnItem"/>

        <field-to-result field-name="returnItem.statusId" result-name="currentStatusId"/>
        <set-nonpk-fields map-name="parameters" value-name="returnItem"/>
        <store-value value-name="returnItem"/>
    </simple-method>
    <simple-method method-name="updateReturnItemsStatus" short-description="Update Return Items Status">
        <check-permission permission="ORDERMGR" action="_UPDATE"><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunUpdateReturnHeader"/></check-permission>
        <check-errors/>

        <set from-field="parameters.returnId" field="lookupPKMap.returnId"/>
        <find-by-and entity-name="ReturnItem" map-name="lookupPKMap" list-name="returnItems"/>
        <iterate entry-name="item" list-name="returnItems">
            <set field="item.statusId" from-field="parameters.statusId"/>
        </iterate>
        <store-list list-name="returnItems"/>
    </simple-method>
    <simple-method method-name="removeReturnItem" short-description="Remove Return Item">
        <check-permission permission="ORDERMGR" action="_DELETE"><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunRemoveQuoteItem"/></check-permission>
        <check-errors/>

        <set from-field="parameters.returnId" field="headerPKMap.returnId"/>
        <find-by-primary-key entity-name="ReturnHeader" map-name="headerPKMap" value-name="returnHeader"/>
        <if-compare field-name="statusId" map-name="returnHeader" operator="not-equals" type="String" value="RETURN_REQUESTED">
            <add-error><fail-property resource="OrderErrorUiLabels" property="OrderCannotRemoveItemsOnceReturnIsApproved"/></add-error>
            <check-errors/>
        </if-compare>

        <set from-field="parameters.returnId" field="lookupPKMap.returnId"/>
        <set from-field="parameters.returnItemSeqId" field="lookupPKMap.returnItemSeqId"/>
        <find-by-primary-key entity-name="ReturnItem" map-name="lookupPKMap" value-name="returnItem"/>

        <remove-value value-name="returnItem"/>
    </simple-method>

    <simple-method method-name="updateReturnStatusFromReceipt" short-description="Update Return Status From ShipmentReceipt">
        <check-permission permission="ORDERMGR" action="_UPDATE"><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunUpdateReturnHeader"/></check-permission>
        <check-errors/>

        <set from-field="parameters.returnId" field="lookupPKMap.returnId"/>
        <find-by-primary-key entity-name="ReturnHeader" map-name="lookupPKMap" value-name="returnHeader"/>
        <find-by-and entity-name="ShipmentReceipt" map-name="lookupPKMap" list-name="shipmentReceipts"/>
        <iterate list-name="shipmentReceipts" entry-name="receipt">
          <if-empty field-name="${receipt.returnItemSeqId}" map-name="totalsMap">
            <calculate field-name="${receipt.returnItemSeqId}" map-name="totalsMap">
              <number value="0"/>
            </calculate>
          </if-empty>
          <calculate field-name="${receipt.returnItemSeqId}" map-name="totalsMap" type="Double">
            <calcop field-name="${receipt.returnItemSeqId}" map-name="totalsMap" operator="add">
              <calcop field-name="quantityAccepted" map-name="receipt" operator="get"/>
              <calcop field-name="quantityRejected" map-name="receipt" operator="get"/>
            </calcop>
          </calculate>
          <set from-field="receipt.returnId" field="newLookupMap.returnId"/>
          <set from-field="receipt.returnItemSeqId" field="newLookupMap.returnItemSeqId"/>
          <find-by-primary-key entity-name="ReturnItem" map-name="newLookupMap" value-name="returnItem"/>
          <if-compare-field field-name="returnQuantity" map-name="returnItem" operator="greater-equals" to-field-name="${receipt.returnItemSeqId}" to-map-name="totalsMap" type="Double">
            <!-- update the status for the item -->
            <set field="returnItem.statusId" value="RETURN_RECEIVED"/>
            <store-value value-name="returnItem"/>
            <!-- create status change history -->
            <make-value entity-name="ReturnStatus" value-name="newValue"/>
            <sequenced-id-to-env sequence-name="ReturnStatus" env-name="returnStatusId"/>
            <set from-field="returnStatusId" field="newValue.returnStatusId"/>

            <set from-field="returnItem.returnItemSeqId" field="newValue.returnId"/>
            <set from-field="returnItem.returnId" field="newValue.returnId"/>
            <set from-field="returnItem.statusId" field="newValuereturnId.returnId"/>

            <now-timestamp-to-env env-name="nowTimestamp"/>
            <set from-field="nowTimestamp" field="newValue.statusDatetime"/>

            <create-value value-name="newValue"/>
          </if-compare-field>
        </iterate>

        <!-- check to see if all items have been received -->
        <set value="true" field="allReceived"/>
        <find-by-and entity-name="ReturnItem" map-name="lookupPKMap" list-name="allReturnItems"/>
        <iterate list-name="allReturnItems" entry-name="item">
          <if-compare field-name="statusId" map-name="item" operator="not-equals" value="RETURN_RECEIVED">
            <if-not-empty field-name="orderItemSeqId" map-name="item">
                <!-- non-order items (i.e. adjustments) are not received -->
                <set value="false" field="allReceived"/>
            </if-not-empty>
          </if-compare>
        </iterate>
        <if-compare field-name="allReceived" operator="equals" value="true">
          <!-- update the return header -->
          <set field="returnHeaderCtx.statusId" value="RETURN_RECEIVED"/>
          <set from-field="returnHeader.returnId" field="returnHeaderCtx.returnId"/>
          <call-service service-name="updateReturnHeader" in-map-name="returnHeaderCtx"/>
          <!-- create the status history -->
          <make-value entity-name="ReturnStatus" value-name="newValue"/>
          <sequenced-id-to-env sequence-name="ReturnStatus" env-name="returnStatusId"/>
          <set from-field="returnStatusId" field="newValue.returnStatusId"/>

          <set from-field="returnHeader.returnId" field="newValue.returnId"/>
          <set value="RETURN_RECEIVED" field="newValue.statusId"/>

          <now-timestamp-to-env env-name="nowTimestamp"/>
          <set from-field="nowTimestamp" field="newValue.statusDatetime"/>

          <create-value value-name="newValue"/>
        </if-compare>

        <!-- return the current return header status -->
        <field-to-result field-name="statusId" map-name="returnHeader" result-name="returnHeaderStatus"/>
    </simple-method>
    
    <simple-method method-name="quickReturnFromOrder" short-description="Create Quick Return From Order">
        <if>
          <condition>
            <and>
              <not><if-has-permission permission="ORDERMGR" action="_CREATE"/></not>
              <not><if-compare-field field-name="partyId" map-name="userLogin" operator="equals" to-field-name="fromPartyId" to-map-name="parameters"/></not>
            </and>
          </condition>
          <then>
            <add-error><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunQuickReturnFromOrder"/></add-error>
          </then>
        </if>
        <check-errors/>

        <!-- get primary information from the order header -->
        <entity-one entity-name="OrderHeader" value-name="orderHeader">
            <field-map env-name="parameters.orderId" field-name="orderId"/>
        </entity-one>

        <!-- find the bill to customer; for return's fromPartyId -->
        <entity-condition entity-name="OrderRole" list-name="orderRoles">
            <condition-list combine="and">
                <condition-expr field-name="orderId" operator="equals" env-name="orderHeader.orderId"/>
                <condition-expr field-name="roleTypeId" operator="equals" value="BILL_TO_CUSTOMER"/>
            </condition-list>
        </entity-condition>
        <first-from-list entry-name="orderRole" list-name="orderRoles"/>

        <!-- create the return header -->
        <set from-field="orderHeader.originFacilityId" field="createHeaderCtx.destinationFacilityId"/>
        <set from-field="orderRole.partyId" field="createHeaderCtx.fromPartyId"/>
        <set value="Y" field="updateHeaderCtx.needsInventoryReceive"/>
        <set from-field="parameters.returnHeaderTypeId" field="createHeaderCtx.returnHeaderTypeId"/>

        <!-- get the return to party from the product store -->
        <get-related-one relation-name="ProductStore" value-name="orderHeader" to-value-name="productStore"/>
        <set from-field="productStore.payToPartyId" field="createHeaderCtx.toPartyId"/>

        <if-empty field-name="destinationFacilityId" map-name="createHeaderCtx">
            <get-related-one value-name="orderHeader" relation-name="ProductStore" to-value-name="productStore"/>
            <set from-field="productStore.inventoryFacilityId" field="createHeaderCtx.destinationFacilityId"/>
        </if-empty>
 
        <!-- copy over the currency of the order to the currency of the return -->
        <set from-field="orderHeader.currencyUom" field="createHeaderCtx.currencyUomId"/>

        <call-service service-name="createReturnHeader" in-map-name="createHeaderCtx" include-user-login="true">
            <result-to-field result-name="returnId"/>
        </call-service>

        <!-- get the available to return order items -->
        <entity-condition entity-name="OrderItem" list-name="orderItems">
            <condition-list combine="and">
                <condition-expr field-name="orderId" operator="equals" env-name="orderHeader.orderId"/>
                <condition-expr field-name="statusId" operator="equals" value="ITEM_COMPLETED"/>
            </condition-list>
        </entity-condition>

        <if-empty field-name="returnReasonId" map-name="parameters">
            <set value="RTN_NOT_WANT" field="parameters.returnReasonId"/>
        </if-empty>
        <if-empty field-name="returnTypeId" map-name="parameters">
            <set value="RTN_REFUND" field="parameters.returnTypeId"/>
        </if-empty>

        <!-- create the return items -->
        <calculate field-name="returnTotal" type="Double"><number value="0.0"/></calculate>
        <iterate entry-name="orderItem" list-name="orderItems">
            <set value="ITEM" field="newItemCtx.returnItemType"/>
            <field-to-field field-name="returnId" to-map-name="newItemCtx"/>
            <field-to-field field-name="returnReasonId" map-name="parameters" to-map-name="newItemCtx"/>
            <field-to-field field-name="returnTypeId" map-name="parameters" to-map-name="newItemCtx"/>
            <env-to-field env-name="orderItem.orderId" field-name="orderId" map-name="newItemCtx"/>
            <env-to-field env-name="orderItem.orderItemSeqId" field-name="orderItemSeqId" map-name="newItemCtx"/>
            <env-to-field env-name="orderItem.itemDescription" field-name="description" map-name="newItemCtx"/>

            <!-- get the returnable price and quantity -->
            <field-to-field field-name="orderItem" to-map-name="itemCheckMap"/>
            <call-service service-name="getReturnableQuantity" in-map-name="itemCheckMap">
                <result-to-field result-name="returnableQuantity" field-name="returnQuantity" map-name="newItemCtx"/>
                <result-to-field result-name="returnablePrice" field-name="returnPrice" map-name="newItemCtx"/>
            </call-service>

            <!-- add in the item amount for a calc total -->
            <calculate field-name="returnTotal">
                <calcop field-name="returnTotal" operator="add">
                    <calcop operator="multiply">
                        <calcop operator="get" field-name="returnPrice" map-name="newItemCtx"/>
                        <calcop operator="get" field-name="returnQuantity" map-name="newItemCtx"/>
                    </calcop>
                </calcop>
            </calculate>

            <!-- create the return item -->
            <call-service service-name="createReturnItem" in-map-name="newItemCtx" include-user-login="true"/>
        </iterate>

        <!-- get the order shipping total -->
        <field-to-field field-name="orderId" map-name="orderHeader" to-map-name="shippingCtx"/>
        <call-service service-name="getOrderShippingAmount" in-map-name="shippingCtx" include-user-login="true">
            <result-to-field result-name="shippingAmount"/>
        </call-service>
        <log level="always" message="Order #${orderHeader.orderId} shipping total - ${shippingAmount}"/>

        <!-- create the shipping return adjustment -->
        <if-compare field-name="shippingAmount" operator="greater" value="0.00" type="Double">
            <log level="always" message="shipping amount is greater than 0"/>

            <string-to-field string="Shipping Adjustment" field-name="description" map-name="shipItemCtx"/>
            <string-to-field string="ADJUSTMENT" field-name="returnItemType" map-name="shipItemCtx"/>

            <field-to-field field-name="returnId" to-map-name="shipItemCtx"/>
            <field-to-field field-name="returnReasonId" map-name="parameters" to-map-name="shipItemCtx"/>
            <field-to-field field-name="returnTypeId" map-name="parameters" to-map-name="shipItemCtx"/>
            <field-to-field field-name="orderId" map-name="orderHeader" to-map-name="shipItemCtx"/>

            <env-to-field env-name="orderHeader.orderId" field-name="orderId" map-name="shipItemCtx"/>
            <env-to-field env-name="shippingAmount" field-name="returnPrice" map-name="shipItemCtx"/>

            <calculate field-name="returnQuantity" map-name="shipItemCtx" type="Double">
                <number value="1"/>
            </calculate>

            <!-- add in the item amount for a calc total -->
            <calculate field-name="returnTotal" type="Double">
                <calcop field-name="returnTotal" operator="add">
                    <calcop operator="multiply">
                        <calcop operator="get" field-name="returnPrice" map-name="shipItemCtx"/>
                        <calcop operator="get" field-name="returnQuantity" map-name="shipItemCtx"/>
                    </calcop>
                </calcop>
            </calculate>

            <!-- create the shipping adjustment return item -->
            <call-service service-name="createReturnItem" in-map-name="shipItemCtx" include-user-login="true"/>
        </if-compare>

        <!-- get the order total - return total diff -->
        <calculate field-name="totalDiff" type="Double" decimal-format="##0.00">
            <calcop operator="subtract">
                <calcop operator="get" field-name="grandTotal" map-name="orderHeader"/>
                <calcop operator="get" field-name="returnTotal"/>
            </calcop>
        </calculate>
        <log level="always" message="OrderTotal [${orderHeader.grandTotal}] - ReturnTotal [${returnTotal}] Diff = [${totalDiff}]"/>

        <!-- create the balance adjustment -->
        <if-compare field-name="totalDiff" operator="not-equals" value="0" type="Double">
            <log level="always" message="diff amount is not 0"/>

            <string-to-field string="Balance Adjustment" field-name="description" map-name="balanceItemCtx"/>
            <string-to-field string="ADJUSTMENT" field-name="returnItemType" map-name="balanceItemCtx"/>

            <field-to-field field-name="returnId" to-map-name="balanceItemCtx"/>
            <field-to-field field-name="returnReasonId" map-name="parameters" to-map-name="balanceItemCtx"/>
            <field-to-field field-name="returnTypeId" map-name="parameters" to-map-name="balanceItemCtx"/>
            <field-to-field field-name="orderId" map-name="orderHeader" to-map-name="balanceItemCtx"/>

            <env-to-field env-name="orderHeader.orderId" field-name="orderId" map-name="balanceItemCtx"/>
            <env-to-field env-name="totalDiff" field-name="returnPrice" map-name="balanceItemCtx"/>

            <calculate field-name="returnQuantity" map-name="balanceItemCtx" type="Double">
                <number value="1"/>
            </calculate>

            <!-- create the shipping adjustment return item -->
            <call-service service-name="createReturnItem" in-map-name="balanceItemCtx" include-user-login="true"/>
        </if-compare>

        <!-- update the header status -->
        <string-to-field string="RETURN_ACCEPTED" field-name="statusId" map-name="updateHeaderCtx"/>
        <field-to-field field-name="returnId" to-map-name="updateHeaderCtx"/>
        <call-service service-name="updateReturnHeader" in-map-name="updateHeaderCtx" include-user-login="true"/>

        <!-- auto-receive this return if we passed in the flag -->
        <if-compare field-name="receiveReturn" map-name="parameters" operator="equals" value="true" type="Boolean">
            <field-to-field field-name="returnId" to-map-name="receiveCtx"/>
            <call-service service-name="quickReceiveReturn" in-map-name="receiveCtx"/>
        <else>
            <!-- update the header status -->
            <log level="info" message="Receive flag not set; will handle receiving on entity-sync"/>            
        </else>
        </if-compare>

        <field-to-result field-name="returnId"/>
    </simple-method>
</simple-methods>
