/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*
 * Script to build the open order item report using
 * the OrderItemQuantityReportGroupByItem view.
 */


import org.ofbiz.base.util.UtilMisc;
import org.ofbiz.entity.condition.*;
import org.ofbiz.entity.util.*;
import org.ofbiz.entity.*;
import org.ofbiz.base.util.*;

productStoreId = parameters.get("productStoreId");
orderTypeId = parameters.get("orderTypeId");
orderStatusId = parameters.get("orderStatusId");
fromOrderDate = parameters.get("fromOrderDate");
thruOrderDate = parameters.get("thruOrderDate");
 

// search by orderTypeId is mandatory
conditions = UtilMisc.toList(new EntityExpr("orderTypeId", EntityOperator.EQUALS, orderTypeId));

if (UtilValidate.isDate(fromOrderDate) && UtilValidate.isNotEmpty(fromOrderDate)){
    conditions.add(new EntityExpr("orderDate", EntityOperator.GREATER_THAN_EQUAL_TO, fromOrderDate));
}
if (UtilValidate.isDate(thruOrderDate) && UtilValidate.isNotEmpty(thruOrderDate)){
    conditions.add(new EntityExpr("orderDate", EntityOperator.LESS_THAN_EQUAL_TO, thruOrderDate));
}

if (productStoreId != null && productStoreId.length() > 0) {
    conditions.add(new EntityExpr("productStoreId", EntityOperator.EQUALS, productStoreId));
    // for generating a title (given product store)
    context.put("productStore", delegator.findByPrimaryKeyCache("ProductStore", UtilMisc.toMap("productStoreId", productStoreId)));
} else {
    // for generating a title (all stores)  TODO: use UtilProperties to internationalize
    context.put("productStore", UtilMisc.toMap("storeName", "All Stores")); 
}
if (orderStatusId != null && orderStatusId.length() > 0) {
    conditions.add(new EntityExpr("orderStatusId", EntityOperator.EQUALS, orderStatusId));
} else {
    // search all orders that are not completed, cancelled or rejected
    conditions.add( 
            new EntityConditionList( UtilMisc.toList(
                    new EntityExpr("orderStatusId", EntityOperator.NOT_EQUAL, "ORDER_COMPLETED"),
                    new EntityExpr("orderStatusId", EntityOperator.NOT_EQUAL, "ORDER_CANCELLED"),
                    new EntityExpr("orderStatusId", EntityOperator.NOT_EQUAL, "ORDER_REJECTED")
                    ), EntityOperator.AND)
            );
}

// item conditions
conditions.add(new EntityExpr("orderItemStatusId", EntityOperator.NOT_EQUAL, "ITEM_COMPLETED"));
conditions.add(new EntityExpr("orderItemStatusId", EntityOperator.NOT_EQUAL, "ITEM_CANCELLED"));
conditions.add(new EntityExpr("orderItemStatusId", EntityOperator.NOT_EQUAL, "ITEM_REJECTED"));

// get the results as an entity list iterator
allConditions = new EntityConditionList( conditions, EntityOperator.AND );
fieldsToSelect = UtilMisc.toList("orderId","orderDate","productId","quantityOrdered","quantityIssued","quantityOpen");
fieldsToSelect.add("shipBeforeDate");
fieldsToSelect.add("shipAfterDate");
fieldsToSelect.add("itemDescription");
findOptions = new EntityFindOptions(true, EntityFindOptions.TYPE_SCROLL_INSENSITIVE, EntityFindOptions.CONCUR_READ_ONLY, true);
listIt = delegator.findListIteratorByCondition("OrderItemQuantityReportGroupByItem", allConditions, null, fieldsToSelect, UtilMisc.toList("orderDate DESC"), findOptions);
List orderItemList = new ArrayList();
Double totalCostPrice = new Double(0.0);
Double totalListPrice = new Double(0.0);
Double totalMarkup = new Double(0.0);
Double totalDiscount = new Double(0.0);
Double totalRetailPrice = new Double(0.0);
Double totalquantityOrdered = new Double(0.0);
Double totalquantityOpen = new Double(0.0);

while ((listValue = (GenericValue) listIt.next()) != null) {
    orderId = listValue.get("orderId");
    productId = listValue.get("productId");
    orderDate = listValue.get("orderDate");
    quantityOrdered = listValue.get("quantityOrdered");
    quantityOpen = listValue.get("quantityOpen");
    quantityIssued = listValue.get("quantityIssued");
    itemDescription = listValue.get("itemDescription");
    shipAfterDate = listValue.get("shipAfterDate");
    shipBeforeDate = listValue.get("shipBeforeDate");    
    fieldsToSelect = UtilMisc.toSet("price","productPriceTypeId");
    productIdCondExpr =  UtilMisc.toList(new EntityExpr("productId", EntityOperator.EQUALS, productId));    
    prodPriceCond = new EntityConditionList(productIdCondExpr, EntityOperator.AND);    
    productPrices = delegator.findList("ProductPrice", prodPriceCond, fieldsToSelect, null, null, false);    
    Double costPrice = new Double(0.0);
    Double retailPrice = new Double(0.0);
    Double listPrice = new Double(0.0);
    
    Iterator productPricesItr = productPrices.iterator();
    while (productPricesItr.hasNext()) {
        productPriceMap = productPricesItr.next();
        if (productPriceMap.get("productPriceTypeId").equals("AVERAGE_COST")) {
            costPrice = productPriceMap.get("price");
        } else if (productPriceMap.get("productPriceTypeId").equals("DEFAULT_PRICE")) {
            retailPrice = productPriceMap.get("price");
        } else if (productPriceMap.get("productPriceTypeId").equals("LIST_PRICE")) {
            listPrice = productPriceMap.get("price");
        }      
    }
    
    totalListPrice += listPrice;
    totalRetailPrice += retailPrice;
    totalCostPrice += costPrice;    
    totalquantityOrdered += quantityOrdered;
    totalquantityOpen += quantityOpen;    
    orderItemMap = UtilMisc.toMap("orderDate", orderDate, "orderId", orderId, "productId", productId, "itemDescription", itemDescription, "quantityOrdered", quantityOrdered,"quantityIssued", quantityIssued);
    orderItemMap.put("quantityOpen",quantityOpen);
    orderItemMap.put("shipAfterDate",shipAfterDate);
    orderItemMap.put("shipBeforeDate",shipBeforeDate);
    orderItemMap.put("costPrice",costPrice);
    orderItemMap.put("retailPrice",retailPrice);
    orderItemMap.put("listPrice",listPrice);
    orderItemMap.put("discount",(Double.toString(listPrice- retailPrice)));
    orderItemMap.put("calculatedMarkup",(Double.toString(retailPrice - costPrice)));
    orderItemMap.put("percentMarkup",(Double.toString(((retailPrice - costPrice)/costPrice)*100)));
    orderItemList.add(orderItemMap);    
}

listIt.close();
List totalAmountList = new ArrayList();
if (UtilValidate.isNotEmpty(orderItemList)) { 
    totalAmountMap = UtilMisc.toMap("totalCostPrice", totalCostPrice, "totalListPrice", totalListPrice, "totalRetailPrice", totalRetailPrice, "totalquantityOrdered", totalquantityOrdered, "quantityOrdered", quantityOrdered,"totalquantityOpen", totalquantityOpen);
    totalAmountMap.put("totalDiscount",(totalListPrice - totalRetailPrice));
    totalAmountMap.put("totalMarkup",(totalRetailPrice - totalCostPrice));
    totalAmountMap.put("totalPercentMarkup",((totalRetailPrice - totalCostPrice)/totalCostPrice)*100);
    totalAmountList.add(totalAmountMap);
}
context.put("orderItemList", orderItemList);
context.put("totalAmountList", totalAmountList);
