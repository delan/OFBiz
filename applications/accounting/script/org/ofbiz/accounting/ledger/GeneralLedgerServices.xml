<?xml version="1.0" encoding="UTF-8"?>
<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->

<simple-methods xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
        xsi:noNamespaceSchemaLocation="http://ofbiz.apache.org/dtds/simple-methods.xsd">

    <!-- ========= GlAccount methods ========= -->
    <simple-method method-name="createGlAccount" short-description="Create an GlAccount">
        <make-value entity-name="GlAccount" value-name="newEntity"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>

        <!-- GlAccount uses a sequenced id, so get the next one now and set it... -->
        <if-empty field-name="parameters.glAccountId">
            <sequenced-id-to-env sequence-name="GlAccount" env-name="newEntity.glAccountId"/>
        <else>
            <set-pk-fields map-name="parameters" value-name="newEntity"/>
        </else>
        </if-empty>
        <field-to-result field-name="newEntity.glAccountId" result-name="glAccountId"/>
        
        <create-value value-name="newEntity"/>
    </simple-method>
    <simple-method method-name="updateGlAccount" short-description="Update an GlAccount">
        <make-value entity-name="GlAccount" value-name="lookupPKMap"/>
        <set-pk-fields map-name="parameters" value-name="lookupPKMap"/>
        <find-by-primary-key map-name="lookupPKMap" value-name="lookedUpValue"/>
        <set-nonpk-fields map-name="parameters" value-name="lookedUpValue"/>
        <store-value value-name="lookedUpValue"/>
    </simple-method>
    <simple-method method-name="deleteGlAccount" short-description="Delete an GlAccount">
        <make-value entity-name="GlAccount" value-name="lookupPKMap"/>
        <set-pk-fields map-name="parameters" value-name="lookupPKMap"/>
        <find-by-primary-key map-name="lookupPKMap" value-name="lookedUpValue"/>
        <remove-value value-name="lookedUpValue"/>
    </simple-method>
    
    <!-- ========= GlAccountOrganization methods ========= -->
    <simple-method method-name="createGlAccountOrganization" short-description="Create GlAccountOrganization">
        <make-value entity-name="GlAccountOrganization" value-name="newEntity"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>
        <set-pk-fields map-name="parameters" value-name="newEntity"/>

        <create-value value-name="newEntity"/>
    </simple-method>
    <simple-method method-name="updateGlAccountOrganization" short-description="Update GlAccountOrganization">
        <make-value entity-name="GlAccountOrganization" value-name="lookupPKMap"/>
        <set-pk-fields map-name="parameters" value-name="lookupPKMap"/>
        <find-by-primary-key map-name="lookupPKMap" value-name="lookedUpValue"/>
        <set-nonpk-fields map-name="parameters" value-name="lookedUpValue"/>
       
        <store-value value-name="lookedUpValue"/>
    </simple-method>
    <simple-method method-name="deleteGlAccountOrganization" short-description="Delete GlAccountOrganization">
        <make-value entity-name="GlAccountOrganization" value-name="lookupPKMap"/>
        <set-pk-fields map-name="parameters" value-name="lookupPKMap"/>
        <find-by-primary-key map-name="lookupPKMap" value-name="lookedUpValue"/>
        <remove-value value-name="lookedUpValue"/>
    </simple-method>

    <!-- ========= GlJournal methods ========= -->
    <simple-method method-name="quickCreateAcctgTransAndEntries" short-description="Creates an AcctgTrans and two offsetting AcctgTransEntry records">
        <!-- TODO: Do we need to create a GlJournal record here? -->
    
        <!-- first, create the AcctgTrans -->
        <set-service-fields service-name="createAcctgTrans" to-map-name="createAcctgTransParams" map-name="parameters"/>
        <now-timestamp-to-env env-name="createAcctgTransParams.transactionDate"/>
        <call-service service-name="createAcctgTrans" in-map-name="createAcctgTransParams">
            <result-to-field result-name="acctgTransId"/>
        </call-service>

        <!-- TODO: if someday there are more than one type of acctgTransEntryTypeId (other than _NA_, we should get rid of the lines below
            that fix those values -->
        <!-- now, create the debit AcctgTransEntry -->
        <set-service-fields service-name="createAcctgTransEntry" map-name="parameters" to-map-name="createAcctgTransEntryParams"/>
        <set field="createAcctgTransEntryParams.acctgTransId" from-field="acctgTransId"/>
        <set field="createAcctgTransEntryParams.glAccountId" from-field="parameters.debitGlAccountId"/>
        <set field="createAcctgTransEntryParams.debitCreditFlag" value="D"/>
        <set field="createAcctgTransEntryParams.acctgTransEntryTypeId" value="_NA_"/>
        <call-service service-name="createAcctgTransEntry" in-map-name="createAcctgTransEntryParams"/>
        
        <!-- now the credit AcctgTransEntry -->
        <set-service-fields service-name="createAcctgTransEntry" map-name="parameters" to-map-name="createAcctgTransEntryParams"/>
        <set field="createAcctgTransEntryParams.acctgTransId" from-field="acctgTransId"/>
        <set field="createAcctgTransEntryParams.glAccountId" from-field="parameters.creditGlAccountId"/>
        <set field="createAcctgTransEntryParams.debitCreditFlag" value="C"/>
        <set field="createAcctgTransEntryParams.acctgTransEntryTypeId" value="_NA_"/>
        <call-service service-name="createAcctgTransEntry" in-map-name="createAcctgTransEntryParams"/>
        
        <field-to-result field-name="acctgTransId" result-name="acctgTransId"/>
    </simple-method> 
       
    <simple-method method-name="createGlJournal" short-description="Create an GlJournal">
        <make-value entity-name="GlJournal" value-name="newEntity"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>

        <!-- GlJournal uses a sequenced id, so get the next one now and set it... -->        
        <sequenced-id-to-env sequence-name="GlJournal" env-name="newEntity.glJournalId"/>
        <field-to-result field-name="newEntity.glJournalId" result-name="glJournalId"/>

        <create-value value-name="newEntity"/>
    </simple-method>
    <simple-method method-name="updateGlJournal" short-description="Update an GlJournal">
        <entity-one entity-name="GlJournal" value-name="lookedUpValue"/>
        <set-nonpk-fields map-name="parameters" value-name="lookedUpValue"/>
        <store-value value-name="lookedUpValue"/>
    </simple-method>
    <simple-method method-name="deleteGlJournal" short-description="Delete an GlJournal">
        <entity-one entity-name="GlJournal" value-name="lookedUpValue"/>
        <remove-value value-name="lookedUpValue"/>
    </simple-method>
        
    <!-- GlJournal Trial Balance and Post routines -->
    <simple-method method-name="calculateGlJournalTrialBalance" short-description="Calculate Trial Balance for a GlJournal">
        <check-permission permission="ACCOUNTING" action="_VIEW"><fail-message message="Security Error: to run calculateGlJournalTrialBalance you must have the ACCOUNTING_UPDATE or ACCOUNTING_ADMIN permission"/></check-permission>
        <check-errors/>

        <!-- iterate through all AcctgTrans in this journal and that are not yet posted, and get totals of all debits and of all credits -->
        <entity-condition entity-name="AcctgTrans" list-name="acctgTransList">
            <condition-list combine="and">
                <condition-expr field-name="glJournalId" env-name="parameters.glJournalId"/>
                <condition-expr field-name="isPosted" operator="not-equals" value="Y"/>
            </condition-list>
        </entity-condition>
        
        <iterate entry-name="acctgTrans" list-name="acctgTransList">
            <clear-field field-name="callServiceMap"/>
            <clear-field field-name="serviceResults"/>
            <set from-field="acctgTrans.acctgTransId" field="callServiceMap.acctgTransId"/>
            <call-service service-name="calculateAcctgTransTrialBalance" in-map-name="callServiceMap">
                <results-to-map map-name="serviceResults"/>
            </call-service>
            <calculate field-name="debitTotal" type="Double">
                <calcop operator="get" field-name="debitTotal"/>
                <calcop operator="get" field-name="serviceResults.debitTotal"/>
            </calculate>
            <calculate field-name="creditTotal" type="Double">
                <calcop operator="get" field-name="creditTotal"/>
                <calcop operator="get" field-name="serviceResults.creditTotal"/>
            </calculate>
            <calculate field-name="debitCreditDifference" type="Double">
                <calcop operator="get" field-name="debitCreditDifference"/>
                <calcop operator="get" field-name="serviceResults.debitCreditDifference"/>
            </calculate>
        </iterate>
        
        <field-to-result field-name="debitTotal"/>
        <field-to-result field-name="creditTotal"/>
        <field-to-result field-name="debitCreditDifference"/>
    </simple-method>

    <simple-method method-name="postGlJournal" short-description="Post a GlJournal">
        <check-permission permission="ACCOUNTING" action="_UPDATE"><fail-message message="Security Error: to run postGlJournal you must have the ACCOUNTING_UPDATE or ACCOUNTING_ADMIN permission"/></check-permission>
        <check-errors/>
        <!-- first calculate the trial balance for the journal and make sure debits and credits match -->
        <set from-field="parameters.glJournalId" field="trialBalanceCallMap.glJournalId"/>
        <call-service service-name="calculateGlJournalTrialBalance" in-map-name="trialBalanceCallMap">
            <results-to-map map-name="trialBalanceResultMap"/>
        </call-service>
        
        <if-compare field-name="trialBalanceResultMap.debitCreditDifference" operator="not-equals" value="0" type="Double">
            <add-error><fail-message message="Not posting GL Journal with ID [${parameters.glJournalId}] because the trial balance failed: Debit Total=${trialBalanceResultMap.debitTotal} Credit Total=${trialBalanceResultMap.creditTotal} Debit/Credit Difference=${trialBalanceResultMap.debitCreditDifference}"/></add-error>
            <check-errors/>
        </if-compare>
        
        <!-- iterate through all AcctgTrans in this journal and that are not yet posted, and post each one -->
        <entity-condition entity-name="AcctgTrans" list-name="acctgTransList">
            <condition-list combine="and">
                <condition-expr field-name="glJournalId" env-name="parameters.glJournalId"/>
                <condition-expr field-name="isPosted" operator="not-equals" value="Y"/>
            </condition-list>
        </entity-condition>
        <iterate entry-name="acctgTrans" list-name="acctgTransList">
            <clear-field field-name="callServiceMap"/>
            <set from-field="acctgTrans.acctgTransId" field="callServiceMap.acctgTransId"/>
            <call-service service-name="postAcctgTrans" in-map-name="callServiceMap"/>
        </iterate>
    </simple-method>

    <!-- ========= GlReconciliation methods ========= -->
    <simple-method method-name="createGlReconciliation" short-description="Create an GlReconciliation">
        <make-value entity-name="GlReconciliation" value-name="newEntity"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>

        <!-- GlReconciliation uses a sequenced id, so get the next one now and set it... -->        
        <sequenced-id-to-env sequence-name="GlReconciliation" env-name="newEntity.glReconciliationId"/>
        <field-to-result field-name="newEntity.glReconciliationId" result-name="glReconciliationId"/>
        
        <set from-field="userLogin.userLoginId" field="newEntity.lastModifiedByUserLogin"/>
        <set from-field="userLogin.userLoginId" field="newEntity.createdByUserLogin"/>
        
        <create-value value-name="newEntity"/>
    </simple-method>
    <simple-method method-name="updateGlReconciliation" short-description="Update an GlReconciliation">
        <entity-one entity-name="GlReconciliation" value-name="lookedUpValue"/>
        <set-nonpk-fields map-name="parameters" value-name="lookedUpValue"/>
        
        <set from-field="userLogin.userLoginId" field="lookedUpValue.lastModifiedByUserLogin"/>
        <store-value value-name="lookedUpValue"/>
    </simple-method>
    <simple-method method-name="deleteGlReconciliation" short-description="Delete an GlReconciliation">
        <entity-one entity-name="GlReconciliation" value-name="lookedUpValue"/>
        <remove-value value-name="lookedUpValue"/>
    </simple-method>
    <simple-method method-name="updateGlReconciliationLastModified" short-description="Update GlReconciliation LastModified Info">
        <!-- this is just a little method that is meant to be called as an inline call-simple-method target with the context already setup -->
        <entity-one entity-name="GlReconciliation" value-name="lookedUpGLR"/>
        <set from-field="userLogin.userLoginId" field="lookedUpGLR.lastModifiedByUserLogin"/>
        <store-value value-name="lookedUpGLR"/>
    </simple-method>
    
    <!-- ========= GlReconciliationEntry methods ========= -->
    <simple-method method-name="createGlReconciliationEntry" short-description="Add Entry To GlReconciliation">
        <make-value entity-name="GlReconciliationEntry" value-name="newEntity"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>
        <set-pk-fields map-name="parameters" value-name="newEntity"/>
        <create-value value-name="newEntity"/>

        <!-- when changing entries, also update the last modified info for the GlReconciliation -->
        <call-simple-method method-name="updateGlReconciliationLastModified"/>
    </simple-method>
    <simple-method method-name="updateGlReconciliationEntry" short-description="Update Entry To GlReconciliation">
        <entity-one entity-name="GlReconciliationEntry" value-name="lookedUpValue"/>
        <set-nonpk-fields map-name="parameters" value-name="lookedUpValue"/>
        <store-value value-name="lookedUpValue"/>
        
        <!-- when changing entries, also update the last modified info for the GlReconciliation -->
        <call-simple-method method-name="updateGlReconciliationLastModified"/>
    </simple-method>
    <simple-method method-name="deleteGlReconciliationEntry" short-description="Remove Entry From GlReconciliation">
        <entity-one entity-name="GlReconciliationEntry" value-name="lookedUpValue"/>
        <remove-value value-name="lookedUpValue"/>

        <!-- when changing entries, also update the last modified info for the GlReconciliation -->
        <call-simple-method method-name="updateGlReconciliationLastModified"/>
    </simple-method>

    <!-- ========== GL Posting Services ========== -->
    <simple-method method-name="createAcctgTransAndEntries" short-description="Verifies and posts a set of AcctgTransEntries">
        <!-- retrieve ledger rounding properties -->
        <property-to-field resource="arithmetic" property="ledger.decimals" field-name="ledgerDecimals"/>
        <property-to-field resource="arithmetic" property="ledger.rounding" field-name="roundingMode"/>
        <log level="info" message="Using ledger decimals [${ledgerDecimals}] and rounding [${roundingMode}]"/>

        <!-- first loop through and make sure all the entries are valid  -->
        <iterate list-name="parameters.acctgTransEntries" entry-name="acctgTransEntry">
            <!-- the organization party must be an internal organization -->
            <entity-one entity-name="PartyRole" value-name="partyRole" use-cache="true" auto-field-map="false">
                <field-map field-name="partyId" env-name="acctgTransEntry.organizationPartyId"/>
                <field-map field-name="roleTypeId" value="INTERNAL_ORGANIZATIO"/>
            </entity-one>
            <if-empty field-name="partyRole">
                <log level="warning" message="The party with id [${acctgTransEntry.organizationPartyId}] is not an internal organization; the following accounting transaction will be ignored: ${acctgTransEntry}"/>
            <else>
                <!-- if the amount field is empty, then determine it from the origAmount and origCurrencyUomId fields:
                     if origCurrencyUomId is different from the base currency of the organization, then the amount value will be converted -->
                <if-empty field-name="acctgTransEntry.amount">
                    <if-not-empty field-name="acctgTransEntry.origAmount">
                        <entity-one entity-name="PartyAcctgPreference" value-name="partyAcctgPreference" use-cache="true" auto-field-map="false">
                            <field-map field-name="partyId" env-name="acctgTransEntry.organizationPartyId"/>
                        </entity-one>
                        <if-empty field-name="acctgTransEntry.origCurrencyUomId">
                            <set field="acctgTransEntry.origCurrencyUomId" from-field="partyAcctgPreference.baseCurrencyUomId"/>
                        </if-empty>
                        <set field="acctgTransEntry.currencyUomId" from-field="partyAcctgPreference.baseCurrencyUomId"/>
                        <if-compare-field field-name="acctgTransEntry.origCurrencyUomId" operator="not-equals" to-field-name="acctgTransEntry.currencyUomId">
                            <clear-field field-name="convertUomInMap"/>
                            <set field="convertUomInMap.originalValue" from-field="acctgTransEntry.origAmount"/>
                            <set field="convertUomInMap.uomId" from-field="acctgTransEntry.origCurrencyUomId"/>
                            <set field="convertUomInMap.uomIdTo" from-field="acctgTransEntry.currencyUomId"/>
                            <!-- TODO: set the optional asOfDate input parameter -->
                            <call-service service-name="convertUom" in-map-name="convertUomInMap">
                                <result-to-field result-name="convertedValue" field-name="acctgTransEntry.amount"/>
                            </call-service>
                        <else>
                            <set field="acctgTransEntry.amount" from-field="acctgTransEntry.origAmount"/>
                        </else>
                        </if-compare-field>
                    </if-not-empty>
                </if-empty>
                <!-- if the glAccountId is empty, but we have a glAccountTypeId, then we will determine the
                     correct glAccountId from the gl setup settings -->
                <if-empty field-name="acctgTransEntry.glAccountId">
                    <if-not-empty field-name="acctgTransEntry.glAccountTypeId">
                        <clear-field field-name="getGlAccountFromAccountTypeInMap"/>
                        <!-- if this is an inventory variance pass the glAccountTypeId as the varianceReasonId, it will be used to lookup the account id in the VarianceReasonGlAccount entity -->
                        <if-compare field-name="parameters.acctgTransTypeId" operator="equals" value="ITEM_VARIANCE_ACCTG_">
                            <set field="getGlAccountFromAccountTypeInMap.varianceReasonId" from-field="acctgTransEntry.glAccountTypeId"/>
                        </if-compare>
                        <if-not-empty field-name="acctgTransEntry.productId">
                            <set field="getGlAccountFromAccountTypeInMap.productId" from-field="acctgTransEntry.productId"/>
                        </if-not-empty>
                        <set field="getGlAccountFromAccountTypeInMap.glAccountTypeId" from-field="acctgTransEntry.glAccountTypeId"/>
                        <set field="getGlAccountFromAccountTypeInMap.organizationPartyId" from-field="acctgTransEntry.organizationPartyId"/>
                        <call-service service-name="getGlAccountFromAccountType" in-map-name="getGlAccountFromAccountTypeInMap">
                            <result-to-field result-name="glAccountId" field-name="acctgTransEntry.glAccountId"/>
                        </call-service>
                    </if-not-empty>
                </if-empty>
                <if-empty field-name="acctgTransEntry.origAmount">
                    <set field="acctgTransEntry.origAmount" from-field="acctgTransEntry.amount"/>
                </if-empty>
                <set field="normalizedAcctgTransEntries[]" from-field="acctgTransEntry"/>
            </else>
            </if-empty>
        </iterate>

        <if-not-empty field-name="normalizedAcctgTransEntries">
            <!-- now do the posting. First, create the AcctgTrans entity -->
            <set-service-fields service-name="createAcctgTrans" map-name="parameters" to-map-name="createAcctgTransParams"/>
            <if-empty field-name="createAcctgTransParams.transactionDate">
                <now-timestamp-to-env env-name="createAcctgTransParams.transactionDate"/>
            </if-empty>
            <call-service service-name="createAcctgTrans" in-map-name="createAcctgTransParams">
                <result-to-field result-name="acctgTransId"/>
            </call-service>

            <!-- Next, create the AcctgTransEntry entities one by one -->
            <iterate list-name="normalizedAcctgTransEntries" entry-name="acctgTransEntry">
                <!-- if any amount is negative, then get the absolute (positive) value of that amount, and flip the Debit/Credit flag  -->
                <if-compare field-name="acctgTransEntry.origAmount" operator="less" value="0">
                    <log level="verbose" message="${acctgTransEntry} is going to get inverted"/>
                    <calculate field-name="acctgTransEntry.origAmount">
                        <calcop field-name="acctgTransEntry.origAmount" operator="negative"/>
                    </calculate>
                    <calculate field-name="acctgTransEntry.amount">
                        <calcop field-name="acctgTransEntry.amount" operator="negative"/>
                    </calculate>
                    <if-compare field-name="acctgTransEntry.debitCreditFlag" operator="equals" value="D">
                        <set value="C" field="acctgTransEntry.debitCreditFlag"/>
                    <else>
                        <if-compare field-name="acctgTransEntry.debitCreditFlag" operator="equals" value="C">
                            <set value="D" field="acctgTransEntry.debitCreditFlag"/>
                        </if-compare>
                    </else>
                    </if-compare>
                </if-compare>

                <!-- now create the AcctgTransEntry using the acctgTransId we already have from above -->
                <clear-field field-name="createAcctgTransEntryParams"/>
                <set-service-fields service-name="createAcctgTransEntry" map-name="acctgTransEntry" to-map-name="createAcctgTransEntryParams"/>
                <set from-field="acctgTransId" field="createAcctgTransEntryParams.acctgTransId"/>
                <call-service service-name="createAcctgTransEntry" in-map-name="createAcctgTransEntryParams"/>
            </iterate>
        <else>
            <log level="warning" message="Cannot process an accounting transactions with empty list of entries."/>
        </else>
        </if-not-empty>
        
        <!-- all done -->
        <field-to-result field-name="acctgTransId"/>
    </simple-method>

    <!-- Miscellaneous services for product and inventory -->

    <simple-method method-name="getGlAccountFromAccountType" short-description="Look up a GlAccountId from GlAccountTypeId"> 
        <if-not-empty field-name="parameters.varianceReasonId">
            <entity-one entity-name="VarianceReasonGlAccount" value-name="varianceReasonGlAccount">
                <field-map field-name="organizationPartyId" env-name="parameters.organizationPartyId"/>
                <field-map field-name="varianceReasonId" env-name="parameters.varianceReasonId"/>
            </entity-one>
            <if-not-empty field-name="varianceReasonGlAccount.glAccountId">
                <field-to-result field-name="varianceReasonGlAccount.glAccountId" result-name="glAccountId"/>
            </if-not-empty>
            <return/>
        </if-not-empty>
        <if-not-empty field-name="parameters.productId">
            <entity-one entity-name="ProductGlAccount" value-name="lookedUpValue" use-cache="true"/>
            <!-- if nothing found look if the parameters.productId is member of any ProductCategory in ProductCategoryGlAccount --> 
            <if-empty field-name="lookedUpValue.glAccountId">
                <entity-and entity-name="ProductCategoryMember" list-name="productCategoryMembers" filter-by-date="true">
                    <field-map field-name="productId" env-name="parameters.productId"/>
                    <order-by field-name="-fromDate"/>
                </entity-and>
                <iterate list-name="productCategoryMembers" entry-name="productCategoryMember">
                    <entity-one entity-name="ProductCategoryGlAccount" value-name="productCategoryGlAccount">
                        <field-map field-name="productCategoryId" env-name="productCategoryMember.productCategoryId"/>
                        <field-map field-name="glAccountTypeId" env-name="parameters.glAccountTypeId"/>
                        <field-map field-name="organizationPartyId" env-name="parameters.organizationPartyId"/>
                    </entity-one>
                    <if-not-empty field-name="productCategoryGlAccount.glAccountId">
                        <field-to-result field-name="productCategoryGlAccount.glAccountId" result-name="glAccountId"/>
                        <return/>
                    </if-not-empty>
                </iterate>
            </if-empty>
        </if-not-empty>

        <!-- if nothing found or if no such parameters were passed (lookedUpValue empty in both cases), try GlAccountTypeDefault -->
        <if-empty field-name="lookedUpValue.glAccountId">
            <entity-one entity-name="GlAccountTypeDefault" value-name="lookedUpValue" use-cache="true"/> 
        </if-empty>
        <field-to-result field-name="lookedUpValue.glAccountId" result-name="glAccountId"/> 
    </simple-method>

    <simple-method method-name="getInventoryItemOwner" short-description="Get an ownerPartyId from inventoryItemId">
        <entity-one entity-name="InventoryItem" value-name="inventoryItem"/>
        <if-empty field-name="inventoryItem.ownerPartyId">
            <get-related-one value-name="inventoryItem" relation-name="Facility" to-value-name="facility"/>
            <field-to-result field-name="facility.ownerPartyId" result-name="ownerPartyId"/>
        <else>
            <field-to-result field-name="inventoryItem.ownerPartyId" result-name="ownerPartyId"/>
        </else>
        </if-empty>
    </simple-method>

    <!-- Services for the automatic creation of accounting transactions based on business transactions
         Typically, these services are triggered by SECAs -->

    <simple-method method-name="createAcctgTransForSalesShipmentIssuance" short-description="Create an accounting transactions for a sales shipment issuance (D: INVENTORY_ACCOUNT, C: COGS_ACCOUNT)">
        <!-- retrieve ledger rounding properties -->
        <property-to-field resource="arithmetic" property="ledger.decimals" field-name="ledgerDecimals"/>
        <property-to-field resource="arithmetic" property="ledger.rounding" field-name="roundingMode"/>
        <log level="info" message="Using ledger decimals [${ledgerDecimals}] and rounding [${roundingMode}]"/>

        <entity-one entity-name="ItemIssuance" value-name="itemIssuance"/>
        <get-related-one value-name="itemIssuance" relation-name="InventoryItem" to-value-name="inventoryItem"/>
        <entity-and entity-name="OrderRole" list-name="billToCustomers">
            <field-map field-name="orderId" env-name="itemIssuance.orderId"/>
            <field-map field-name="roleTypeId" value="BILL_TO_CUSTOMER"/>
        </entity-and>
        <first-from-list list-name="billToCustomers" entry-name="billToCustomer"/>
        <!-- TODO: handle serialized inventory -->
        <calculate field-name="origAmount" type="BigDecimal" decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
            <calcop operator="multiply">
                <calcop operator="get" field-name="itemIssuance.quantity"/>
                <calcop operator="get" field-name="inventoryItem.unitCost"/>
            </calcop>
        </calculate>
        <!-- prepare the doble posting (D/C) entries (AcctgTransEntry) -->
        <!-- Credit -->
        <make-value entity-name="AcctgTransEntry" value-name="creditEntry"/>
        <set field="creditEntry.debitCreditFlag" value="C"/>
        <set field="creditEntry.glAccountTypeId" value="INVENTORY_ACCOUNT"/>
        <set field="creditEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
        <set field="creditEntry.productId" from-field="inventoryItem.productId"/>
        <set field="creditEntry.origAmount" from-field="origAmount"/>
        <set field="creditEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
        <if-not-empty field-name="billToCustomer">
            <set field="creditEntry.partyId" from-field="billToCustomer.partyId"/>
            <set field="creditEntry.roleTypeId" from-field="billToCustomer.roleTypeId"/>
        </if-not-empty>
        <set field="acctgTransEntries[]" from-field="creditEntry" type="Object"/>
        <!-- Debit -->
        <make-value entity-name="AcctgTransEntry" value-name="debitEntry"/>
        <set field="debitEntry.debitCreditFlag" value="D"/>
        <set field="debitEntry.glAccountTypeId" value="COGS_ACCOUNT"/>
        <set field="debitEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
        <set field="debitEntry.productId" from-field="inventoryItem.productId"/>
        <set field="debitEntry.origAmount" from-field="origAmount"/>
        <set field="debitEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
        <if-not-empty field-name="billToCustomer">
            <set field="debitEntry.partyId" from-field="billToCustomer.partyId"/>
            <set field="debitEntry.roleTypeId" from-field="billToCustomer.roleTypeId"/>
        </if-not-empty>
        <set field="acctgTransEntries[]" from-field="debitEntry" type="Object"/>
        <!-- Set header fields (AcctgTrans) -->
        <set field="createAcctgTransAndEntriesInMap.glFiscalTypeId" value="ACTUAL"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransTypeId" value="SALES_SHIPMENT"/>
        <set field="createAcctgTransAndEntriesInMap.shipmentId" from-field="itemIssuance.shipmentId"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransEntries" from-field="acctgTransEntries"/>
        <call-service service-name="createAcctgTransAndEntries" in-map-name="createAcctgTransAndEntriesInMap">
            <result-to-field result-name="acctgTransId"/>
        </call-service>
        <field-to-result field-name="acctgTransId" result-name="acctgTransId"/>        
    </simple-method>

    <simple-method method-name="createAcctgTransForShipmentReceipt" short-description="Create an accounting transactions for a shipment receipt (D: INVENTORY_ACCOUNT, C: UNINVOICED_SHIP_RCPT or COGS_ACCOUNT for returns)">
        <!-- retrieve ledger rounding properties -->
        <property-to-field resource="arithmetic" property="ledger.decimals" field-name="ledgerDecimals"/>
        <property-to-field resource="arithmetic" property="ledger.rounding" field-name="roundingMode"/>
        <log level="info" message="Using ledger decimals [${ledgerDecimals}] and rounding [${roundingMode}]"/>

        <entity-one entity-name="ShipmentReceipt" value-name="shipmentReceipt"/>
        <get-related-one value-name="shipmentReceipt" relation-name="InventoryItem" to-value-name="inventoryItem"/>
        <get-related-one value-name="shipmentReceipt" relation-name="Shipment" to-value-name="shipment"/>
        <if-not-empty field-name="shipmentReceipt.returnId">
            <set field="creditAccountTypeId" value="COGS_ACCOUNT"/>
        <else>
            <set field="creditAccountTypeId" value="UNINVOICED_SHIP_RCPT"/>
        </else>
        </if-not-empty>
        <!-- TODO: handle serialized inventory -->
        <calculate field-name="origAmount" type="BigDecimal" decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
            <calcop operator="multiply">
                <calcop operator="get" field-name="shipmentReceipt.quantityAccepted"/>
                <calcop operator="get" field-name="inventoryItem.unitCost"/>
            </calcop>
        </calculate>
        <!-- prepare the doble posting (D/C) entries (AcctgTransEntry) -->
        <!-- Credit -->
        <make-value entity-name="AcctgTransEntry" value-name="creditEntry"/>
        <set field="creditEntry.debitCreditFlag" value="C"/>
        <set field="creditEntry.glAccountTypeId" from-field="creditAccountTypeId"/>
        <set field="creditEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
        <set field="creditEntry.partyId" from-field="shipment.partyIdFrom"/>
        <set field="creditEntry.roleTypeId" value="BILL_FROM_VENDOR"/>
        <set field="creditEntry.productId" from-field="inventoryItem.productId"/>
        <set field="creditEntry.origAmount" from-field="origAmount"/>
        <set field="creditEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
        <set field="acctgTransEntries[]" from-field="creditEntry" type="Object"/>
        <!-- Debit -->
        <make-value entity-name="AcctgTransEntry" value-name="debitEntry"/>
        <set field="debitEntry.debitCreditFlag" value="D"/>
        <set field="debitEntry.glAccountTypeId" value="INVENTORY_ACCOUNT"/>
        <set field="debitEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
        <set field="debitEntry.partyId" from-field="shipment.partyIdFrom"/>
        <set field="debitEntry.roleTypeId" value="BILL_FROM_VENDOR"/>
        <set field="debitEntry.productId" from-field="inventoryItem.productId"/>
        <set field="debitEntry.origAmount" from-field="origAmount"/>
        <set field="debitEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
        <set field="acctgTransEntries[]" from-field="debitEntry" type="Object"/>
        <!-- Set header fields (AcctgTrans) -->
        <set field="createAcctgTransAndEntriesInMap.glFiscalTypeId" value="ACTUAL"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransTypeId" value="SHIPMENT_RECEIPT"/>
        <set field="createAcctgTransAndEntriesInMap.shipmentId" from-field="shipmentReceipt.shipmentId"/>
        <set field="createAcctgTransAndEntriesInMap.partyId" from-field="shipment.partyIdFrom"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransEntries" from-field="acctgTransEntries"/>
        <call-service service-name="createAcctgTransAndEntries" in-map-name="createAcctgTransAndEntriesInMap">
            <result-to-field result-name="acctgTransId"/>
        </call-service>
        <field-to-result field-name="acctgTransId" result-name="acctgTransId"/>        
    </simple-method>

    <!-- DEPRECATED: use createAcctgTransForSalesShipmentIssuance instead -->
    <simple-method method-name="createAcctgTransForSalesShipment" short-description="Create accounting transactions for issuances for a sales shipment (D: INVENTORY_ACCOUNT, C: COGS_ACCOUNT)">
        <!-- retrieve ledger rounding properties -->
        <property-to-field resource="arithmetic" property="ledger.decimals" field-name="ledgerDecimals"/>
        <property-to-field resource="arithmetic" property="ledger.rounding" field-name="roundingMode"/>
        <log level="info" message="Using ledger decimals [${ledgerDecimals}] and rounding [${roundingMode}]"/>

        <entity-and entity-name="ItemIssuance" list-name="itemIssuances">
            <field-map field-name="shipmentId" env-name="parameters.shipmentId"/>
        </entity-and>
        <iterate list-name="itemIssuances" entry-name="itemIssuance">
            <get-related-one value-name="itemIssuance" relation-name="InventoryItem" to-value-name="inventoryItem"/>
            <entity-and entity-name="OrderRole" list-name="billToCustomers">
                <field-map field-name="orderId" env-name="itemIssuance.orderId"/>
                <field-map field-name="roleTypeId" value="BILL_TO_CUSTOMER"/>
            </entity-and>
            <first-from-list list-name="billToCustomers" entry-name="billToCustomer"/>
            <!-- TODO: handle serialized inventory -->
            <calculate field-name="origAmount" type="BigDecimal" decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
                <calcop operator="multiply">
                    <calcop operator="get" field-name="itemIssuance.quantity"/>
                    <calcop operator="get" field-name="inventoryItem.unitCost"/>
                </calcop>
            </calculate>
            <!-- Credit -->
            <make-value entity-name="AcctgTransEntry" value-name="creditEntry"/>
            <set field="creditEntry.debitCreditFlag" value="C"/>
            <set field="creditEntry.glAccountTypeId" value="INVENTORY_ACCOUNT"/>
            <set field="creditEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
            <set field="creditEntry.productId" from-field="inventoryItem.productId"/>
            <set field="creditEntry.origAmount" from-field="origAmount"/>
            <set field="creditEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
            <if-not-empty field-name="billToCustomer">
                <set field="creditEntry.partyId" from-field="billToCustomer.partyId"/>
                <set field="creditEntry.roleTypeId" from-field="billToCustomer.roleTypeId"/>
            </if-not-empty>
            <!-- Debit -->
            <make-value entity-name="AcctgTransEntry" value-name="debitEntry"/>
            <set field="debitEntry.debitCreditFlag" value="D"/>
            <set field="debitEntry.glAccountTypeId" value="COGS_ACCOUNT"/>
            <set field="debitEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
            <set field="debitEntry.productId" from-field="inventoryItem.productId"/>
            <set field="debitEntry.origAmount" from-field="origAmount"/>
            <set field="debitEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
            <if-not-empty field-name="billToCustomer">
                <set field="debitEntry.partyId" from-field="billToCustomer.partyId"/>
                <set field="debitEntry.roleTypeId" from-field="billToCustomer.roleTypeId"/>
            </if-not-empty>
            <set field="acctgTransEntries[]" from-field="creditEntry" type="Object"/>
            <set field="acctgTransEntries[]" from-field="debitEntry" type="Object"/>
        </iterate>
        <set field="createAcctgTransAndEntriesInMap.glFiscalTypeId" value="ACTUAL"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransTypeId" value="SALES_SHIPMENT"/>
        <set field="createAcctgTransAndEntriesInMap.shipmentId" from-field="parameters.shipmentId"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransEntries" from-field="acctgTransEntries"/>
        <call-service service-name="createAcctgTransAndEntries" in-map-name="createAcctgTransAndEntriesInMap">
            <result-to-field result-name="acctgTransId"/>
        </call-service>
        <field-to-result field-name="acctgTransId" result-name="acctgTransId"/>        
    </simple-method>
    
    <simple-method method-name="createAcctgTransForInventoryItemCostChange" short-description="Create accounting transaction when item cost is changed (D: INV_ADJ_VAL, C: INVENTORY_ACCOUNT)">
        <!-- retrieve ledger rounding properties -->        
        <property-to-field resource="arithmetic" property="ledger.decimals" field-name="ledgerDecimals"/>
        <property-to-field resource="arithmetic" property="ledger.rounding" field-name="roundingMode"/>
        <entity-one entity-name="InventoryItemDetail" value-name="newInventoryItemDetail"/>
        <entity-condition entity-name="InventoryItemDetail" list-name="inventoryItemDetails">
            <condition-list>
                <condition-expr field-name="unitCost" operator="not-equals" value="0.00"/>
                <condition-expr field-name="inventoryItemDetailSeqId" operator="not-equals" env-name="parameters.inventoryItemDetailSeqId"/>
            </condition-list>
            <order-by field-name="-effectiveDate"/>
        </entity-condition>
        <first-from-list list-name="inventoryItemDetails" entry-name="oldInventoryItemDetail"/>
        <if-not-empty field-name="oldInventoryItemDetail">
            <calculate field-name="origAmount" type="BigDecimal" decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
                <calcop operator="multiply" field-name="newinventoryItem.quantityOnHandTotal">
                    <calcop operator="subtract">
                        <calcop operator="get" field-name="oldInventoryItemDetail.unitCost"/>
                        <calcop operator="get" field-name="newInventoryItemDetail.unitCost"/>
                    </calcop>
                </calcop>
            </calculate>
        </if-not-empty>
        <get-related-one value-name="newInventoryItemDetail" relation-name="InventoryItem" to-value-name="inventoryItem"/>
        <!-- Credit -->
        <make-value entity-name="AcctgTransEntry" value-name="creditEntry"/>
        <set field="creditEntry.debitCreditFlag" value="C"/>
        <set field="creditEntry.glAccountTypeId" value="INVENTORY_ACCOUNT"/>
        <set field="creditEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
        <set field="creditEntry.productId" from-field="inventoryItem.productId"/>
        <set field="creditEntry.origAmount" from-field="origAmount"/>
        <set field="creditEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
        <!-- Debit -->
        <make-value entity-name="AcctgTransEntry" value-name="debitEntry"/>
        <set field="debitEntry.debitCreditFlag" value="D"/>
        <set field="debitEntry.glAccountTypeId" value="INV_ADJ_VAL"/>
        <set field="debitEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
        <set field="debitEntry.productId" from-field="inventoryItem.productId"/>
        <set field="debitEntry.origAmount" from-field="origAmount"/>
        <set field="debitEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>

        <set field="acctgTransEntries[]" from-field="creditEntry" type="Object"/>
        <set field="acctgTransEntries[]" from-field="debitEntry" type="Object"/>
      
        <set field="createAcctgTransAndEntriesInMap.glFiscalTypeId" value="ACTUAL"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransTypeId" value="INVENTORY"/>
        <set field="createAcctgTransAndEntriesInMap.shipmentId" from-field="parameters.InventoryItemId"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransEntries" from-field="acctgTransEntries"/>
        <call-service service-name="createAcctgTransAndEntries" in-map-name="createAcctgTransAndEntriesInMap">
            <result-to-field result-name="acctgTransId"/>
        </call-service>
        <field-to-result field-name="acctgTransId" result-name="acctgTransId"/>
    </simple-method>

    <simple-method method-name="createAcctgTransForPhysicalInventoryVariance" short-description="Create an Account Transaction For Physical Inventory Variance">
        <!-- retrieve ledger rounding properties -->  
        <property-to-field resource="arithmetic" property="ledger.decimals" field-name="ledgerDecimals"/>
        <property-to-field resource="arithmetic" property="ledger.rounding" field-name="roundingMode"/>
        <entity-and entity-name="InventoryItemDetail" list-name="inventoryItemDetails">
            <field-map field-name="physicalInventoryId" env-name="parameters.physicalInventoryId"/>
            <order-by field-name="inventoryItemId"/>
        </entity-and>
        <iterate list-name="inventoryItemDetails" entry-name="inventoryItemDetail">
            <get-related-one value-name="inventoryItemDetail" relation-name="InventoryItem" to-value-name="inventoryItem"/>        
            <calculate field-name="origAmount" type="BigDecimal" decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
                <calcop operator="multiply">
                    <calcop operator="get" field-name="inventoryItemDetail.quantityOnHandDiff"/>
                    <calcop operator="get" field-name="inventoryItem.unitCost "/>
                </calcop>
            </calculate>
            <!-- Credit Entries -->
            <make-value entity-name="AcctgTransEntry" value-name="creditEntry"/>
            <set field="creditEntry.debitCreditFlag" value="C"/>
            <set field="creditEntry.glAccountTypeId" from-field="inventoryItemDetail.reasonEnumId"/>
            <set field="creditEntry.productId" from-field="inventoryItem.productId"/>
            <set field="creditEntry.origAmount" from-field="origAmount"/>
            <set field="creditEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
            <set field="creditEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
            <!-- Debit Entries-->
            <make-value entity-name="AcctgTransEntry" value-name="debitEntry"/>
            <set field="debitEntry.debitCreditFlag" value="D"/>
            <set field="debitEntry.glAccountTypeId" value="INVENTORY_ACCOUNT"/>
            <set field="debitEntry.productId" from-field="inventoryItem.productId"/>
            <set field="debitEntry.origAmount" from-field="origAmount"/>
            <set field="debitEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
            <set field="debitEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
            <set field="acctgTransEntries[]" from-field="creditEntry" type="Object"/>
            <set field="acctgTransEntries[]" from-field="debitEntry" type="Object"/>            
        </iterate>
        <set field="createAcctgTransAndEntriesInMap.glFiscalTypeId" value="ACTUAL"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransEntries" from-field="acctgTransEntries"/>
        <set field="createAcctgTransAndEntriesInMap.physicalInventoryId" from-field="parameters.physicalInventoryId"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransTypeId" value="ITEM_VARIANCE_ACCTG_"/>
        <call-service service-name="createAcctgTransAndEntries" in-map-name="createAcctgTransAndEntriesInMap">
            <result-to-field result-name="acctgTransId"/>
        </call-service>
        <field-to-result field-name="acctgTransId" result-name="acctgTransId"/>
   </simple-method>

   <simple-method method-name="createAcctgTransForWorkEffortInventoryProduced" short-description="Create an accounting transactions for a Work Effort Inventory Produced (D: INVENTORY_ACCOUNT, C: WIP_INVENTORY)">
        <!-- retrieve ledger rounding properties -->
        <property-to-field resource="arithmetic" property="ledger.decimals" field-name="ledgerDecimals"/>
        <property-to-field resource="arithmetic" property="ledger.rounding" field-name="roundingMode"/>
        <log level="info" message="Using ledger decimals [${ledgerDecimals}] and rounding [${roundingMode}]"/>
        <entity-one entity-name="WorkEffortInventoryProduced" value-name="workEffortInventoryProduced">
            <field-map field-name="workEffortId" env-name="parameters.workEffortId"/>
            <field-map field-name="inventoryItemId" env-name="parameters.inventoryItemId"/>
        </entity-one>
        <get-related-one value-name="workEffortInventoryProduced" relation-name="InventoryItem" to-value-name="inventoryItem"/>  
        <!-- TODO: handle serialized inventory -->
        <calculate field-name="origAmount" type="BigDecimal" decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
            <calcop operator="multiply">
                <calcop operator="get" field-name="inventoryItem.quantityOnHandTotal"/>
                <calcop operator="get" field-name="inventoryItem.unitCost"/>
            </calcop>
        </calculate>
        <!-- prepare the doble posting (D/C) entries (AcctgTransEntry) -->
        <!-- Credit -->
        <make-value entity-name="AcctgTransEntry" value-name="creditEntry"/>
        <set field="creditEntry.debitCreditFlag" value="C"/>
        <set field="creditEntry.glAccountTypeId" value="WIP_INVENTORY"/>
        <set field="creditEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
        <set field="creditEntry.productId" from-field="inventoryItem.productId"/>
        <set field="creditEntry.origAmount" from-field="origAmount"/>
        <set field="creditEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
        <set field="acctgTransEntries[]" from-field="creditEntry" type="Object"/>
        <!-- Debit -->
        <make-value entity-name="AcctgTransEntry" value-name="debitEntry"/>
        <set field="debitEntry.debitCreditFlag" value="D"/>
        <set field="debitEntry.glAccountTypeId" value="INVENTORY_ACCOUNT"/>
        <set field="debitEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
        <set field="debitEntry.productId" from-field="inventoryItem.productId"/>
        <set field="debitEntry.origAmount" from-field="origAmount"/>
        <set field="debitEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>        
        <set field="acctgTransEntries[]" from-field="debitEntry" type="Object"/>
        <!-- Set header fields (AcctgTrans) -->
        <set field="createAcctgTransAndEntriesInMap.glFiscalTypeId" value="ACTUAL"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransTypeId" value="INVENTORY"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransEntries" from-field="acctgTransEntries"/>
        <call-service service-name="createAcctgTransAndEntries" in-map-name="createAcctgTransAndEntriesInMap">
            <result-to-field result-name="acctgTransId"/>
        </call-service>
        <field-to-result field-name="acctgTransId" result-name="acctgTransId"/>        
    </simple-method>            

    <simple-method method-name="createAcctgTransForWorkEffortCost"
               short-description="Create an accounting transaction for inventory that is issued to a work effort cost (Type: INVENTORY D: INVENTORY_ACCOUNT , C: UNINVOICED_SHIP_RCPT or COGS_ACCOUNT)">
        <entity-one entity-name="CostComponent" value-name="costComponent">
            <field-map field-name="costComponentId" env-name="parameters.costComponentId"/>
        </entity-one>
        <get-related-one value-name="costComponent" relation-name="CostComponentCalc" to-value-name="costComponentCalc"/>    
        <entity-one entity-name="WorkEffort" value-name="workEffort">
            <field-map field-name="workEffortId" env-name="parameters.workEffortId"/>
        </entity-one>
        <get-related-one value-name="workEffort" relation-name="Facility"  to-value-name="facility"/>
        <if-compare field-name="workEffort.workEffortTypeId" operator="equals" value="PROD_ORDER_TASK">
            <if-not-empty field-name="workEffort.workEffortParentId">
                <entity-and entity-name="WorkEffortGoodStandard" list-name="workEffortGoodStandards">
                    <field-map field-name="workEffortId" env-name="workEffort.workEffortParentId"/>
                    <field-map field-name="workEffortGoodStdTypeId" value="PRUN_PROD_DELIV"/>
                    <order-by field-name="-fromDate"/>
                </entity-and>
               <first-from-list list-name="workEffortGoodStandards" entry-name="workEffortGoodStandard"/>
            </if-not-empty>
        </if-compare>   
        <!-- Credit -->
        <make-value entity-name="AcctgTransEntry" value-name="creditEntry"/>
        <set field="creditEntry.debitCreditFlag" value="C"/>
        <set field="creditEntry.glAccountTypeId" value="costComponentCalc.costGlAccountTypeId"/>
        <set field="creditEntry.organizationPartyId" from-field="facility.ownerPartyId"/>
        <set field="creditEntry.productId" from-field="workEffortGoodStandard.productId"/>
        <set field="creditEntry.origAmount" from-field="costComponent.cost"/>
        <set field="creditEntry.origCurrencyUomId" from-field="facility.currencyUomId"/>        
        <set field="acctgTransEntries[]" from-field="creditEntry" type="Object"/>
        <!-- Debit -->
        <make-value entity-name="AcctgTransEntry" value-name="debitEntry"/>
        <set field="debitEntry.debitCreditFlag" value="D"/>
        <if-not-empty field-name="costComponentCalc.offsettingGlAccountTypeId">
            <set field="debitEntry.glAccountTypeId" value="costComponentCalc.offsettingGlAccountTypeId"/>
        <else>
            <set field="debitEntry.glAccountTypeId" value="WIP_INVENTORY"/>
        </else>
        </if-not-empty>
        <set field="debitEntry.organizationPartyId" from-field="facility.ownerPartyId"/>
        <set field="debitEntry.productId" from-field="workEffortGoodStandard.productId"/>
        <set field="debitEntry.origAmount" from-field="costComponent.cost"/>
        <set field="debitEntry.origCurrencyUomId" from-field="facility.currencyUomId"/>        
        <set field="acctgTransEntries[]" from-field="debitEntry" type="Object"/>
        <!-- Set header fields (AcctgTrans) -->
        <set field="createAcctgTransAndEntriesInMap.workEffortId" from-field="parameters.workEffortId"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransTypeId" value="MANUFACTURING"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransEntries" from-field="acctgTransEntries"/>
        <call-service service-name="createAcctgTransAndEntries" in-map-name="createAcctgTransAndEntriesInMap">
            <result-to-field result-name="acctgTransId"/>
        </call-service>
        <field-to-result field-name="acctgTransId" result-name="acctgTransId"/>
    </simple-method>

    <!-- AcctgTrans For Inventory Item Owner Change Service -->
    <simple-method method-name="createAcctgTransForInventoryItemOwnerChange" short-description="Create an accounting transactions for Inventory Item Owner Change (D: INVENTORY_ACCOUNT(old Owner) INVENTORY_ACCOUNT(new Owner), C: INVENTORY_XFER_IN(oldOwner) INVENTORY_XFER_OUT(new Owner))">
        <!-- retrieve ledger rounding properties -->
        <property-to-field resource="arithmetic" property="ledger.decimals" field-name="ledgerDecimals"/>
        <property-to-field resource="arithmetic" property="ledger.rounding" field-name="roundingMode"/>
        <log level="info" message="Using ledger decimals [${ledgerDecimals}] and rounding [${roundingMode}]"/>
 
        <entity-one entity-name="InventoryItem" value-name="inventoryItem"/>
        
        <!-- TODO: handle serialized inventory -->
        <if-not-empty field-name="inventoryItem.quantityOnHandTotal">
            <calculate field-name="origAmount" type="BigDecimal" decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
                <calcop operator="multiply">
                    <calcop operator="get" field-name="inventoryItem.quantityOnHandTotal"/>
                    <calcop operator="get" field-name="inventoryItem.unitCost"/>
                </calcop>
            </calculate>
        </if-not-empty>
        <!-- prepare the doble posting (D/C) entries (AcctgTransEntry) for old OwnerPartyId  -->
        <!-- Credit -->
        <make-value entity-name="AcctgTransEntry" value-name="oldPartyCreditEntry"/>
        <set field="oldPartyCreditEntry.debitCreditFlag" value="C"/>
        <set field="oldPartyCreditEntry.glAccountTypeId" value="INVENTORY_XFER_IN"/>
        <set field="oldPartyCreditEntry.productId" from-field="inventoryItem.productId"/>
        <set field="oldPartyCreditEntry.origAmount" from-field="origAmount"/>
        <set field="oldPartyCreditEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
        <set field="oldPartyCreditEntry.organizationPartyId" from-field="parameters.oldOwnerPartyId"/>
                
        <!-- Debit -->
        <make-value entity-name="AcctgTransEntry" value-name="oldPartyDebitEntry"/>
        <set field="oldPartyDebitEntry.debitCreditFlag" value="D"/>
        <set field="oldPartyDebitEntry.productId" from-field="inventoryItem.productId"/>
        <set field="oldPartyDebitEntry.origAmount" from-field="origAmount"/>
        <set field="oldPartyDebitEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
        <set field="oldPartyDebitEntry.organizationPartyId" from-field="parameters.oldOwnerPartyId"/>
        <set field="oldPartyDebitEntry.glAccountTypeId" value="INVENTORY_ACCOUNT"/>
        <!-- prepare the doble posting (D/C) entries (AcctgTransEntry) for New ownerPartyId -->
        <!-- Credit -->
        <make-value entity-name="AcctgTransEntry" value-name="newPartyCreditEntry"/>
        <set field="newPartyCreditEntry.debitCreditFlag" value="C"/>
        <set field="newPartyCreditEntry.glAccountTypeId" value="INVENTORY_XFER_IN"/>
        <set field="newPartyCreditEntry.productId" from-field="inventoryItem.productId"/>
        <set field="newPartyCreditEntry.origAmount" from-field="origAmount"/>
        <set field="newPartyCreditEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
        <set field="newPartyCreditEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
                
        <!-- Debit -->
        <make-value entity-name="AcctgTransEntry" value-name="newPartyDebitEntry"/>
        <set field="newPartyDebitEntry.debitCreditFlag" value="D"/>
        <set field="newPartyDebitEntry.productId" from-field="inventoryItem.productId"/>
        <set field="newPartyDebitEntry.origAmount" from-field="origAmount"/>
        <set field="newPartyDebitEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
        <set field="newPartyDebitEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
        <set field="newPartyDebitEntry.glAccountTypeId" value="INVENTORY_ACCOUNT"/>

        <set field="acctgTransEntries[]" from-field="oldPartyCreditEntry" type="Object"/>
        <set field="acctgTransEntries[]" from-field="oldPartyDebitEntry" type="Object"/>
        <set field="acctgTransEntries[]" from-field="newPartyCreditEntry" type="Object"/>
        <set field="acctgTransEntries[]" from-field="newPartyDebitEntry" type="Object"/>
        
        <!-- Set header fields (AcctgTrans) -->
        
        <set field="createAcctgTransAndEntriesInMap.acctgTransTypeId" value="INVENTORY"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransEntries" from-field="acctgTransEntries"/>
        <set field="createAcctgTransAndEntriesInMap.inventoryItemId" from-field="parameters.inventoryItemId"/>
        <set field="createAcctgTransAndEntriesInMap.glFiscalTypeId" value="ACTUAL"/>
        <call-service service-name="createAcctgTransAndEntries" in-map-name="createAcctgTransAndEntriesInMap">
            <result-to-field result-name="acctgTransId"/>
        </call-service>
        <field-to-result field-name="acctgTransId" result-name="acctgTransId"/>
    </simple-method>
    <!--automatic GL posting service triggered when inventory is issued to a work effort-->
  
    <simple-method method-name="createAcctgTransForWorkEffortIssuance" short-description="Create an accounting transaction for inventory that is issued to a work effort (Type: INVENTORY D: RAWMAT_INVENTORY, C: WIP_INVENTORY)">
        <!-- retrieve ledger rounding properties -->
        <property-to-field resource="arithmetic" property="ledger.decimals" field-name="ledgerDecimals"/>
        <property-to-field resource="arithmetic" property="ledger.rounding" field-name="roundingMode"/>
        <log level="info" message="Using ledger decimals [${ledgerDecimals}] and rounding [${roundingMode}]"/>
        <entity-one entity-name="WorkEffort" value-name="workEffort">
            <field-map field-name="workEffortId" env-name="parameters.workEffortId"/>
        </entity-one>
        <if-compare field-name="workEffort.workEffortTypeId" operator="equals" value="PROD_ORDER_TASK">
            <if-not-empty field-name="workEffort.workEffortParentId">
                <entity-and entity-name="WorkEffortGoodStandard" list-name="workEffortGoodStandards">
                    <field-map field-name="workEffortId" env-name="workEffort.workEffortParentId"/>
                    <field-map field-name="workEffortGoodStdTypeId" value="PRUN_PROD_DELIV"/>
                    <order-by field-name="-fromDate"/>
                </entity-and>
               <first-from-list list-name="workEffortGoodStandards" entry-name="workEffortGoodStandard"/>
            </if-not-empty>
        </if-compare>
        <entity-one entity-name="WorkEffortInventoryAssign" value-name="workEffortInventoryAssign">
            <field-map field-name="workEffortId" env-name="parameters.workEffortId"/>
            <field-map field-name="inventoryItemId" env-name="parameters.inventoryItemId"/>
        </entity-one>        
        <get-related-one value-name="workEffortInventoryAssign" relation-name="InventoryItem" to-value-name="inventoryItem"/>
        <!-- TODO: handle serialized inventory -->
        <calculate field-name="origAmount" type="BigDecimal" decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
            <calcop operator="multiply">
                <calcop operator="get" field-name="workEffortInventoryAssign.quantity"/>
                <calcop operator="get" field-name="inventoryItem.unitCost"/>
            </calcop>
        </calculate>
        <!--Credit -->
        <make-value entity-name="AcctgTransEntry" value-name="creditEntry"/>
        <set field="creditEntry.debitCreditFlag" value="C"/>
        <set field="creditEntry.glAccountTypeId" value="WIP_INVENTORY"/>
        <set field="creditEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
        <set field="creditEntry.productId" from-field="workEffortGoodStandard.productId"/>
        <set field="creditEntry.origAmount" from-field="origAmount"/>
        <set field="creditEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>        
        <set field="acctgTransEntries[]" from-field="creditEntry" type="Object"/>
        <!-- Debit -->
        <make-value entity-name="AcctgTransEntry" value-name="debitEntry"/>
        <set field="debitEntry.debitCreditFlag" value="D"/>
        <set field="debitEntry.glAccountTypeId" value="RAWMAT_INVENTORY"/>
        <set field="debitEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
        <set field="debitEntry.productId" from-field="inventoryItem.productId"/>
        <set field="debitEntry.origAmount" from-field="origAmount"/>
        <set field="debitEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>        
        <set field="acctgTransEntries[]" from-field="debitEntry" type="Object"/>
        <!-- Set header fields (AcctgTrans) -->
        <set field="createAcctgTransAndEntriesInMap.glFiscalTypeId" value="ACTUAL"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransTypeId" value="INVENTORY"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransEntries" from-field="acctgTransEntries"/>
        <call-service service-name="createAcctgTransAndEntries" in-map-name="createAcctgTransAndEntriesInMap">
            <result-to-field result-name="acctgTransId"/>
        </call-service>
        <field-to-result field-name="acctgTransId" result-name="acctgTransId"/>        
    </simple-method>
</simple-methods>
