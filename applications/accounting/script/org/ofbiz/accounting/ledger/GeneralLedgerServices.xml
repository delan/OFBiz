<?xml version="1.0" encoding="UTF-8"?>
<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->

<simple-methods xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
        xsi:noNamespaceSchemaLocation="http://ofbiz.apache.org/dtds/simple-methods.xsd">

    <!-- ========= GlAccount methods ========= -->
    <simple-method method-name="createGlAccount" short-description="Create an GlAccount">
        <make-value entity-name="GlAccount" value-name="newEntity"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>

        <!-- GlAccount uses a sequenced id, so get the next one now and set it... -->
        <if-empty field-name="parameters.glAccountId">
            <sequenced-id-to-env sequence-name="GlAccount" env-name="newEntity.glAccountId"/>
        <else>
            <set-pk-fields map-name="parameters" value-name="newEntity"/>
        </else>
        </if-empty>
        <field-to-result field-name="newEntity.glAccountId" result-name="glAccountId"/>
        
        <create-value value-name="newEntity"/>
    </simple-method>
    <simple-method method-name="updateGlAccount" short-description="Update an GlAccount">
        <make-value entity-name="GlAccount" value-name="lookupPKMap"/>
        <set-pk-fields map-name="parameters" value-name="lookupPKMap"/>
        <find-by-primary-key map-name="lookupPKMap" value-name="lookedUpValue"/>
        <set-nonpk-fields map-name="parameters" value-name="lookedUpValue"/>
        <store-value value-name="lookedUpValue"/>
    </simple-method>
    <simple-method method-name="deleteGlAccount" short-description="Delete an GlAccount">
        <make-value entity-name="GlAccount" value-name="lookupPKMap"/>
        <set-pk-fields map-name="parameters" value-name="lookupPKMap"/>
        <find-by-primary-key map-name="lookupPKMap" value-name="lookedUpValue"/>
        <remove-value value-name="lookedUpValue"/>
    </simple-method>
    
    <!-- ========= GlAccountOrganization methods ========= -->
    <simple-method method-name="createGlAccountOrganization" short-description="Create GlAccountOrganization">
        <make-value entity-name="GlAccountOrganization" value-name="newEntity"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>
        <set-pk-fields map-name="parameters" value-name="newEntity"/>

        <create-value value-name="newEntity"/>
    </simple-method>
    <simple-method method-name="updateGlAccountOrganization" short-description="Update GlAccountOrganization">
        <make-value entity-name="GlAccountOrganization" value-name="lookupPKMap"/>
        <set-pk-fields map-name="parameters" value-name="lookupPKMap"/>
        <find-by-primary-key map-name="lookupPKMap" value-name="lookedUpValue"/>
        <set-nonpk-fields map-name="parameters" value-name="lookedUpValue"/>
       
        <store-value value-name="lookedUpValue"/>
    </simple-method>
    <simple-method method-name="deleteGlAccountOrganization" short-description="Delete GlAccountOrganization">
        <make-value entity-name="GlAccountOrganization" value-name="lookupPKMap"/>
        <set-pk-fields map-name="parameters" value-name="lookupPKMap"/>
        <find-by-primary-key map-name="lookupPKMap" value-name="lookedUpValue"/>
        <remove-value value-name="lookedUpValue"/>
    </simple-method>

    <!-- ========= GlJournal methods ========= -->
    <simple-method method-name="quickCreateAcctgTransAndEntries" short-description="Creates an AcctgTrans and two offsetting AcctgTransEntry records">
        <!-- TODO: Do we need to create a GlJournal record here? -->
    
        <!-- first, create the AcctgTrans -->
        <set-service-fields service-name="createAcctgTrans" to-map-name="createAcctgTransParams" map-name="parameters"/>
        <now-timestamp-to-env env-name="createAcctgTransParams.transactionDate"/>
        <call-service service-name="createAcctgTrans" in-map-name="createAcctgTransParams">
            <result-to-field result-name="acctgTransId"/>
        </call-service>

        <!-- TODO: if someday there are more than one type of acctgTransEntryTypeId (other than _NA_, we should get rid of the lines below
            that fix those values -->
        <!-- now, create the debit AcctgTransEntry -->
        <set-service-fields service-name="createAcctgTransEntry" map-name="parameters" to-map-name="createAcctgTransEntryParams"/>
        <set field="createAcctgTransEntryParams.acctgTransId" from-field="acctgTransId"/>
        <set field="createAcctgTransEntryParams.glAccountId" from-field="parameters.debitGlAccountId"/>
        <set field="createAcctgTransEntryParams.debitCreditFlag" value="D"/>
        <set field="createAcctgTransEntryParams.acctgTransEntryTypeId" value="_NA_"/>
        <call-service service-name="createAcctgTransEntry" in-map-name="createAcctgTransEntryParams"/>
        
        <!-- now the credit AcctgTransEntry -->
        <set-service-fields service-name="createAcctgTransEntry" map-name="parameters" to-map-name="createAcctgTransEntryParams"/>
        <set field="createAcctgTransEntryParams.acctgTransId" from-field="acctgTransId"/>
        <set field="createAcctgTransEntryParams.glAccountId" from-field="parameters.creditGlAccountId"/>
        <set field="createAcctgTransEntryParams.debitCreditFlag" value="C"/>
        <set field="createAcctgTransEntryParams.acctgTransEntryTypeId" value="_NA_"/>
        <call-service service-name="createAcctgTransEntry" in-map-name="createAcctgTransEntryParams"/>
        
        <field-to-result field-name="acctgTransId" result-name="acctgTransId"/>
    </simple-method> 
       
    <simple-method method-name="createGlJournal" short-description="Create an GlJournal">
        <make-value entity-name="GlJournal" value-name="newEntity"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>

        <!-- GlJournal uses a sequenced id, so get the next one now and set it... -->        
        <sequenced-id-to-env sequence-name="GlJournal" env-name="newEntity.glJournalId"/>
        <field-to-result field-name="newEntity.glJournalId" result-name="glJournalId"/>

        <create-value value-name="newEntity"/>
    </simple-method>
    <simple-method method-name="updateGlJournal" short-description="Update an GlJournal">
        <entity-one entity-name="GlJournal" value-name="lookedUpValue"/>
        <set-nonpk-fields map-name="parameters" value-name="lookedUpValue"/>
        <store-value value-name="lookedUpValue"/>
    </simple-method>
    <simple-method method-name="deleteGlJournal" short-description="Delete an GlJournal">
        <entity-one entity-name="GlJournal" value-name="lookedUpValue"/>
        <remove-value value-name="lookedUpValue"/>
    </simple-method>
        
    <!-- GlJournal Trial Balance and Post routines -->
    <simple-method method-name="calculateGlJournalTrialBalance" short-description="Calculate Trial Balance for a GlJournal">
        <check-permission permission="ACCOUNTING" action="_VIEW"><fail-message message="Security Error: to run calculateGlJournalTrialBalance you must have the ACCOUNTING_UPDATE or ACCOUNTING_ADMIN permission"/></check-permission>
        <check-errors/>

        <!-- iterate through all AcctgTrans in this journal and that are not yet posted, and get totals of all debits and of all credits -->
        <entity-condition entity-name="AcctgTrans" list-name="acctgTransList">
            <condition-list combine="and">
                <condition-expr field-name="glJournalId" env-name="parameters.glJournalId"/>
                <condition-expr field-name="isPosted" operator="not-equals" value="Y"/>
            </condition-list>
        </entity-condition>
        
        <iterate entry-name="acctgTrans" list-name="acctgTransList">
            <clear-field field-name="callServiceMap"/>
            <clear-field field-name="serviceResults"/>
            <set from-field="acctgTrans.acctgTransId" field="callServiceMap.acctgTransId"/>
            <call-service service-name="calculateAcctgTransTrialBalance" in-map-name="callServiceMap">
                <results-to-map map-name="serviceResults"/>
            </call-service>
            <calculate field-name="debitTotal" type="Double">
                <calcop operator="get" field-name="debitTotal"/>
                <calcop operator="get" field-name="serviceResults.debitTotal"/>
            </calculate>
            <calculate field-name="creditTotal" type="Double">
                <calcop operator="get" field-name="creditTotal"/>
                <calcop operator="get" field-name="serviceResults.creditTotal"/>
            </calculate>
            <calculate field-name="debitCreditDifference" type="Double">
                <calcop operator="get" field-name="debitCreditDifference"/>
                <calcop operator="get" field-name="serviceResults.debitCreditDifference"/>
            </calculate>
        </iterate>
        
        <field-to-result field-name="debitTotal"/>
        <field-to-result field-name="creditTotal"/>
        <field-to-result field-name="debitCreditDifference"/>
    </simple-method>

    <simple-method method-name="postGlJournal" short-description="Post a GlJournal">
        <check-permission permission="ACCOUNTING" action="_UPDATE"><fail-message message="Security Error: to run postGlJournal you must have the ACCOUNTING_UPDATE or ACCOUNTING_ADMIN permission"/></check-permission>
        <check-errors/>
        <!-- first calculate the trial balance for the journal and make sure debits and credits match -->
        <set from-field="parameters.glJournalId" field="trialBalanceCallMap.glJournalId"/>
        <call-service service-name="calculateGlJournalTrialBalance" in-map-name="trialBalanceCallMap">
            <results-to-map map-name="trialBalanceResultMap"/>
        </call-service>
        
        <if-compare field-name="trialBalanceResultMap.debitCreditDifference" operator="not-equals" value="0" type="Double">
            <add-error><fail-message message="Not posting GL Journal with ID [${parameters.glJournalId}] because the trial balance failed: Debit Total=${trialBalanceResultMap.debitTotal} Credit Total=${trialBalanceResultMap.creditTotal} Debit/Credit Difference=${trialBalanceResultMap.debitCreditDifference}"/></add-error>
            <check-errors/>
        </if-compare>
        
        <!-- iterate through all AcctgTrans in this journal and that are not yet posted, and post each one -->
        <entity-condition entity-name="AcctgTrans" list-name="acctgTransList">
            <condition-list combine="and">
                <condition-expr field-name="glJournalId" env-name="parameters.glJournalId"/>
                <condition-expr field-name="isPosted" operator="not-equals" value="Y"/>
            </condition-list>
        </entity-condition>
        <iterate entry-name="acctgTrans" list-name="acctgTransList">
            <clear-field field-name="callServiceMap"/>
            <set from-field="acctgTrans.acctgTransId" field="callServiceMap.acctgTransId"/>
            <call-service service-name="postAcctgTrans" in-map-name="callServiceMap"/>
        </iterate>
    </simple-method>

    <!-- ========= GlReconciliation methods ========= -->
    <simple-method method-name="createGlReconciliation" short-description="Create an GlReconciliation">
        <make-value entity-name="GlReconciliation" value-name="newEntity"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>

        <!-- GlReconciliation uses a sequenced id, so get the next one now and set it... -->        
        <sequenced-id-to-env sequence-name="GlReconciliation" env-name="newEntity.glReconciliationId"/>
        <field-to-result field-name="newEntity.glReconciliationId" result-name="glReconciliationId"/>
        
        <set from-field="userLogin.userLoginId" field="newEntity.lastModifiedByUserLogin"/>
        <set from-field="userLogin.userLoginId" field="newEntity.createdByUserLogin"/>
        
        <create-value value-name="newEntity"/>
    </simple-method>
    <simple-method method-name="updateGlReconciliation" short-description="Update an GlReconciliation">
        <entity-one entity-name="GlReconciliation" value-name="lookedUpValue"/>
        <set-nonpk-fields map-name="parameters" value-name="lookedUpValue"/>
        
        <set from-field="userLogin.userLoginId" field="lookedUpValue.lastModifiedByUserLogin"/>
        <store-value value-name="lookedUpValue"/>
    </simple-method>
    <simple-method method-name="deleteGlReconciliation" short-description="Delete an GlReconciliation">
        <entity-one entity-name="GlReconciliation" value-name="lookedUpValue"/>
        <remove-value value-name="lookedUpValue"/>
    </simple-method>
    <simple-method method-name="updateGlReconciliationLastModified" short-description="Update GlReconciliation LastModified Info">
        <!-- this is just a little method that is meant to be called as an inline call-simple-method target with the context already setup -->
        <entity-one entity-name="GlReconciliation" value-name="lookedUpGLR"/>
        <set from-field="userLogin.userLoginId" field="lookedUpGLR.lastModifiedByUserLogin"/>
        <store-value value-name="lookedUpGLR"/>
    </simple-method>
    
    <!-- ========= GlReconciliationEntry methods ========= -->
    <simple-method method-name="createGlReconciliationEntry" short-description="Add Entry To GlReconciliation">
        <!-- first of all, make sure that the AcctgTransEntry is not already reconciled -->
        <entity-one entity-name="AcctgTransEntry" value-name="acctgTransEntry"/>
        <if-compare field-name="acctgTransEntry.reconcileStatusId" operator="equals" value="AES_RECONCILED">
            <add-error><fail-message message="The accounting transaction entry ${acctgTransEntry.acctgTransId}/${acctgTransEntry.acctgTransEntrySeqId} is already reconciled: cannot reconcile."/></add-error>
            <check-errors/>
        </if-compare>
        <make-value entity-name="GlReconciliationEntry" value-name="newEntity"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>
        <set-pk-fields map-name="parameters" value-name="newEntity"/>
        <create-value value-name="newEntity"/>

        <!-- update the status of the AcctgTransEntry to reconciled -->
        <set field="updateAcctgTransEntryInMap.acctgTransId" from-field="parameters.acctgTransId"/>
        <set field="updateAcctgTransEntryInMap.acctgTransEntrySeqId" from-field="parameters.acctgTransEntrySeqId"/>
        <set field="updateAcctgTransEntryInMap.acctgTransEntrySeqId" value="AES_RECONCILED"/>
        <call-service service-name="updateAcctgTransEntry" in-map-name="updateAcctgTransEntryInMap"/>
        <check-errors/>

        <!-- when changing entries, also update the last modified info for the GlReconciliation -->
        <call-simple-method method-name="updateGlReconciliationLastModified"/>
    </simple-method>
    <simple-method method-name="updateGlReconciliationEntry" short-description="Update Entry To GlReconciliation">
        <entity-one entity-name="GlReconciliationEntry" value-name="lookedUpValue"/>
        <set-nonpk-fields map-name="parameters" value-name="lookedUpValue"/>
        <store-value value-name="lookedUpValue"/>
        
        <!-- when changing entries, also update the last modified info for the GlReconciliation -->
        <call-simple-method method-name="updateGlReconciliationLastModified"/>
    </simple-method>
    <simple-method method-name="deleteGlReconciliationEntry" short-description="Remove Entry From GlReconciliation">
        <entity-one entity-name="GlReconciliationEntry" value-name="lookedUpValue"/>
        <remove-value value-name="lookedUpValue"/>

        <!-- when changing entries, also update the last modified info for the GlReconciliation -->
        <call-simple-method method-name="updateGlReconciliationLastModified"/>
    </simple-method>

    <!-- ========== GL Posting Services ========== -->
    <simple-method method-name="createAcctgTransAndEntries" short-description="Verifies and posts a set of AcctgTransEntries">
        <!-- retrieve ledger rounding properties -->
        <property-to-field resource="arithmetic" property="ledger.decimals" field-name="ledgerDecimals"/>
        <property-to-field resource="arithmetic" property="ledger.rounding" field-name="roundingMode"/>
        <log level="info" message="Using ledger decimals [${ledgerDecimals}] and rounding [${roundingMode}]"/>

        <!-- first loop through and make sure all the entries are valid  -->
        <iterate list-name="parameters.acctgTransEntries" entry-name="acctgTransEntry">
            <!-- the organization party must be an internal organization -->
            <entity-one entity-name="PartyRole" value-name="partyRole" use-cache="true" auto-field-map="false">
                <field-map field-name="partyId" env-name="acctgTransEntry.organizationPartyId"/>
                <field-map field-name="roleTypeId" value="INTERNAL_ORGANIZATIO"/>
            </entity-one>
            <if-empty field-name="partyRole">
                <log level="warning" message="The party with id [${acctgTransEntry.organizationPartyId}] is not an internal organization; the following accounting transaction will be ignored: ${acctgTransEntry}"/>
            <else>
                <entity-one entity-name="PartyAcctgPreference" value-name="partyAcctgPreference" use-cache="true" auto-field-map="false">
                    <field-map field-name="partyId" env-name="acctgTransEntry.organizationPartyId"/>
                </entity-one>
                <if-empty field-name="partyAcctgPreference">
                    <log level="warning" message="The internal organization with id [${acctgTransEntry.organizationPartyId}] has no PartyAcctgPreference setting; the following accounting transaction will be ignored: ${acctgTransEntry}"/>
                <else>
                    <!-- if the amount field is empty, then determine it from the origAmount and origCurrencyUomId fields:
                         if origCurrencyUomId is different from the base currency of the organization, then the amount value will be converted -->
                    <if-empty field-name="acctgTransEntry.amount">
                        <if-not-empty field-name="acctgTransEntry.origAmount">
                            <if-empty field-name="acctgTransEntry.origCurrencyUomId">
                                <set field="acctgTransEntry.origCurrencyUomId" from-field="partyAcctgPreference.baseCurrencyUomId"/>
                            </if-empty>
                            <set field="acctgTransEntry.currencyUomId" from-field="partyAcctgPreference.baseCurrencyUomId"/>
                            <if-compare-field field-name="acctgTransEntry.origCurrencyUomId" operator="not-equals" to-field-name="acctgTransEntry.currencyUomId">
                                <clear-field field-name="convertUomInMap"/>
                                <set field="convertUomInMap.originalValue" from-field="acctgTransEntry.origAmount"/>
                                <set field="convertUomInMap.uomId" from-field="acctgTransEntry.origCurrencyUomId"/>
                                <set field="convertUomInMap.uomIdTo" from-field="acctgTransEntry.currencyUomId"/>
                                <!-- TODO: set the optional asOfDate input parameter -->
                                <call-service service-name="convertUom" in-map-name="convertUomInMap">
                                    <result-to-field result-name="convertedValue" field-name="acctgTransEntry.amount"/>
                                </call-service>
                            <else>
                                <set field="acctgTransEntry.amount" from-field="acctgTransEntry.origAmount"/>
                            </else>
                            </if-compare-field>
                        </if-not-empty>
                    </if-empty>
                    <!-- if the glAccountId is empty, but we have a glAccountTypeId, then we will determine the
                         correct glAccountId from the gl setup settings -->
                    <if-empty field-name="acctgTransEntry.glAccountId">
                        <clear-field field-name="getGlAccountFromAccountTypeInMap"/>
                        <set field="getGlAccountFromAccountTypeInMap.organizationPartyId" from-field="acctgTransEntry.organizationPartyId"/>
                        <set field="getGlAccountFromAccountTypeInMap.acctgTransTypeId" from-field="parameters.acctgTransTypeId"/>
                        <set field="getGlAccountFromAccountTypeInMap.glAccountTypeId" from-field="acctgTransEntry.glAccountTypeId"/>
                        <set field="getGlAccountFromAccountTypeInMap.debitCreditFlag" from-field="acctgTransEntry.debitCreditFlag"/>
                        <set field="getGlAccountFromAccountTypeInMap.productId" from-field="acctgTransEntry.productId"/>
                        <set field="getGlAccountFromAccountTypeInMap.invoiceId" from-field="parameters.invoiceId"/>
                        <set field="getGlAccountFromAccountTypeInMap.paymentId" from-field="parameters.paymentId"/>
                        <call-service service-name="getGlAccountFromAccountType" in-map-name="getGlAccountFromAccountTypeInMap">
                            <result-to-field result-name="glAccountId" field-name="acctgTransEntry.glAccountId"/>
                        </call-service>
                    </if-empty>
                    <if-empty field-name="acctgTransEntry.origAmount">
                        <set field="acctgTransEntry.origAmount" from-field="acctgTransEntry.amount"/>
                    </if-empty>
                    <entity-one entity-name="GlAccountType" value-name="glAccountType" use-cache="true" auto-field-map="false">
                        <field-map field-name="glAccountTypeId" env-name="acctgTransEntry.glAccountTypeId"/>
                    </entity-one>
                    <if-empty field-name="glAccountType">
                        <clear-field field-name="acctgTransEntry.glAccountTypeId"/>
                    </if-empty>
                    <set field="normalizedAcctgTransEntries[]" from-field="acctgTransEntry"/>
                </else>
                </if-empty>
            </else>
            </if-empty>
        </iterate>

        <if-not-empty field-name="normalizedAcctgTransEntries">
            <!-- now do the posting. First, create the AcctgTrans entity -->
            <set-service-fields service-name="createAcctgTrans" map-name="parameters" to-map-name="createAcctgTransParams"/>
            <if-empty field-name="createAcctgTransParams.transactionDate">
                <now-timestamp-to-env env-name="createAcctgTransParams.transactionDate"/>
            </if-empty>
            <call-service service-name="createAcctgTrans" in-map-name="createAcctgTransParams">
                <result-to-field result-name="acctgTransId"/>
            </call-service>

            <!-- Next, create the AcctgTransEntry entities one by one -->
            <iterate list-name="normalizedAcctgTransEntries" entry-name="acctgTransEntry">
                <!-- if any amount is negative, then get the absolute (positive) value of that amount, and flip the Debit/Credit flag  -->
                <if-compare field-name="acctgTransEntry.origAmount" operator="less" value="0">
                    <log level="verbose" message="${acctgTransEntry} is going to get inverted"/>
                    <calculate field-name="acctgTransEntry.origAmount">
                        <calcop field-name="acctgTransEntry.origAmount" operator="negative"/>
                    </calculate>
                    <calculate field-name="acctgTransEntry.amount">
                        <calcop field-name="acctgTransEntry.amount" operator="negative"/>
                    </calculate>
                    <if-compare field-name="acctgTransEntry.debitCreditFlag" operator="equals" value="D">
                        <set value="C" field="acctgTransEntry.debitCreditFlag"/>
                    <else>
                        <if-compare field-name="acctgTransEntry.debitCreditFlag" operator="equals" value="C">
                            <set value="D" field="acctgTransEntry.debitCreditFlag"/>
                        </if-compare>
                    </else>
                    </if-compare>
                </if-compare>

                <!-- now create the AcctgTransEntry using the acctgTransId we already have from above -->
                <clear-field field-name="createAcctgTransEntryParams"/>
                <set-service-fields service-name="createAcctgTransEntry" map-name="acctgTransEntry" to-map-name="createAcctgTransEntryParams"/>
                <set from-field="acctgTransId" field="createAcctgTransEntryParams.acctgTransId"/>
                <call-service service-name="createAcctgTransEntry" in-map-name="createAcctgTransEntryParams"/>
            </iterate>
        <else>
            <log level="warning" message="Cannot process an accounting transactions with empty list of entries."/>
        </else>
        </if-not-empty>
        
        <!-- all done -->
        <field-to-result field-name="acctgTransId"/>
    </simple-method>

    <!-- Miscellaneous services for product and inventory -->

    <simple-method method-name="getGlAccountFromAccountType" short-description="Look up a GlAccountId from GlAccountTypeId">
        <!-- if this is an inventory variance then the glAccountTypeId contains the varianceReasonId; the value is used to lookup the account id in the VarianceReasonGlAccount entity -->
        <if-compare field-name="parameters.acctgTransTypeId" operator="equals" value="ITEM_VARIANCE">
            <entity-one entity-name="VarianceReasonGlAccount" value-name="varianceReasonGlAccount">
                <field-map field-name="organizationPartyId" env-name="parameters.organizationPartyId"/>
                <field-map field-name="varianceReasonId" env-name="parameters.glAccountTypeId"/>
            </entity-one>
            <if-not-empty field-name="varianceReasonGlAccount.glAccountId">
                <field-to-result field-name="varianceReasonGlAccount.glAccountId" result-name="glAccountId"/>
            </if-not-empty>
            <return/>
        </if-compare>
        <if>
            <condition>
                <and>
                    <or>
                        <and>
                            <if-compare field-name="parameters.acctgTransTypeId" operator="equals" value="OUTGOING_PAYMENT"/>
                            <if-compare field-name="parameters.debitCreditFlag" operator="equals" value="C"/>
                        </and>
                        <and>
                            <if-compare field-name="parameters.acctgTransTypeId" operator="equals" value="INCOMING_PAYMENT"/>
                            <if-compare field-name="parameters.debitCreditFlag" operator="equals" value="D"/>
                        </and>
                    </or>
                    <not><if-empty field-name="parameters.paymentId"/></not>
                </and>
            </condition>
            <then>
                <entity-one entity-name="Payment" value-name="payment"/>
                <get-related-one value-name="payment" relation-name="PaymentMethod" to-value-name="paymentMethod"/>
                <if-not-empty field-name="paymentMethod.glAccountId">
                    <field-to-result field-name="paymentMethod.glAccountId" result-name="glAccountId"/>
                    <return/>
                </if-not-empty>
                <if-compare field-name="payment.paymentMethodTypeId" operator="equals" value="CREDIT_CARD">
                    <get-related-one value-name="payment" relation-name="CreditCard" to-value-name="creditCard"/>
                    <entity-one entity-name="CreditCardTypeGlAccount" value-name="creditCardTypeGlAccount">
                        <field-map field-name="cardType" env-name="creditCard.cardType"/>
                        <field-map field-name="organizationPartyId" env-name="parameters.organizationPartyId"/>
                    </entity-one>
                    <if-not-empty field-name="creditCardTypeGlAccount.glAccountId">
                        <field-to-result field-name="creditCardTypeGlAccount.glAccountId" result-name="glAccountId"/>
                        <return/>
                    </if-not-empty>
                </if-compare>
                <entity-one entity-name="PaymentMethodTypeGlAccount" value-name="paymentMethodTypeGlAccount">
                    <field-map field-name="paymentMethodTypeId" env-name="payment.paymentMethodTypeId"/>
                    <field-map field-name="organizationPartyId" env-name="parameters.organizationPartyId"/>
                </entity-one>
                <if-not-empty field-name="paymentMethodTypeGlAccount.glAccountId">
                    <field-to-result field-name="paymentMethodTypeGlAccount.glAccountId" result-name="glAccountId"/>
                    <return/>
                </if-not-empty>
                <return/>
            </then>
        </if>
        <if-not-empty field-name="parameters.productId">
            <entity-one entity-name="ProductGlAccount" value-name="lookedUpValue" use-cache="true"/>
            <!-- if nothing found look if the parameters.productId is member of any ProductCategory in ProductCategoryGlAccount --> 
            <if-empty field-name="lookedUpValue.glAccountId">
                <entity-and entity-name="ProductCategoryMember" list-name="productCategoryMembers" filter-by-date="true">
                    <field-map field-name="productId" env-name="parameters.productId"/>
                    <order-by field-name="-fromDate"/>
                </entity-and>
                <iterate list-name="productCategoryMembers" entry-name="productCategoryMember">
                    <entity-one entity-name="ProductCategoryGlAccount" value-name="productCategoryGlAccount">
                        <field-map field-name="productCategoryId" env-name="productCategoryMember.productCategoryId"/>
                        <field-map field-name="glAccountTypeId" env-name="parameters.glAccountTypeId"/>
                        <field-map field-name="organizationPartyId" env-name="parameters.organizationPartyId"/>
                    </entity-one>
                    <if-not-empty field-name="productCategoryGlAccount.glAccountId">
                        <field-to-result field-name="productCategoryGlAccount.glAccountId" result-name="glAccountId"/>
                        <return/>
                    </if-not-empty>
                </iterate>
            </if-empty>
        </if-not-empty>
        <if>
            <condition>
                <and>
                    <or>
                        <and>
                            <if-compare field-name="parameters.acctgTransTypeId" operator="equals" value="PURCHASE_INVOICE"/>
                            <if-compare field-name="parameters.debitCreditFlag" operator="equals" value="D"/>
                        </and>
                        <and>
                            <if-compare field-name="parameters.acctgTransTypeId" operator="equals" value="SALES_INVOICE"/>
                            <if-compare field-name="parameters.debitCreditFlag" operator="equals" value="C"/>
                        </and>
                    </or>
                    <not><if-empty field-name="parameters.invoiceId"/></not>
                    <not><if-empty field-name="parameters.glAccountTypeId"/></not>
                </and>
            </condition>
            <then>
                <if-not-empty field-name="parameters.productId">
                    <entity-one entity-name="GlAccountTypeDefault" value-name="glAccountTypeDefault" use-cache="true">
                        <field-map field-name="organizationPartyId" env-name="parameters.organizationPartyId"/>
                        <field-map field-name="glAccountTypeId" value="SALES_ACCOUNT"/>
                    </entity-one>
                    <if-not-empty field-name="glAccountTypeDefault.glAccountId">
                        <field-to-result field-name="glAccountTypeDefault.glAccountId" result-name="glAccountId"/>
                        <return/>
                    </if-not-empty>
                </if-not-empty>
                <entity-one entity-name="InvoiceItemTypeGlAccount" value-name="invoiceItemTypeGlAccount">
                    <field-map field-name="invoiceItemTypeId" env-name="parameters.glAccountTypeId"/>
                    <field-map field-name="organizationPartyId" env-name="parameters.organizationPartyId"/>
                </entity-one>
                <if-not-empty field-name="invoiceItemTypeGlAccount.glAccountId">
                    <field-to-result field-name="invoiceItemTypeGlAccount.glAccountId" result-name="glAccountId"/>
                    <return/>
                </if-not-empty>
                <entity-one entity-name="InvoiceItemType" value-name="invoiceItemType">
                    <field-map field-name="invoiceItemTypeId" env-name="parameters.glAccountTypeId"/>
                </entity-one>
                <if-not-empty field-name="invoiceItemType.defaultGlAccountId">
                    <field-to-result field-name="invoiceItemType.defaultGlAccountId" result-name="glAccountId"/>
                    <return/>
                </if-not-empty>
                <return/>
            </then>
        </if>

        <!-- if nothing found or if no such parameters were passed (lookedUpValue empty in both cases), try GlAccountTypeDefault -->
        <if-empty field-name="lookedUpValue.glAccountId">
            <entity-one entity-name="GlAccountTypeDefault" value-name="lookedUpValue" use-cache="true"/> 
        </if-empty>
        <field-to-result field-name="lookedUpValue.glAccountId" result-name="glAccountId"/> 
    </simple-method>

    <simple-method method-name="getInventoryItemOwner" short-description="Get an ownerPartyId from inventoryItemId">
        <entity-one entity-name="InventoryItem" value-name="inventoryItem"/>
        <if-empty field-name="inventoryItem.ownerPartyId">
            <get-related-one value-name="inventoryItem" relation-name="Facility" to-value-name="facility"/>
            <field-to-result field-name="facility.ownerPartyId" result-name="ownerPartyId"/>
        <else>
            <field-to-result field-name="inventoryItem.ownerPartyId" result-name="ownerPartyId"/>
        </else>
        </if-empty>
    </simple-method>

    <simple-method method-name="closeFinancialTimePeriod" short-description="Close a financial CustomTimePeriod">
        <entity-one entity-name="CustomTimePeriod" value-name="customTimePeriod"/>
        <set field="openTimePeriodCondition.isClosed" value="N"/>
        <get-related value-name="customTimePeriod" relation-name="ChildCustomTimePeriod" list-name="openChildTimePeriods" map-name="openTimePeriodCondition"/>
        <iterate list-name="openChildTimePeriods" entry-name="openChildTimePeriod">
            <add-error><fail-message message="Cannot close time period [${customTimePeriod.customTimePeriodId}] because the child time period ${openChildTimePeriod.periodName} [${openChildTimePeriod.customTimePeriodId}] is not closed."/></add-error>
        </iterate>
        <check-errors/>
        <!-- retrieve the last closed date for the same type of time period -->
        <set field="findLastClosedDateInMap.organizationPartyId" from-field="customTimePeriod.organizationPartyId"/>
        <set field="findLastClosedDateInMap.periodTypeId" from-field="customTimePeriod.periodTypeId"/>
        <call-service service-name="findLastClosedDate" in-map-name="findLastClosedDateInMap">
            <result-to-field result-name="lastClosedDate"/>
            <result-to-field result-name="lastClosedTimePeriod"/>
        </call-service>
        <if-empty field-name="lastClosedDate">
            <add-error><fail-message message="Unable to find a last closed date for time period [${customTimePeriod.customTimePeriodId}] of type [${customTimePeriod.customTimePeriodId}] for organization [${customTimePeriod.organizationPartyId}]"/></add-error>
        </if-empty>
        <check-errors/>
        <entity-one entity-name="GlAccountClass" value-name="expenseGlAccountClass">
            <field-map field-name="glAccountClassId" value="EXPENSE"/>
        </entity-one>
        <call-class-method class-name="org.ofbiz.accounting.util.UtilAccounting" method-name="getDescendantGlAccountClassIds" ret-field-name="expenseAccountClassIds">
            <field field-name="expenseGlAccountClass" type="GenericValue"/>
        </call-class-method>
        <entity-one entity-name="GlAccountClass" value-name="revenueGlAccountClass">
            <field-map field-name="glAccountClassId" value="REVENUE"/>
        </entity-one>
        <call-class-method class-name="org.ofbiz.accounting.util.UtilAccounting" method-name="getDescendantGlAccountClassIds" ret-field-name="revenueAccountClassIds">
            <field field-name="revenueGlAccountClass" type="GenericValue"/>
        </call-class-method>
        <entity-one entity-name="GlAccountClass" value-name="incomeGlAccountClass">
            <field-map field-name="glAccountClassId" value="INCOME"/>
        </entity-one>
        <call-class-method class-name="org.ofbiz.accounting.util.UtilAccounting" method-name="getDescendantGlAccountClassIds" ret-field-name="incomeAccountClassIds">
            <field field-name="incomeGlAccountClass" type="GenericValue"/>
        </call-class-method>
        <entity-one entity-name="GlAccountClass" value-name="assetGlAccountClass">
            <field-map field-name="glAccountClassId" value="ASSET"/>
        </entity-one>
        <call-class-method class-name="org.ofbiz.accounting.util.UtilAccounting" method-name="getDescendantGlAccountClassIds" ret-field-name="assetAccountClassIds">
            <field field-name="assetGlAccountClass" type="GenericValue"/>
        </call-class-method>
        <entity-one entity-name="GlAccountClass" value-name="liabilityGlAccountClass">
            <field-map field-name="glAccountClassId" value="LIABILITY"/>
        </entity-one>
        <call-class-method class-name="org.ofbiz.accounting.util.UtilAccounting" method-name="getDescendantGlAccountClassIds" ret-field-name="liabilityAccountClassIds">
            <field field-name="liabilityGlAccountClass" type="GenericValue"/>
        </call-class-method>
        <entity-one entity-name="GlAccountClass" value-name="equityGlAccountClass">
            <field-map field-name="glAccountClassId" value="EQUITY"/>
        </entity-one>
        <call-class-method class-name="org.ofbiz.accounting.util.UtilAccounting" method-name="getDescendantGlAccountClassIds" ret-field-name="equityAccountClassIds">
            <field field-name="equityGlAccountClass" type="GenericValue"/>
        </call-class-method>
        
        <!-- Compute the total posted amount of the period -->
        <entity-condition entity-name="AcctgTransAndEntries" list-name="acctgTransAndEntries">
            <condition-list combine="and">
                <condition-expr field-name="organizationPartyId" operator="equals" env-name="customTimePeriod.organizationPartyId"/>
                <condition-expr field-name="isPosted" operator="equals" value="Y"/>
                <condition-expr field-name="glFiscalTypeId" operator="equals" value="ACTUAL"/>
                <condition-expr field-name="transactionDate" operator="greater-equals" env-name="lastClosedDate"/>
                <condition-expr field-name="transactionDate" operator="less" env-name="customTimePeriod.thruDate"/> <!-- FIXME: Date to Timestamp -->
                <condition-expr field-name="acctgTransTypeId" operator="not-equals" value="PERIOD_CLOSING"/>
                <condition-list combine="or">
                    <condition-expr field-name="glAccountClassId" operator="in" env-name="expenseAccountClassIds"/>
                    <condition-expr field-name="glAccountClassId" operator="in" env-name="revenueAccountClassIds"/>
                    <condition-expr field-name="glAccountClassId" operator="in" env-name="incomeAccountClassIds"/>
                </condition-list>
            </condition-list>
            <order-by field-name="acctgTransId"/>
            <order-by field-name="acctgTransEntrySeqId"/>
        </entity-condition>
        <set field="totalAmount" value="0.0" type="Double"/>
        <iterate list-name="acctgTransAndEntries" entry-name="acctgTransAndEntry">
            <get-related-one value-name="acctgTransAndEntry" relation-name="GlAccount" to-value-name="glAccount"/>
            <call-class-method class-name="org.ofbiz.accounting.util.UtilAccounting" method-name="isCreditAccount" ret-field-name="isCreditAccount">
                <field field-name="glAccount" type="GenericValue"/>
            </call-class-method>
            <call-class-method class-name="org.ofbiz.accounting.util.UtilAccounting" method-name="isDebitAccount" ret-field-name="isDebitAccount">
                <field field-name="glAccount" type="GenericValue"/>
            </call-class-method>
            <call-class-method class-name="org.ofbiz.accounting.util.UtilAccounting" method-name="isExpenseAccount" ret-field-name="isExpenseAccount">
                <field field-name="glAccount" type="GenericValue"/>
            </call-class-method>
            <set field="amount" from-field="acctgTransAndEntry.amount" type="Double"/>
            <if>
                <condition>
                    <or>
                        <and>
                            <if-compare field-name="acctgTransAndEntry.debitCreditFlag" operator="equals" value="D"/>
                            <if-compare field-name="isCreditAccount" operator="equals" value="true" type="Boolean"/>
                        </and>
                        <and>
                            <if-compare field-name="acctgTransAndEntry.debitCreditFlag" operator="equals" value="C"/>
                            <if-compare field-name="isDebitAccount" operator="equals" value="true" type="Boolean"/>
                        </and>
                    </or>
                </condition>
                <then>
                    <calculate field-name="amount">
                        <calcop field-name="amount" operator="negative"/>
                    </calculate>
                </then>
            </if>
            <if-compare field-name="isExpenseAccount" operator="equals" value="true" type="Boolean">
                <calculate field-name="amount">
                    <calcop field-name="amount" operator="negative"/>
                </calculate>
            </if-compare>
            <calculate field-name="totalAmount" type="Double">
                <calcop field-name="totalAmount" operator="add"><calcop field-name="amount" operator="get"/></calcop>
            </calculate>
        </iterate>
        <entity-one entity-name="PartyAcctgPreference" value-name="partyAcctgPreference" use-cache="true" auto-field-map="false">
            <field-map field-name="partyId" env-name="customTimePeriod.organizationPartyId"/>
        </entity-one>
        <!-- get the profit and loss gl account id -->
        <entity-one entity-name="GlAccountTypeDefault" value-name="profitLossAccount" use-cache="true">
            <field-map field-name="organizationPartyId" env-name="customTimePeriod.organizationPartyId"/>
            <field-map field-name="glAccountTypeId" value="PROFIT_LOSS_ACCOUNT"/>
        </entity-one>
        <entity-one entity-name="GlAccountHistory" value-name="profitLossAccountHistory">
            <field-map field-name="organizationPartyId" env-name="customTimePeriod.organizationPartyId"/>
            <field-map field-name="customTimePeriodId" env-name="customTimePeriod.customTimePeriodId"/>
            <field-map field-name="glAccountId" env-name="profitLossAccount.glAccountId"/>
        </entity-one>
        <if-not-empty field-name="profitLossAccountHistory">
            <!-- already posted: verify if numbers match -->
            <call-class-method class-name="org.ofbiz.accounting.util.UtilAccounting" method-name="getNetBalance" ret-field-name="postedBalance">
                <field field-name="profitLossAccountHistory" type="GenericValue"/>
            </call-class-method>
            <if-compare-field field-name="postedBalance" operator="not-equals" to-field-name="totalAmount" type="Double">
                <add-error><fail-message message="There is already a posted balance [${postedBalance}] that doesn't match with the current one [${totalAmount}]."/></add-error>
            </if-compare-field>
            <check-errors/>
        <else>
            <make-value entity-name="AcctgTransEntry" value-name="creditEntry"/>
            <set field="creditEntry.debitCreditFlag" value="C"/>
            <set field="creditEntry.glAccountTypeId" value="RETAINED_EARNINGS"/>
            <set field="creditEntry.organizationPartyId" from-field="customTimePeriod.organizationPartyId"/>
            <set field="creditEntry.origAmount" from-field="totalAmount"/>
            <set field="creditEntry.origCurrencyUomId" from-field="partyAcctgPreference.baseCurrencyUomId"/>
            <set field="acctgTransEntries[]" from-field="creditEntry" type="Object"/>
            <make-value entity-name="AcctgTransEntry" value-name="debitEntry"/>
            <set field="debitEntry.debitCreditFlag" value="D"/>
            <set field="debitEntry.glAccountTypeId" value="PROFIT_LOSS_ACCOUNT"/>
            <set field="debitEntry.organizationPartyId" from-field="customTimePeriod.organizationPartyId"/>
            <set field="debitEntry.origAmount" from-field="totalAmount"/>
            <set field="debitEntry.origCurrencyUomId" from-field="partyAcctgPreference.baseCurrencyUomId"/>
            <set field="acctgTransEntries[]" from-field="debitEntry" type="Object"/>

            <set field="createAcctgTransAndEntriesInMap.glFiscalTypeId" value="ACTUAL"/>
            <set field="createAcctgTransAndEntriesInMap.acctgTransTypeId" value="PERIOD_CLOSING"/>
            <set field="createAcctgTransAndEntriesInMap.transactionDate" from-field="customTimePeriod.thruDate"/> <!-- FIXME -->
            <set field="createAcctgTransAndEntriesInMap.acctgTransEntries" from-field="acctgTransEntries"/>
            <call-service service-name="createAcctgTransAndEntries" in-map-name="createAcctgTransAndEntriesInMap">
                <result-to-field result-name="acctgTransId"/>
            </call-service>
        </else>
        </if-not-empty>
        <entity-and entity-name="GlAccountHistory" list-name="glAccountHistories">
            <field-map field-name="organizationPartyId" env-name="customTimePeriod.organizationPartyId"/>
            <field-map field-name="customTimePeriodId" env-name="customTimePeriod.customTimePeriodId"/>
        </entity-and>
        <iterate list-name="glAccountHistories" entry-name="glAccountHistory">
            <call-class-method class-name="org.ofbiz.accounting.util.UtilAccounting" method-name="getNetBalance" ret-field-name="endingBalance">
                <field field-name="glAccountHistory" type="GenericValue"/>
            </call-class-method>
            <set field="glAccountHistory.endingBalance" from-field="endingBalance" type="Double"/>
            <store-value value-name="glAccountHistory"/>
        </iterate>
        <if-not-empty field-name="lastClosedTimePeriod">
            <entity-condition entity-name="GlAccountAndHistory" list-name="lastPeriodGlAccountAndHistories">
                <condition-list combine="and">
                    <condition-expr field-name="organizationPartyId" operator="equals" env-name="customTimePeriod.organizationPartyId"/>
                    <condition-expr field-name="customTimePeriodId" operator="equals" env-name="lastClosedTimePeriod.customTimePeriodId"/>
                    <condition-list combine="or">
                        <condition-expr field-name="glAccountClassId" operator="in" env-name="assetAccountClassIds"/>
                        <condition-expr field-name="glAccountClassId" operator="in" env-name="liabilityAccountClassIds"/>
                        <condition-expr field-name="glAccountClassId" operator="in" env-name="equityAccountClassIds"/>
                    </condition-list>
                </condition-list>
                <order-by field-name="glAccountId"/>
            </entity-condition>
            <iterate list-name="lastPeriodGlAccountAndHistories" entry-name="lastPeriodGlAccountAndHistory">
                <get-related-one value-name="lastPeriodGlAccountAndHistory" relation-name="GlAccountHistory" to-value-name="lastPeriodGlAccountHistory"/>
                <entity-one entity-name="GlAccountHistory" value-name="thisPeriodGlAccountHistory" auto-field-map="false">
                    <field-map field-name="organizationPartyId" env-name="customTimePeriod.organizationPartyId"/>
                    <field-map field-name="customTimePeriodId" env-name="customTimePeriod.customTimePeriodId"/>
                    <field-map field-name="glAccountId" env-name="lastPeriodGlAccountHistory.glAccountId"/>
                </entity-one>
                <if-empty field-name="thisPeriodGlAccountHistory">
                    <make-value entity-name="GlAccountHistory" value-name="thisPeriodGlAccountHistory"/>
                    <set field="thisPeriodGlAccountHistory.customTimePeriodId" from-field="customTimePeriod.customTimePeriodId"/>
                    <set field="thisPeriodGlAccountHistory.organizationPartyId" from-field="customTimePeriod.organizationPartyId"/>
                    <set field="thisPeriodGlAccountHistory.glAccountId" from-field="lastPeriodGlAccountHistory.glAccountId"/>
                    <set field="thisPeriodGlAccountHistory.postedDebits" value="0.0" type="Double"/>
                    <set field="thisPeriodGlAccountHistory.postedCredits" value="0.0" type="Double"/>
                    <set field="thisPeriodGlAccountHistory.endingBalance" from-field="lastPeriodGlAccountHistory.endingBalance" type="Double"/>
                    <create-value value-name="thisPeriodGlAccountHistory"/>
                <else>
                    <calculate field-name="thisPeriodGlAccountHistory.endingBalance" type="Double">
                        <calcop field-name="thisPeriodGlAccountHistory.endingBalance" operator="add"><calcop field-name="lastPeriodGlAccountHistory.endingBalance" operator="get"/></calcop>
                    </calculate>
                    <store-value value-name="thisPeriodGlAccountHistory"/>
                </else>
                </if-empty>
            </iterate>
        </if-not-empty>

        <!-- Initialize the accounts for the new fiscal period -->
        <entity-condition entity-name="GlAccountOrganizationAndClass" list-name="glAccountOrganizationAndClassList">
            <condition-list combine="and">
                <condition-expr field-name="organizationPartyId" operator="equals" env-name="customTimePeriod.organizationPartyId"/>
                <condition-expr field-name="postedBalance" operator="not-equals" value="0.0"/>
                <condition-list combine="or">
                    <condition-expr field-name="glAccountClassId" operator="in" env-name="expenseAccountClassIds"/>
                    <condition-expr field-name="glAccountClassId" operator="in" env-name="revenueAccountClassIds"/>
                    <condition-expr field-name="glAccountClassId" operator="in" env-name="incomeAccountClassIds"/>
                </condition-list>
            </condition-list>
        </entity-condition>
        <now-timestamp-to-env env-name="nowTimestamp"/>
        <iterate list-name="glAccountOrganizationAndClassList" entry-name="glAccountOrganizationAndClass">
            <entity-condition entity-name="AcctgTransAndEntries" list-name="acctgTransAndEntries">
                <condition-list combine="and">
                    <condition-expr field-name="organizationPartyId" operator="equals" env-name="customTimePeriod.organizationPartyId"/>
                    <condition-expr field-name="glAccountId" operator="equals" env-name="glAccountOrganizationAndClass.glAccountId"/>
                    <condition-expr field-name="isPosted" operator="equals" value="Y"/>
                    <condition-expr field-name="glFiscalTypeId" operator="equals" value="ACTUAL"/>
                    <condition-expr field-name="transactionDate" operator="greater-equals" env-name="customTimePeriod.thruDate"/> <!-- FIXME: Date to Timestamp -->
                    <condition-expr field-name="transactionDate" operator="less" env-name="nowTimestamp"/>
                    <condition-expr field-name="acctgTransTypeId" operator="not-equals" value="PERIOD_CLOSING"/>
                </condition-list>
                <order-by field-name="acctgTransId"/>
                <order-by field-name="acctgTransEntrySeqId"/>
            </entity-condition>

            <set field="newPostedBalance" value="0.0" type="Double"/>
            <iterate list-name="acctgTransAndEntries" entry-name="acctgTransAndEntry">
                <get-related-one value-name="acctgTransAndEntry" relation-name="GlAccount" to-value-name="glAccount"/>
                <call-class-method class-name="org.ofbiz.accounting.util.UtilAccounting" method-name="isCreditAccount" ret-field-name="isCreditAccount">
                    <field field-name="glAccount" type="GenericValue"/>
                </call-class-method>
                <call-class-method class-name="org.ofbiz.accounting.util.UtilAccounting" method-name="isDebitAccount" ret-field-name="isDebitAccount">
                    <field field-name="glAccount" type="GenericValue"/>
                </call-class-method>
                <call-class-method class-name="org.ofbiz.accounting.util.UtilAccounting" method-name="isExpenseAccount" ret-field-name="isExpenseAccount">
                    <field field-name="glAccount" type="GenericValue"/>
                </call-class-method>
                <set field="amount" from-field="acctgTransAndEntry.amount" type="Double"/>
                <if>
                    <condition>
                        <or>
                            <and>
                                <if-compare field-name="acctgTransAndEntry.debitCreditFlag" operator="equals" value="D"/>
                                <if-compare field-name="isCreditAccount" operator="equals" value="true" type="Boolean"/>
                            </and>
                            <and>
                                <if-compare field-name="acctgTransAndEntry.debitCreditFlag" operator="equals" value="C"/>
                                <if-compare field-name="isDebitAccount" operator="equals" value="true" type="Boolean"/>
                            </and>
                        </or>
                    </condition>
                    <then>
                        <calculate field-name="amount">
                            <calcop field-name="amount" operator="negative"/>
                        </calculate>
                    </then>
                </if>
                <if-compare field-name="isExpenseAccount" operator="equals" value="true" type="Boolean">
                    <calculate field-name="amount">
                        <calcop field-name="amount" operator="negative"/>
                    </calculate>
                </if-compare>
                <calculate field-name="newPostedBalance" type="Double">
                    <calcop field-name="newPostedBalance" operator="add"><calcop field-name="amount" operator="get"/></calcop>
                </calculate>
            </iterate>

            <set field="updateGlAccountOrganizationInMap.organizationPartyId" from-field="customTimePeriod.organizationPartyId"/>
            <set field="updateGlAccountOrganizationInMap.glAccountId" from-field="glAccountOrganizationAndClass.glAccountId"/>
            <set field="updateGlAccountOrganizationInMap.postedBalance" from-field="newPostedBalance" type="Double"/>
            <call-service service-name="updateGlAccountOrganization" in-map-name="updateGlAccountOrganizationInMap"/>
        </iterate>

        <set field="updateCustomTimePeriodInMap.customTimePeriodId" from-field="customTimePeriod.customTimePeriodId"/>
        <set field="updateCustomTimePeriodInMap.organizationPartyId" from-field="customTimePeriod.organizationPartyId"/>
        <set field="updateCustomTimePeriodInMap.isClosed" value="Y"/>
        <call-service service-name="updateCustomTimePeriod" in-map-name="updateCustomTimePeriodInMap"/>
    </simple-method>

    <simple-method method-name="prepareIncomeStatement" short-description="Close a financial CustomTimePeriod">
        <entity-one entity-name="GlAccountClass" value-name="expenseGlAccountClass">
            <field-map field-name="glAccountClassId" value="EXPENSE"/>
        </entity-one>
        <call-class-method class-name="org.ofbiz.accounting.util.UtilAccounting" method-name="getDescendantGlAccountClassIds" ret-field-name="expenseAccountClassIds">
            <field field-name="expenseGlAccountClass" type="GenericValue"/>
        </call-class-method>
        <entity-one entity-name="GlAccountClass" value-name="revenueGlAccountClass">
            <field-map field-name="glAccountClassId" value="REVENUE"/>
        </entity-one>
        <call-class-method class-name="org.ofbiz.accounting.util.UtilAccounting" method-name="getDescendantGlAccountClassIds" ret-field-name="revenueAccountClassIds">
            <field field-name="revenueGlAccountClass" type="GenericValue"/>
        </call-class-method>
        <entity-one entity-name="GlAccountClass" value-name="incomeGlAccountClass">
            <field-map field-name="glAccountClassId" value="INCOME"/>
        </entity-one>
        <call-class-method class-name="org.ofbiz.accounting.util.UtilAccounting" method-name="getDescendantGlAccountClassIds" ret-field-name="incomeAccountClassIds">
            <field field-name="incomeGlAccountClass" type="GenericValue"/>
        </call-class-method>
        <entity-condition entity-name="AcctgTransAndEntries" list-name="acctgTransAndEntries">
            <condition-list combine="and">
                <condition-expr field-name="organizationPartyId" operator="equals" env-name="parameters.organizationPartyId"/>
                <condition-expr field-name="isPosted" operator="equals" value="Y"/>
                <condition-expr field-name="glFiscalTypeId" operator="equals" env-name="parameters.glFiscalTypeId"/>
                <condition-expr field-name="transactionDate" operator="greater-equals" env-name="parameters.fromDate"/>
                <condition-expr field-name="transactionDate" operator="less" env-name="parameters.thruDate"/> <!-- FIXME: Date to Timestamp -->
                <condition-expr field-name="acctgTransTypeId" operator="not-equals" value="PERIOD_CLOSING"/>
                <condition-list combine="or">
                    <condition-expr field-name="glAccountClassId" operator="in" env-name="expenseAccountClassIds"/>
                    <condition-expr field-name="glAccountClassId" operator="in" env-name="revenueAccountClassIds"/>
                    <condition-expr field-name="glAccountClassId" operator="in" env-name="incomeAccountClassIds"/>
                </condition-list>
            </condition-list>
            <order-by field-name="acctgTransId"/>
            <order-by field-name="acctgTransEntrySeqId"/>
        </entity-condition>
        <set field="totalNetIncome" value="0.0" type="Double"/>
        <iterate list-name="acctgTransAndEntries" entry-name="acctgTransAndEntry">
            <get-related-one value-name="acctgTransAndEntry" relation-name="GlAccount" to-value-name="glAccount"/>
            <call-class-method class-name="org.ofbiz.accounting.util.UtilAccounting" method-name="isCreditAccount" ret-field-name="isCreditAccount">
                <field field-name="glAccount" type="GenericValue"/>
            </call-class-method>
            <call-class-method class-name="org.ofbiz.accounting.util.UtilAccounting" method-name="isDebitAccount" ret-field-name="isDebitAccount">
                <field field-name="glAccount" type="GenericValue"/>
            </call-class-method>
            <call-class-method class-name="org.ofbiz.accounting.util.UtilAccounting" method-name="isExpenseAccount" ret-field-name="isExpenseAccount">
                <field field-name="glAccount" type="GenericValue"/>
            </call-class-method>
            <set field="amount" from-field="acctgTransAndEntry.amount" type="Double"/>
            <if>
                <condition>
                    <or>
                        <and>
                            <if-compare field-name="acctgTransAndEntry.debitCreditFlag" operator="equals" value="D"/>
                            <if-compare field-name="isCreditAccount" operator="equals" value="true" type="Boolean"/>
                        </and>
                        <and>
                            <if-compare field-name="acctgTransAndEntry.debitCreditFlag" operator="equals" value="C"/>
                            <if-compare field-name="isDebitAccount" operator="equals" value="true" type="Boolean"/>
                        </and>
                    </or>
                </condition>
                <then>
                    <calculate field-name="amount">
                        <calcop field-name="amount" operator="negative"/>
                    </calculate>
                </then>
            </if>
            <if-compare field-name="isExpenseAccount" operator="equals" value="true" type="Boolean">
                <calculate field-name="amount">
                    <calcop field-name="amount" operator="negative"/>
                </calculate>
            </if-compare>
            <calculate field-name="totalNetIncome" type="Double">
                <calcop field-name="totalNetIncome" operator="add"><calcop field-name="amount" operator="get"/></calcop>
            </calculate>
            <if-empty field-name="glAccountTotalsMap.${glAccount.glAccountId}">
                <set field="glAccountTotalsMap.${glAccount.glAccountId}" value="0.0" type="Double"/>
            </if-empty>
            <calculate field-name="glAccountTotalsMap.${glAccount.glAccountId}" type="Double">
                <calcop field-name="glAccountTotalsMap.${glAccount.glAccountId}" operator="add"><calcop field-name="amount" operator="get"/></calcop>
            </calculate>
        </iterate>
        <iterate-map map-name="glAccountTotalsMap" key-name="glAccountId" value-name="totalAmount">
            <clear-field field-name="glAccountTotalMap"/>
            <set field="glAccountTotalMap.glAccountId" from-field="glAccountId"/>
            <set field="glAccountTotalMap.totalAmount" from-field="totalAmount"/>
            <set field="glAccountTotalsList[]" from-field="glAccountTotalMap"/>
        </iterate-map>
        <set field="orderByList[]" value="glAccountId"/>
        <order-value-list list-name="glAccountTotalsList" order-by-list-name="orderByList"/>

        <field-to-result field-name="totalNetIncome" result-name="totalNetIncome"/>
        <field-to-result field-name="glAccountTotalsMap" result-name="glAccountTotalsMap"/>
        <field-to-result field-name="glAccountTotalsList" result-name="glAccountTotalsList"/>
    </simple-method>

    <!-- Services for the automatic creation of accounting transactions based on business transactions
         Typically, these services are triggered by SECAs -->

    <simple-method method-name="createAcctgTransForSalesShipmentIssuance" short-description="Create an accounting transactions for a sales shipment issuance (D: INVENTORY_ACCOUNT, C: COGS_ACCOUNT)">
        <!-- retrieve ledger rounding properties -->
        <property-to-field resource="arithmetic" property="ledger.decimals" field-name="ledgerDecimals"/>
        <property-to-field resource="arithmetic" property="ledger.rounding" field-name="roundingMode"/>
        <log level="info" message="Using ledger decimals [${ledgerDecimals}] and rounding [${roundingMode}]"/>

        <entity-one entity-name="ItemIssuance" value-name="itemIssuance"/>
        <get-related-one value-name="itemIssuance" relation-name="InventoryItem" to-value-name="inventoryItem"/>
        <entity-and entity-name="OrderRole" list-name="billToCustomers">
            <field-map field-name="orderId" env-name="itemIssuance.orderId"/>
            <field-map field-name="roleTypeId" value="BILL_TO_CUSTOMER"/>
        </entity-and>
        <first-from-list list-name="billToCustomers" entry-name="billToCustomer"/>
        <!-- TODO: handle serialized inventory -->
        <calculate field-name="origAmount" type="BigDecimal" decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
            <calcop operator="multiply">
                <calcop operator="get" field-name="itemIssuance.quantity"/>
                <calcop operator="get" field-name="inventoryItem.unitCost"/>
            </calcop>
        </calculate>
        <!-- prepare the doble posting (D/C) entries (AcctgTransEntry) -->
        <!-- Credit -->
        <make-value entity-name="AcctgTransEntry" value-name="creditEntry"/>
        <set field="creditEntry.debitCreditFlag" value="C"/>
        <set field="creditEntry.glAccountTypeId" value="INVENTORY_ACCOUNT"/>
        <set field="creditEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
        <set field="creditEntry.productId" from-field="inventoryItem.productId"/>
        <set field="creditEntry.origAmount" from-field="origAmount"/>
        <set field="creditEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
        <if-not-empty field-name="billToCustomer">
            <set field="creditEntry.partyId" from-field="billToCustomer.partyId"/>
            <set field="creditEntry.roleTypeId" from-field="billToCustomer.roleTypeId"/>
        </if-not-empty>
        <set field="acctgTransEntries[]" from-field="creditEntry" type="Object"/>
        <!-- Debit -->
        <make-value entity-name="AcctgTransEntry" value-name="debitEntry"/>
        <set field="debitEntry.debitCreditFlag" value="D"/>
        <set field="debitEntry.glAccountTypeId" value="COGS_ACCOUNT"/>
        <set field="debitEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
        <set field="debitEntry.productId" from-field="inventoryItem.productId"/>
        <set field="debitEntry.origAmount" from-field="origAmount"/>
        <set field="debitEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
        <if-not-empty field-name="billToCustomer">
            <set field="debitEntry.partyId" from-field="billToCustomer.partyId"/>
            <set field="debitEntry.roleTypeId" from-field="billToCustomer.roleTypeId"/>
        </if-not-empty>
        <set field="acctgTransEntries[]" from-field="debitEntry" type="Object"/>
        <!-- Set header fields (AcctgTrans) -->
        <set field="createAcctgTransAndEntriesInMap.glFiscalTypeId" value="ACTUAL"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransTypeId" value="SALES_SHIPMENT"/>
        <set field="createAcctgTransAndEntriesInMap.shipmentId" from-field="itemIssuance.shipmentId"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransEntries" from-field="acctgTransEntries"/>
        <call-service service-name="createAcctgTransAndEntries" in-map-name="createAcctgTransAndEntriesInMap">
            <result-to-field result-name="acctgTransId"/>
        </call-service>
        <field-to-result field-name="acctgTransId" result-name="acctgTransId"/>
    </simple-method>

    <simple-method method-name="createAcctgTransForShipmentReceipt" short-description="Create an accounting transactions for a shipment receipt (D: INVENTORY_ACCOUNT, C: UNINVOICED_SHIP_RCPT or COGS_ACCOUNT for returns)">
        <!-- retrieve ledger rounding properties -->
        <property-to-field resource="arithmetic" property="ledger.decimals" field-name="ledgerDecimals"/>
        <property-to-field resource="arithmetic" property="ledger.rounding" field-name="roundingMode"/>
        <log level="info" message="Using ledger decimals [${ledgerDecimals}] and rounding [${roundingMode}]"/>

        <entity-one entity-name="ShipmentReceipt" value-name="shipmentReceipt"/>
        <get-related-one value-name="shipmentReceipt" relation-name="InventoryItem" to-value-name="inventoryItem"/>
        <get-related-one value-name="shipmentReceipt" relation-name="Shipment" to-value-name="shipment"/>
        <if-not-empty field-name="shipmentReceipt.returnId">
            <set field="creditAccountTypeId" value="COGS_ACCOUNT"/>
        <else>
            <set field="creditAccountTypeId" value="UNINVOICED_SHIP_RCPT"/>
        </else>
        </if-not-empty>
        <!-- TODO: handle serialized inventory -->
        <calculate field-name="origAmount" type="BigDecimal" decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
            <calcop operator="multiply">
                <calcop operator="get" field-name="shipmentReceipt.quantityAccepted"/>
                <calcop operator="get" field-name="inventoryItem.unitCost"/>
            </calcop>
        </calculate>
        <!-- prepare the doble posting (D/C) entries (AcctgTransEntry) -->
        <!-- Credit -->
        <make-value entity-name="AcctgTransEntry" value-name="creditEntry"/>
        <set field="creditEntry.debitCreditFlag" value="C"/>
        <set field="creditEntry.glAccountTypeId" from-field="creditAccountTypeId"/>
        <set field="creditEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
        <set field="creditEntry.partyId" from-field="shipment.partyIdFrom"/>
        <set field="creditEntry.roleTypeId" value="BILL_FROM_VENDOR"/>
        <set field="creditEntry.productId" from-field="inventoryItem.productId"/>
        <set field="creditEntry.origAmount" from-field="origAmount"/>
        <set field="creditEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
        <set field="acctgTransEntries[]" from-field="creditEntry" type="Object"/>
        <!-- Debit -->
        <make-value entity-name="AcctgTransEntry" value-name="debitEntry"/>
        <set field="debitEntry.debitCreditFlag" value="D"/>
        <set field="debitEntry.glAccountTypeId" value="INVENTORY_ACCOUNT"/>
        <set field="debitEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
        <set field="debitEntry.partyId" from-field="shipment.partyIdFrom"/>
        <set field="debitEntry.roleTypeId" value="BILL_FROM_VENDOR"/>
        <set field="debitEntry.productId" from-field="inventoryItem.productId"/>
        <set field="debitEntry.origAmount" from-field="origAmount"/>
        <set field="debitEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
        <set field="acctgTransEntries[]" from-field="debitEntry" type="Object"/>
        <!-- Set header fields (AcctgTrans) -->
        <set field="createAcctgTransAndEntriesInMap.glFiscalTypeId" value="ACTUAL"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransTypeId" value="SHIPMENT_RECEIPT"/>
        <set field="createAcctgTransAndEntriesInMap.shipmentId" from-field="shipmentReceipt.shipmentId"/>
        <set field="createAcctgTransAndEntriesInMap.partyId" from-field="shipment.partyIdFrom"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransEntries" from-field="acctgTransEntries"/>
        <call-service service-name="createAcctgTransAndEntries" in-map-name="createAcctgTransAndEntriesInMap">
            <result-to-field result-name="acctgTransId"/>
        </call-service>
        <field-to-result field-name="acctgTransId" result-name="acctgTransId"/>        
    </simple-method>

    <simple-method method-name="createAcctgTransForInventoryItemCostChange" short-description="Create accounting transaction when item cost is changed (D: INV_ADJ_VAL, C: INVENTORY_ACCOUNT)">
        <!-- retrieve ledger rounding properties -->        
        <property-to-field resource="arithmetic" property="ledger.decimals" field-name="ledgerDecimals"/>
        <property-to-field resource="arithmetic" property="ledger.rounding" field-name="roundingMode"/>
        <entity-one entity-name="InventoryItemDetail" value-name="newInventoryItemDetail"/>
        <entity-condition entity-name="InventoryItemDetail" list-name="inventoryItemDetails">
            <condition-list>
                <condition-expr field-name="inventoryItemId" operator="equals" env-name="newInventoryItemDetail.inventoryItemId"/>
                <condition-expr field-name="unitCost" operator="not-equals" env-name="nullField"/>
                <condition-expr field-name="inventoryItemDetailSeqId" operator="not-equals" env-name="parameters.inventoryItemDetailSeqId"/>
            </condition-list>
            <order-by field-name="-effectiveDate"/>
        </entity-condition>
        <first-from-list list-name="inventoryItemDetails" entry-name="oldInventoryItemDetail"/>
        <if-not-empty field-name="oldInventoryItemDetail">
            <calculate field-name="origAmount" type="BigDecimal" decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
                <calcop operator="multiply" field-name="newinventoryItem.quantityOnHandTotal">
                    <calcop operator="subtract">
                        <calcop operator="get" field-name="oldInventoryItemDetail.unitCost"/>
                        <calcop operator="get" field-name="newInventoryItemDetail.unitCost"/>
                    </calcop>
                </calcop>
            </calculate>
            <get-related-one value-name="newInventoryItemDetail" relation-name="InventoryItem" to-value-name="inventoryItem"/>
            <!-- Credit -->
            <make-value entity-name="AcctgTransEntry" value-name="creditEntry"/>
            <set field="creditEntry.debitCreditFlag" value="C"/>
            <set field="creditEntry.glAccountTypeId" value="INVENTORY_ACCOUNT"/>
            <set field="creditEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
            <set field="creditEntry.productId" from-field="inventoryItem.productId"/>
            <set field="creditEntry.origAmount" from-field="origAmount"/>
            <set field="creditEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
            <!-- Debit -->
            <make-value entity-name="AcctgTransEntry" value-name="debitEntry"/>
            <set field="debitEntry.debitCreditFlag" value="D"/>
            <set field="debitEntry.glAccountTypeId" value="INV_ADJ_VAL"/>
            <set field="debitEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
            <set field="debitEntry.productId" from-field="inventoryItem.productId"/>
            <set field="debitEntry.origAmount" from-field="origAmount"/>
            <set field="debitEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>

            <set field="acctgTransEntries[]" from-field="creditEntry" type="Object"/>
            <set field="acctgTransEntries[]" from-field="debitEntry" type="Object"/>

            <set field="createAcctgTransAndEntriesInMap.glFiscalTypeId" value="ACTUAL"/>
            <set field="createAcctgTransAndEntriesInMap.acctgTransTypeId" value="INVENTORY"/>
            <set field="createAcctgTransAndEntriesInMap.shipmentId" from-field="parameters.InventoryItemId"/>
            <set field="createAcctgTransAndEntriesInMap.acctgTransEntries" from-field="acctgTransEntries"/>
            <call-service service-name="createAcctgTransAndEntries" in-map-name="createAcctgTransAndEntriesInMap">
                <result-to-field result-name="acctgTransId"/>
            </call-service>
            <field-to-result field-name="acctgTransId" result-name="acctgTransId"/>
        </if-not-empty>
    </simple-method>

    <simple-method method-name="createAcctgTransForPhysicalInventoryVariance" short-description="Create an Account Transaction For Physical Inventory Variance">
        <!-- retrieve ledger rounding properties -->  
        <property-to-field resource="arithmetic" property="ledger.decimals" field-name="ledgerDecimals"/>
        <property-to-field resource="arithmetic" property="ledger.rounding" field-name="roundingMode"/>
        <entity-and entity-name="InventoryItemDetail" list-name="inventoryItemDetails">
            <field-map field-name="physicalInventoryId" env-name="parameters.physicalInventoryId"/>
            <order-by field-name="inventoryItemId"/>
        </entity-and>
        <iterate list-name="inventoryItemDetails" entry-name="inventoryItemDetail">
            <get-related-one value-name="inventoryItemDetail" relation-name="InventoryItem" to-value-name="inventoryItem"/>        
            <calculate field-name="origAmount" type="BigDecimal" decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
                <calcop operator="multiply">
                    <calcop operator="get" field-name="inventoryItemDetail.quantityOnHandDiff"/>
                    <calcop operator="get" field-name="inventoryItem.unitCost "/>
                </calcop>
            </calculate>
            <!-- Credit Entries -->
            <make-value entity-name="AcctgTransEntry" value-name="creditEntry"/>
            <set field="creditEntry.debitCreditFlag" value="C"/>
            <set field="creditEntry.glAccountTypeId" from-field="inventoryItemDetail.reasonEnumId"/>
            <set field="creditEntry.productId" from-field="inventoryItem.productId"/>
            <set field="creditEntry.origAmount" from-field="origAmount"/>
            <set field="creditEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
            <set field="creditEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
            <!-- Debit Entries-->
            <make-value entity-name="AcctgTransEntry" value-name="debitEntry"/>
            <set field="debitEntry.debitCreditFlag" value="D"/>
            <set field="debitEntry.glAccountTypeId" value="INVENTORY_ACCOUNT"/>
            <set field="debitEntry.productId" from-field="inventoryItem.productId"/>
            <set field="debitEntry.origAmount" from-field="origAmount"/>
            <set field="debitEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
            <set field="debitEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
            <set field="acctgTransEntries[]" from-field="creditEntry" type="Object"/>
            <set field="acctgTransEntries[]" from-field="debitEntry" type="Object"/>            
        </iterate>
        <set field="createAcctgTransAndEntriesInMap.glFiscalTypeId" value="ACTUAL"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransEntries" from-field="acctgTransEntries"/>
        <set field="createAcctgTransAndEntriesInMap.physicalInventoryId" from-field="parameters.physicalInventoryId"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransTypeId" value="ITEM_VARIANCE"/>
        <call-service service-name="createAcctgTransAndEntries" in-map-name="createAcctgTransAndEntriesInMap">
            <result-to-field result-name="acctgTransId"/>
        </call-service>
        <field-to-result field-name="acctgTransId" result-name="acctgTransId"/>
   </simple-method>

   <simple-method method-name="createAcctgTransForWorkEffortInventoryProduced" short-description="Create an accounting transactions for a Work Effort Inventory Produced (D: INVENTORY_ACCOUNT, C: WIP_INVENTORY)">
        <!-- retrieve ledger rounding properties -->
        <property-to-field resource="arithmetic" property="ledger.decimals" field-name="ledgerDecimals"/>
        <property-to-field resource="arithmetic" property="ledger.rounding" field-name="roundingMode"/>
        <log level="info" message="Using ledger decimals [${ledgerDecimals}] and rounding [${roundingMode}]"/>
        <entity-one entity-name="WorkEffortInventoryProduced" value-name="workEffortInventoryProduced">
            <field-map field-name="workEffortId" env-name="parameters.workEffortId"/>
            <field-map field-name="inventoryItemId" env-name="parameters.inventoryItemId"/>
        </entity-one>
        <get-related-one value-name="workEffortInventoryProduced" relation-name="InventoryItem" to-value-name="inventoryItem"/>  
        <!-- TODO: handle serialized inventory -->
        <calculate field-name="origAmount" type="BigDecimal" decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
            <calcop operator="multiply">
                <calcop operator="get" field-name="inventoryItem.quantityOnHandTotal"/>
                <calcop operator="get" field-name="inventoryItem.unitCost"/>
            </calcop>
        </calculate>
        <!-- prepare the doble posting (D/C) entries (AcctgTransEntry) -->
        <!-- Credit -->
        <make-value entity-name="AcctgTransEntry" value-name="creditEntry"/>
        <set field="creditEntry.debitCreditFlag" value="C"/>
        <set field="creditEntry.glAccountTypeId" value="WIP_INVENTORY"/>
        <set field="creditEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
        <set field="creditEntry.productId" from-field="inventoryItem.productId"/>
        <set field="creditEntry.origAmount" from-field="origAmount"/>
        <set field="creditEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
        <set field="acctgTransEntries[]" from-field="creditEntry" type="Object"/>
        <!-- Debit -->
        <make-value entity-name="AcctgTransEntry" value-name="debitEntry"/>
        <set field="debitEntry.debitCreditFlag" value="D"/>
        <set field="debitEntry.glAccountTypeId" value="INVENTORY_ACCOUNT"/>
        <set field="debitEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
        <set field="debitEntry.productId" from-field="inventoryItem.productId"/>
        <set field="debitEntry.origAmount" from-field="origAmount"/>
        <set field="debitEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>        
        <set field="acctgTransEntries[]" from-field="debitEntry" type="Object"/>
        <!-- Set header fields (AcctgTrans) -->
        <set field="createAcctgTransAndEntriesInMap.glFiscalTypeId" value="ACTUAL"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransTypeId" value="INVENTORY"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransEntries" from-field="acctgTransEntries"/>
        <call-service service-name="createAcctgTransAndEntries" in-map-name="createAcctgTransAndEntriesInMap">
            <result-to-field result-name="acctgTransId"/>
        </call-service>
        <field-to-result field-name="acctgTransId" result-name="acctgTransId"/>        
    </simple-method>            

    <simple-method method-name="createAcctgTransForWorkEffortCost"
               short-description="Create an accounting transaction for inventory that is issued to a work effort cost (Type: INVENTORY D: INVENTORY_ACCOUNT , C: UNINVOICED_SHIP_RCPT or COGS_ACCOUNT)">
        <entity-one entity-name="CostComponent" value-name="costComponent">
            <field-map field-name="costComponentId" env-name="parameters.costComponentId"/>
        </entity-one>
        <get-related-one value-name="costComponent" relation-name="CostComponentCalc" to-value-name="costComponentCalc"/>    
        <entity-one entity-name="WorkEffort" value-name="workEffort">
            <field-map field-name="workEffortId" env-name="parameters.workEffortId"/>
        </entity-one>
        <get-related-one value-name="workEffort" relation-name="Facility"  to-value-name="facility"/>
        <if-compare field-name="workEffort.workEffortTypeId" operator="equals" value="PROD_ORDER_TASK">
            <if-not-empty field-name="workEffort.workEffortParentId">
                <entity-and entity-name="WorkEffortGoodStandard" list-name="workEffortGoodStandards">
                    <field-map field-name="workEffortId" env-name="workEffort.workEffortParentId"/>
                    <field-map field-name="workEffortGoodStdTypeId" value="PRUN_PROD_DELIV"/>
                    <order-by field-name="-fromDate"/>
                </entity-and>
               <first-from-list list-name="workEffortGoodStandards" entry-name="workEffortGoodStandard"/>
            </if-not-empty>
        </if-compare>   
        <!-- Credit -->
        <make-value entity-name="AcctgTransEntry" value-name="creditEntry"/>
        <set field="creditEntry.debitCreditFlag" value="C"/>
        <set field="creditEntry.glAccountTypeId" value="costComponentCalc.costGlAccountTypeId"/>
        <set field="creditEntry.organizationPartyId" from-field="facility.ownerPartyId"/>
        <set field="creditEntry.productId" from-field="workEffortGoodStandard.productId"/>
        <set field="creditEntry.origAmount" from-field="costComponent.cost"/>
        <set field="creditEntry.origCurrencyUomId" from-field="facility.currencyUomId"/>        
        <set field="acctgTransEntries[]" from-field="creditEntry" type="Object"/>
        <!-- Debit -->
        <make-value entity-name="AcctgTransEntry" value-name="debitEntry"/>
        <set field="debitEntry.debitCreditFlag" value="D"/>
        <if-not-empty field-name="costComponentCalc.offsettingGlAccountTypeId">
            <set field="debitEntry.glAccountTypeId" value="costComponentCalc.offsettingGlAccountTypeId"/>
        <else>
            <set field="debitEntry.glAccountTypeId" value="WIP_INVENTORY"/>
        </else>
        </if-not-empty>
        <set field="debitEntry.organizationPartyId" from-field="facility.ownerPartyId"/>
        <set field="debitEntry.productId" from-field="workEffortGoodStandard.productId"/>
        <set field="debitEntry.origAmount" from-field="costComponent.cost"/>
        <set field="debitEntry.origCurrencyUomId" from-field="facility.currencyUomId"/>        
        <set field="acctgTransEntries[]" from-field="debitEntry" type="Object"/>
        <!-- Set header fields (AcctgTrans) -->
        <set field="createAcctgTransAndEntriesInMap.glFiscalTypeId" value="ACTUAL"/>
        <set field="createAcctgTransAndEntriesInMap.workEffortId" from-field="parameters.workEffortId"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransTypeId" value="MANUFACTURING"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransEntries" from-field="acctgTransEntries"/>
        <call-service service-name="createAcctgTransAndEntries" in-map-name="createAcctgTransAndEntriesInMap">
            <result-to-field result-name="acctgTransId"/>
        </call-service>
        <field-to-result field-name="acctgTransId" result-name="acctgTransId"/>
    </simple-method>

    <!-- AcctgTrans For Inventory Item Owner Change Service -->
    <simple-method method-name="createAcctgTransForInventoryItemOwnerChange" short-description="Create an accounting transactions for Inventory Item Owner Change (D: INVENTORY_ACCOUNT(old Owner) INVENTORY_ACCOUNT(new Owner), C: INVENTORY_XFER_IN(oldOwner) INVENTORY_XFER_OUT(new Owner))">
        <!-- retrieve ledger rounding properties -->
        <property-to-field resource="arithmetic" property="ledger.decimals" field-name="ledgerDecimals"/>
        <property-to-field resource="arithmetic" property="ledger.rounding" field-name="roundingMode"/>
        <log level="info" message="Using ledger decimals [${ledgerDecimals}] and rounding [${roundingMode}]"/>
 
        <entity-one entity-name="InventoryItem" value-name="inventoryItem"/>
        
        <!-- TODO: handle serialized inventory -->
        <if-not-empty field-name="inventoryItem.quantityOnHandTotal">
            <calculate field-name="origAmount" type="BigDecimal" decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
                <calcop operator="multiply">
                    <calcop operator="get" field-name="inventoryItem.quantityOnHandTotal"/>
                    <calcop operator="get" field-name="inventoryItem.unitCost"/>
                </calcop>
            </calculate>
        </if-not-empty>
        <!-- prepare the doble posting (D/C) entries (AcctgTransEntry) for old OwnerPartyId  -->
        <!-- Credit -->
        <make-value entity-name="AcctgTransEntry" value-name="oldPartyCreditEntry"/>
        <set field="oldPartyCreditEntry.debitCreditFlag" value="C"/>
        <set field="oldPartyCreditEntry.glAccountTypeId" value="INVENTORY_XFER_IN"/>
        <set field="oldPartyCreditEntry.productId" from-field="inventoryItem.productId"/>
        <set field="oldPartyCreditEntry.origAmount" from-field="origAmount"/>
        <set field="oldPartyCreditEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
        <set field="oldPartyCreditEntry.organizationPartyId" from-field="parameters.oldOwnerPartyId"/>
                
        <!-- Debit -->
        <make-value entity-name="AcctgTransEntry" value-name="oldPartyDebitEntry"/>
        <set field="oldPartyDebitEntry.debitCreditFlag" value="D"/>
        <set field="oldPartyDebitEntry.productId" from-field="inventoryItem.productId"/>
        <set field="oldPartyDebitEntry.origAmount" from-field="origAmount"/>
        <set field="oldPartyDebitEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
        <set field="oldPartyDebitEntry.organizationPartyId" from-field="parameters.oldOwnerPartyId"/>
        <set field="oldPartyDebitEntry.glAccountTypeId" value="INVENTORY_ACCOUNT"/>
        <!-- prepare the doble posting (D/C) entries (AcctgTransEntry) for New ownerPartyId -->
        <!-- Credit -->
        <make-value entity-name="AcctgTransEntry" value-name="newPartyCreditEntry"/>
        <set field="newPartyCreditEntry.debitCreditFlag" value="C"/>
        <set field="newPartyCreditEntry.glAccountTypeId" value="INVENTORY_XFER_IN"/>
        <set field="newPartyCreditEntry.productId" from-field="inventoryItem.productId"/>
        <set field="newPartyCreditEntry.origAmount" from-field="origAmount"/>
        <set field="newPartyCreditEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
        <set field="newPartyCreditEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
                
        <!-- Debit -->
        <make-value entity-name="AcctgTransEntry" value-name="newPartyDebitEntry"/>
        <set field="newPartyDebitEntry.debitCreditFlag" value="D"/>
        <set field="newPartyDebitEntry.productId" from-field="inventoryItem.productId"/>
        <set field="newPartyDebitEntry.origAmount" from-field="origAmount"/>
        <set field="newPartyDebitEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
        <set field="newPartyDebitEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
        <set field="newPartyDebitEntry.glAccountTypeId" value="INVENTORY_ACCOUNT"/>

        <set field="acctgTransEntries[]" from-field="oldPartyCreditEntry" type="Object"/>
        <set field="acctgTransEntries[]" from-field="oldPartyDebitEntry" type="Object"/>
        <set field="acctgTransEntries[]" from-field="newPartyCreditEntry" type="Object"/>
        <set field="acctgTransEntries[]" from-field="newPartyDebitEntry" type="Object"/>
        
        <!-- Set header fields (AcctgTrans) -->
        
        <set field="createAcctgTransAndEntriesInMap.acctgTransTypeId" value="INVENTORY"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransEntries" from-field="acctgTransEntries"/>
        <set field="createAcctgTransAndEntriesInMap.inventoryItemId" from-field="parameters.inventoryItemId"/>
        <set field="createAcctgTransAndEntriesInMap.glFiscalTypeId" value="ACTUAL"/>
        <call-service service-name="createAcctgTransAndEntries" in-map-name="createAcctgTransAndEntriesInMap">
            <result-to-field result-name="acctgTransId"/>
        </call-service>
        <field-to-result field-name="acctgTransId" result-name="acctgTransId"/>
    </simple-method>
    <!--automatic GL posting service triggered when inventory is issued to a work effort-->
  
    <simple-method method-name="createAcctgTransForWorkEffortIssuance" short-description="Create an accounting transaction for inventory that is issued to a work effort (Type: INVENTORY D: RAWMAT_INVENTORY, C: WIP_INVENTORY)">
        <!-- retrieve ledger rounding properties -->
        <property-to-field resource="arithmetic" property="ledger.decimals" field-name="ledgerDecimals"/>
        <property-to-field resource="arithmetic" property="ledger.rounding" field-name="roundingMode"/>
        <log level="info" message="Using ledger decimals [${ledgerDecimals}] and rounding [${roundingMode}]"/>
        <entity-one entity-name="WorkEffort" value-name="workEffort">
            <field-map field-name="workEffortId" env-name="parameters.workEffortId"/>
        </entity-one>
        <if-compare field-name="workEffort.workEffortTypeId" operator="equals" value="PROD_ORDER_TASK">
            <if-not-empty field-name="workEffort.workEffortParentId">
                <entity-and entity-name="WorkEffortGoodStandard" list-name="workEffortGoodStandards">
                    <field-map field-name="workEffortId" env-name="workEffort.workEffortParentId"/>
                    <field-map field-name="workEffortGoodStdTypeId" value="PRUN_PROD_DELIV"/>
                    <order-by field-name="-fromDate"/>
                </entity-and>
               <first-from-list list-name="workEffortGoodStandards" entry-name="workEffortGoodStandard"/>
            </if-not-empty>
        </if-compare>
        <entity-one entity-name="WorkEffortInventoryAssign" value-name="workEffortInventoryAssign">
            <field-map field-name="workEffortId" env-name="parameters.workEffortId"/>
            <field-map field-name="inventoryItemId" env-name="parameters.inventoryItemId"/>
        </entity-one>        
        <get-related-one value-name="workEffortInventoryAssign" relation-name="InventoryItem" to-value-name="inventoryItem"/>
        <!-- TODO: handle serialized inventory -->
        <calculate field-name="origAmount" type="BigDecimal" decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
            <calcop operator="multiply">
                <calcop operator="get" field-name="workEffortInventoryAssign.quantity"/>
                <calcop operator="get" field-name="inventoryItem.unitCost"/>
            </calcop>
        </calculate>
        <!--Credit -->
        <make-value entity-name="AcctgTransEntry" value-name="creditEntry"/>
        <set field="creditEntry.debitCreditFlag" value="C"/>
        <set field="creditEntry.glAccountTypeId" value="WIP_INVENTORY"/>
        <set field="creditEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
        <set field="creditEntry.productId" from-field="workEffortGoodStandard.productId"/>
        <set field="creditEntry.origAmount" from-field="origAmount"/>
        <set field="creditEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>        
        <set field="acctgTransEntries[]" from-field="creditEntry" type="Object"/>
        <!-- Debit -->
        <make-value entity-name="AcctgTransEntry" value-name="debitEntry"/>
        <set field="debitEntry.debitCreditFlag" value="D"/>
        <set field="debitEntry.glAccountTypeId" value="RAWMAT_INVENTORY"/>
        <set field="debitEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
        <set field="debitEntry.productId" from-field="inventoryItem.productId"/>
        <set field="debitEntry.origAmount" from-field="origAmount"/>
        <set field="debitEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>        
        <set field="acctgTransEntries[]" from-field="debitEntry" type="Object"/>
        <!-- Set header fields (AcctgTrans) -->
        <set field="createAcctgTransAndEntriesInMap.glFiscalTypeId" value="ACTUAL"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransTypeId" value="INVENTORY"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransEntries" from-field="acctgTransEntries"/>
        <call-service service-name="createAcctgTransAndEntries" in-map-name="createAcctgTransAndEntriesInMap">
            <result-to-field result-name="acctgTransId"/>
        </call-service>
        <field-to-result field-name="acctgTransId" result-name="acctgTransId"/>        
    </simple-method>

    <!-- Service for the automatic creation of accounting transaction for inventory that is issued for fixed asset maintenance -->
    <simple-method method-name="createAcctgTransForFixedAssetMaintIssuance" short-description="Create an accounting transaction for inventory that is issued for fixed asset maintenance (Type: INVENTORY D: INVENTORY_ACCOUNT, C: FIXED_ASSET_MAINT)">
        <!-- retrieve ledger rounding properties -->
        <property-to-field resource="arithmetic" property="ledger.decimals" field-name="ledgerDecimals"/>
        <property-to-field resource="arithmetic" property="ledger.rounding" field-name="roundingMode"/>
        
        <entity-one entity-name="ItemIssuance" value-name="itemIssuance"/>
        <get-related-one value-name="itemIssuance" relation-name="InventoryItem" to-value-name="inventoryItem"/>

        <calculate field-name="origAmount" type="BigDecimal" decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
            <calcop operator="multiply">
                <calcop operator="get" field-name="itemIssuance.quantity"/>
                <calcop operator="get" field-name="inventoryItem.unitCost"/>
            </calcop>
        </calculate>
        
        <!-- prepare the double posting (D/C) entries (AcctgTransEntry) -->
        <!-- Credit -->
        <make-value entity-name="AcctgTransEntry" value-name="creditEntry"/>
        <set field="creditEntry.debitCreditFlag" value="C"/>
        <set field="creditEntry.glAccountTypeId" value="INVENTORY_ACCOUNT"/>
        <set field="creditEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
        <set field="creditEntry.productId" from-field="inventoryItem.productId"/>
        <set field="creditEntry.origAmount" from-field="origAmount"/>
        <set field="creditEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
        <set field="acctgTransEntries[]" from-field="creditEntry" type="Object"/>
        <!-- Debit -->
        <make-value entity-name="AcctgTransEntry" value-name="debitEntry"/>
        <set field="debitEntry.debitCreditFlag" value="D"/>
        <set field="debitEntry.glAccountTypeId" value="FIXED_ASSET_MAINT"/>
        <set field="debitEntry.organizationPartyId" from-field="inventoryItem.ownerPartyId"/>
        <set field="debitEntry.productId" from-field="inventoryItem.productId"/>
        <set field="debitEntry.origAmount" from-field="origAmount"/>
        <set field="debitEntry.origCurrencyUomId" from-field="inventoryItem.currencyUomId"/>
        <set field="acctgTransEntries[]" from-field="debitEntry" type="Object"/>
        <!-- Set header fields (AcctgTrans) -->
        <set field="createAcctgTransAndEntriesInMap.glFiscalTypeId" value="ACTUAL"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransTypeId" value="INVENTORY"/>
        <set field="createAcctgTransAndEntriesInMap.fixedAssetId" from-field="itemIssuance.fixedAssetId"/>
        <set field="createAcctgTransAndEntriesInMap.acctgTransEntries" from-field="acctgTransEntries"/>
        <call-service service-name="createAcctgTransAndEntries" in-map-name="createAcctgTransAndEntriesInMap">
            <result-to-field result-name="acctgTransId"/>
        </call-service>
        <field-to-result field-name="acctgTransId" result-name="acctgTransId"/>        
    </simple-method>
    <simple-method method-name="createAcctgTransAndEntriesForIncomingPayment" short-description="Create an accounting transaction for an incoming payment" >
        <property-to-field resource="arithmetic" property="ledger.decimals" field-name="ledgerDecimals"/>
        <property-to-field resource="arithmetic" property="ledger.rounding" field-name="roundingMode"/>
        <log level="info" message="Using ledger decimals [${ledgerDecimals}] and rounding [${roundingMode}]"/>
          
        <calculate field-name="amountAppliedTotal" type="BigDecimal"><number value="0"/></calculate>
        <calculate field-name="diffAmount" type="BigDecimal"><number value="0"/></calculate>
         
        <entity-one entity-name="Payment" value-name="payment"/>
        <call-class-method class-name="org.ofbiz.accounting.util.UtilAccounting" method-name="isReceipt" ret-field-name="isReceiptValue">
            <field field-name="payment" type="org.ofbiz.entity.GenericValue"/>
        </call-class-method>
     
        <if-compare field-name="isReceiptValue" operator="equals" value="true" type="Boolean">
            <set field="origCurrencyUomId" from-field="payment.currencyUomId"/>
            <set field="organizationPartyId" from-field="payment.partyIdTo"/>
            <set field="partyId" from-field="payment.partyIdFrom"/>
            <set field="paymentId" from-field="payment.paymentId"/>
         
            <!-- Debit -->
            <make-value entity-name="AcctgTransEntry" value-name="debitEntry"/>
            <set field="debitEntry.debitCreditFlag" value="D"/>
            <!-- TODO --> 
            <!--set field="debitEntry.glAccountTypeId" value=""/-->
            <set field="debitEntry.origAmount" from-field="payment.amount"/> 
            <set field="debitEntry.origCurrencyUomId" from-field="origCurrencyUomId"/>
            <set field="debitEntry.organizationPartyId" from-field="organizationPartyId"/>
            <set field="acctgTransEntries[]" from-field="debitEntry" type="Object"/>
         
            <entity-one entity-name="PaymentGlAccountTypeMap" value-name="paymentGlAccountTypeMap">
                <field-map field-name="paymentTypeId" env-name="payment.paymentTypeId"/>
                <field-map field-name="organizationPartyId"/>
            </entity-one>
            <set field="creditGlAccountTypeId" from-field="paymentGlAccountTypeMap.glAccountTypeId"/>
            
            <get-related value-name="payment" relation-name="PaymentApplication" list-name="paymentApplications"/>
            <iterate list-name="paymentApplications" entry-name="paymentApplication">
             
                <!-- credit -->
                <make-value entity-name="AcctgTransEntry" value-name="creditEntry"/>
                <set field="creditEntry.debitCreditFlag" value="C"/>
                <set field="creditEntry.origAmount" from-field="paymentApplication.amountApplied"/>
                <set field="creditEntry.origCurrencyUomId" from-field="origCurrencyUomId"/>
                <if-not-empty field-name="paymentApplication.overrideGlAccountId">
                    <set field="creditEntry.glAccountId" from-field="paymentApplication.overrideGlAccountId"/>
                <else>
                    <set field="creditEntry.glAccountId" from-field="payment.overrideGlAccountId"/>                  
                </else> 
                </if-not-empty>
                <set field="creditEntry.organizationPartyId" from-field="organizationPartyId"/>
                <set field="creditEntry.glAccountTypeId" from-field="creditGlAccountTypeId"/>
                <calculate field-name="amountAppliedTotal" type="BigDecimal" decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
                    <calcop operator="add">
                        <calcop operator="get" field-name="amountAppliedTotal"/>
                        <calcop operator="get" field-name="paymentApplication.amountApplied"/>
                    </calcop>
                </calculate>
                <set field="acctgTransEntries[]" from-field="creditEntry" type="Object"/>
            </iterate>
         
            <calculate field-name="diffAmount" type="BigDecimal" decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
                <calcop operator="subtract">
                    <calcop operator="get" field-name="payment.amount"/>
                    <calcop operator="get" field-name="amountAppliedTotal"/>
                </calcop>
            </calculate>
            <if-compare field-name="diffAmount" operator="greater" value="0" type="BigDecimal">
                <!-- credit for diff amount-->
                <make-value entity-name="AcctgTransEntry" value-name="creditEntryWithDiffAmount"/> 
                <set field="creditEntryWithDiffAmount.debitCreditFlag" value="C"/>
                <set field="creditEntryWithDiffAmount.origAmount" from-field="diffAmount"/>
                <set field="creditEntryWithDiffAmount.origCurrencyUomId" from-field="origCurrencyUomId"/>
                <set field="creditEntryWithDiffAmount.glAccountId" from-field="payment.overrideGlAccountId"/>
                <set field="creditEntryWithDiffAmount.glAccountTypeId" from-field="creditGlAccountTypeId"/>
                <set field="creditEntryWithDiffAmount.organizationPartyId" from-field="organizationPartyId"/>
                <set field="acctgTransEntries[]" from-field="creditEntryWithDiffAmount" type="Object"/>
            </if-compare>
         
            <!-- Set header fields (AcctgTrans) -->        
            <set field="createAcctgTransAndEntriesInMap.glFiscalTypeId" value="ACTUAL"/>
            <set field="createAcctgTransAndEntriesInMap.partyId" from-field="partyId"/>
            <set field="createAcctgTransAndEntriesInMap.roleTypeId" value="BILL_TO_CUSTOMER"/>
            <set field="createAcctgTransAndEntriesInMap.paymentId" from-field="paymentId"/>
            <set field="createAcctgTransAndEntriesInMap.acctgTransTypeId" value="INCOMING_PAYMENT"/>
            <set field="createAcctgTransAndEntriesInMap.acctgTransEntries" from-field="acctgTransEntries"/>
            <call-service service-name="createAcctgTransAndEntries" in-map-name="createAcctgTransAndEntriesInMap">
                <result-to-field result-name="acctgTransId"/>
            </call-service>
            <field-to-result field-name="acctgTransId" result-name="acctgTransId"/>
        </if-compare>      
    </simple-method> 
    
    <!-- Service for the automatic creation of accounting transaction for Purchase Invoice -->
    <simple-method method-name="createAcctgTransForPurchaseInvoice" short-description="Create an accounting transaction for a purchase invoice">
        <!-- retrieve ledger rounding properties -->
        <property-to-field resource="arithmetic" property="ledger.decimals" field-name="ledgerDecimals"/>
        <property-to-field resource="arithmetic" property="ledger.rounding" field-name="roundingMode"/>
        <log level="info" message="Using ledger decimals [${ledgerDecimals}] and rounding [${roundingMode}]"/>
        <set field="totalAmountFromInvoice" type="BigDecimal" value="0"/>
        <set field="amountFromOrder" type="BigDecimal" value="0"/>
        
        <entity-one entity-name="Invoice" value-name="invoice"/>
        <if-compare field-name="invoice.invoiceTypeId" operator="equals" value="PURCHASE_INVOICE">
            <get-related value-name="invoice" relation-name="InvoiceItem" list-name="invoiceItems"/>
            <iterate list-name="invoiceItems" entry-name="invoiceItem">
                <if-empty field-name="invoiceItem.quantity">
                    <set field="invoiceItem.quantity" value="1"/>
                </if-empty>
                <calculate field-name="amountFromInvoice"  type="BigDecimal" decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
                    <calcop operator="multiply">
                        <calcop operator="get" field-name="invoiceItem.quantity"/>
                        <calcop operator="get" field-name="invoiceItem.amount"/>
                    </calcop>
                </calculate>
                <calculate field-name="totalAmountFromInvoice" type="BigDecimal" decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
                    <calcop operator="add">
                        <calcop operator="get" field-name="totalAmountFromInvoice"/>
                        <calcop operator="get" field-name="amountFromInvoice"/>
                    </calcop>
                </calculate>
                <get-related value-name="invoiceItem" relation-name="OrderItemBilling" list-name="orderItemBillings"/>
                <iterate list-name="orderItemBillings" entry-name="orderItemBilling">
                    <get-related-one value-name="orderItemBilling" relation-name="OrderItem" to-value-name="orderItem"/>
                    <calculate field-name="amountFromOrder" type="BigDecimal"  decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
                        <calcop field-name="amountFromOrder" operator="add">
                            <calcop operator="multiply">
                                <calcop operator="get" field-name="orderItemBilling.quantity"/>
                                <calcop operator="get" field-name="orderItem.unitPrice"/>
                            </calcop>
                        </calcop>
                    </calculate>
                </iterate>
                <!-- Debit -->
                <if>
                    <condition>
                        <and>
                            <if-compare-field field-name="amountFromInvoice" operator="not-equals" to-field-name="amountFromOrder"/>
                            <if-compare field-name="amountFromOrder" operator="greater" value="0" type="BigDecimal"/>
                        </and>
                    </condition>
                    <then>
                        <make-value entity-name="AcctgTransEntry" value-name="debitEntry"/>
                        <set field="debitEntry.debitCreditFlag" value="D"/>
                        <set field="debitEntry.organizationPartyId" from-field="invoice.partyId"/>
                        <set field="debitEntry.partyId" from-field="invoice.partyIdFrom"/>
                        <set field="debitEntry.roleTypeId" value="BILL_FROM_VENDOR"/>
                        <set field="debitEntry.productId" from-field="invoiceItem.productId"/>
                        <set field="debitEntry.glAccountTypeId" value="PURCHASE_PRICE_VAR"/>
                        <calculate field-name="origAmount" type="BigDecimal" decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
                            <calcop operator="subtract">
                                <calcop operator="get" field-name="amountFromInvoice"/>
                                <calcop operator="get" field-name="amountFromOrder"/>
                            </calcop>
                        </calculate>
                        <set field="debitEntry.origAmount" from-field="origAmount"/>
                        <set field="debitEntry.origCurrencyUomId" from-field="invoice.currencyUomId"/>
                        <set field="acctgTransEntries[]" from-field="debitEntry" type="Object"/>
                    </then>
                </if>
                <make-value entity-name="AcctgTransEntry" value-name="debitEntry"/>
                <set field="debitEntry.debitCreditFlag" value="D"/>
                <set field="debitEntry.organizationPartyId" from-field="invoice.partyId"/>
                <set field="debitEntry.partyId" from-field="invoice.partyIdFrom"/>
                <set field="debitEntry.roleTypeId" value="BILL_FROM_VENDOR"/>
                <set field="debitEntry.productId" from-field="invoiceItem.productId"/>
                <set field="debitEntry.glAccountTypeId" from-field="invoiceItem.invoiceItemTypeId"/>
                <set field="debitEntry.glAccountId" from-field="invoiceItem.overrideGlAccountId"/>
                <if-compare field-name="amountFromOrder" operator="greater" value="0" type="BigDecimal">
                    <set field="origAmount" from-field="amountFromOrder"/>
                <else>
                    <set field="origAmount" from-field="amountFromInvoice"/>
                </else>
                </if-compare>
                <set field="debitEntry.origAmount" from-field="origAmount"/>
                <set field="debitEntry.origCurrencyUomId" from-field="invoice.currencyUomId"/>
                <set field="acctgTransEntries[]" from-field="debitEntry" type="Object"/>
            </iterate>
            <!-- Credit -->
            <make-value entity-name="AcctgTransEntry" value-name="creditEntry"/>
            <set field="creditEntry.debitCreditFlag" value="C"/>
            <set field="creditEntry.organizationPartyId" from-field="invoice.partyId"/>
            <set field="creditEntry.glAccountTypeId" value="ACCOUNTS_PAYABLE"/>
            <set field="creditEntry.origAmount" from-field="totalAmountFromInvoice"/>
            <set field="creditEntry.origCurrencyUomId" from-field="invoice.currencyUomId"/>
            <set field="creditEntry.partyId" from-field="invoice.partyIdFrom"/>
            <set field="creditEntry.roleTypeId" value="BILL_FROM_VENDOR"/>
            <set field="acctgTransEntries[]" from-field="creditEntry" type="Object"/>

            <!-- Set header fields (AcctgTrans) -->
            <set field="createAcctgTransAndEntriesInMap.glFiscalTypeId" value="ACTUAL"/>
            <set field="createAcctgTransAndEntriesInMap.acctgTransTypeId" value="PURCHASE_INVOICE"/>
            <set field="createAcctgTransAndEntriesInMap.partyId" from-field="invoice.partyIdFrom"/>
            <set field="createAcctgTransAndEntriesInMap.roleTypeId" value="BILL_FROM_VENDOR"/>
            <set field="createAcctgTransAndEntriesInMap.acctgTransEntries" from-field="acctgTransEntries"/>
            <call-service service-name="createAcctgTransAndEntries" in-map-name="createAcctgTransAndEntriesInMap">
                <result-to-field result-name="acctgTransId"/>
            </call-service>
            <field-to-result field-name="acctgTransId" result-name="acctgTransId"/>
        </if-compare>
    </simple-method>
    
    <simple-method method-name="createAcctgTransForSalesInvoice" short-description="Create an accounting transaction for a sales invoice">
        <!-- retrieve ledger rounding properties -->
        <property-to-field resource="arithmetic" property="ledger.decimals" field-name="ledgerDecimals"/>
        <property-to-field resource="arithmetic" property="ledger.rounding" field-name="roundingMode"/>
        <log level="info" message="Using ledger decimals [${ledgerDecimals}] and rounding [${roundingMode}]"/>
        <set field="totalOrigAmount" value="0"/>
           
        <entity-one entity-name="Invoice" value-name="invoice"/>
        <if-compare field-name="invoice.invoiceTypeId" value="SALES_INVOICE" operator="equals">
            <entity-and entity-name="InvoiceItem" list-name="invoiceItems">
                <field-map field-name="invoiceId" env-name="parameters.invoiceId" />                
            </entity-and> 
            <iterate list-name="invoiceItems" entry-name="invoiceItem">
                <!-- TODO: handle serialized inventory -->
                <if-empty field-name="invoiceItem.quantity">
                    <set field="invoiceItem.quantity" value="1"/>
                </if-empty> 
                <calculate field-name="origAmount" type="BigDecimal" decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
                    <calcop operator="multiply">
                        <calcop operator="get" field-name="invoiceItem.quantity"/>
                        <calcop operator="get" field-name="invoiceItem.amount"/>
                    </calcop>
                </calculate>
                <calculate field-name="totalOrigAmount" type="BigDecimal" decimal-scale="${ledgerDecimals}" rounding-mode="${roundingMode}">
                    <calcop operator="add">
                        <calcop operator="get" field-name="totalOrigAmount"/>
                        <calcop operator="get" field-name="origAmount"/>
                    </calcop>
                </calculate>
                <!-- Credit -->
                <make-value entity-name="AcctgTransEntry" value-name="creditEntry"/>
                <set field="creditEntry.debitCreditFlag" value="C"/>
                <set field="creditEntry.glAccountTypeId" from-field="invoiceItem.invoiceItemTypeId"/>
                <set field="creditEntry.organizationPartyId" from-field="invoice.partyIdFrom"/>
                <set field="creditEntry.productId" from-field="invoiceItem.productId"/>
                <set field="creditEntry.origAmount" from-field="origAmount"/>
                <set field="creditEntry.origCurrencyUomId" from-field="invoice.currencyUomId "/>
                <set field="creditEntry.glAccountId" from-field="invoiceItem.overrideGlAccountId"/>
                <if-not-empty field-name="invoiceItem.taxAuthPartyId">
                    <set field="creditEntry.partyId" from-field="invoiceItem.taxAuthPartyId"/>
                    <set field="creditEntry.roleTypeId" value="TAX_AUTHORITY"/>
                </if-not-empty>
            </iterate>        
           
            <!-- Debit -->
            <make-value entity-name="AcctgTransEntry" value-name="debitEntry"/>
            <set field="debitEntry.debitCreditFlag" value="D"/>
            <set field="debitEntry.glAccountTypeId" value="ACCOUNTS_RECEIVABLE"/>
            <set field="debitEntry.organizationPartyId" from-field="invoice.partyIdFrom"/>
            <set field="debitEntry.origAmount" from-field="totalOrigAmount"/>
            <set field="debitEntry.origCurrencyUomId" from-field="invoice.currencyUomId"/>
            <set field="debitEntry.partyId" from-field="invoice.partyId"/>
            <set field="debitEntry.roleTypeId" value="BILL_TO_CUSTOMER"/>
            <set field="acctgTransEntries[]" from-field="creditEntry" type="Object"/>
            <set field="acctgTransEntries[]" from-field="debitEntry" type="Object"/>
            <set field="createAcctgTransAndEntriesInMap.glFiscalTypeId" value="ACTUAL"/>
            <set field="createAcctgTransAndEntriesInMap.acctgTransTypeId" value="SALES_INVOICE"/>
            <set field="createAcctgTransAndEntriesInMap.invoiceId" from-field="parameters.invoiceId"/>
            <set field="createAcctgTransAndEntriesInMap.acctgTransEntries" from-field="acctgTransEntries"/>
            <call-service service-name="createAcctgTransAndEntries" in-map-name="createAcctgTransAndEntriesInMap">
                <result-to-field result-name="acctgTransId"/>
            </call-service>
            <field-to-result field-name="acctgTransId" result-name="acctgTransId"/>
        </if-compare>    
    </simple-method>
    
</simple-methods>
