Index: BeanShell/src/bsh/Interpreter.java
===================================================================
--- BeanShell/src/bsh/Interpreter.java	(revision 21)
+++ BeanShell/src/bsh/Interpreter.java	(working copy)
@@ -585,7 +585,7 @@
 	}
 
     /**
-        Spawn a non-interactive local interpreter to evaluate text in the 
+	 Spawn a non-interactive local interpreter to evaluate text in the 
 		specified namespace.  
 
 		Return value is the evaluated object (or corresponding primitive 
@@ -612,106 +612,11 @@
 			/*, CallStack callstack */ ) 
 		throws EvalError 
 	{
-		Object retVal = null;
 		if ( Interpreter.DEBUG ) debug("eval: nameSpace = "+nameSpace);
 
-		/* 
-			Create non-interactive local interpreter for this namespace
-			with source from the input stream and out/err same as 
-			this interpreter.
-		*/
-        Interpreter localInterpreter = 
-			new Interpreter( 
-				in, out, err, false, nameSpace, this, sourceFileInfo  );
+		return evalParsedScript(parseScript(sourceFileInfo, in), nameSpace); 
+	}
 
-		CallStack callstack = new CallStack( nameSpace );
-
-        boolean eof = false;
-        while(!eof)
-        {
-			SimpleNode node = null;
-            try
-            {
-                eof = localInterpreter.Line();
-                if (localInterpreter.get_jjtree().nodeArity() > 0)
-                {
-                    node = (SimpleNode)localInterpreter.get_jjtree().rootNode();
-					// nodes remember from where they were sourced
-					node.setSourceFile( sourceFileInfo );
-
-					if ( TRACE )
-						println( "// " +node.getText() );
-
-                    retVal = node.eval( callstack, localInterpreter );
-
-					// sanity check during development
-					if ( callstack.depth() > 1 )
-						throw new InterpreterError(
-							"Callstack growing: "+callstack);
-
-                    if ( retVal instanceof ReturnControl ) {
-                        retVal = ((ReturnControl)retVal).value;
-						break; // non-interactive, return control now
-					}
-
-					if ( localInterpreter.showResults 
-						&& retVal != Primitive.VOID )
-						println("<" + retVal + ">");
-                }
-            } catch(ParseException e) {
-				/*
-                throw new EvalError(
-					"Sourced file: "+sourceFileInfo+" parser Error: " 
-					+ e.getMessage( DEBUG ), node, callstack );
-				*/
-				if ( DEBUG )
-					// show extra "expecting..." info
-					error( e.getMessage(DEBUG) );
-
-				// add the source file info and throw again
-				e.setErrorSourceFile( sourceFileInfo );
-				throw e;
-
-            } catch ( InterpreterError e ) {
-                e.printStackTrace();
-                throw new EvalError(
-					"Sourced file: "+sourceFileInfo+" internal Error: " 
-					+ e.getMessage(), node, callstack);
-            } catch ( TargetError e ) {
-				// failsafe, set the Line as the origin of the error.
-				if ( e.getNode()==null )
-					e.setNode( node );
-				e.reThrow("Sourced file: "+sourceFileInfo);
-            } catch ( EvalError e) {
-                if ( DEBUG)
-                    e.printStackTrace();
-				// failsafe, set the Line as the origin of the error.
-				if ( e.getNode()==null )
-					e.setNode( node );
-				e.reThrow( "Sourced file: "+sourceFileInfo );
-            } catch ( Exception e) {
-                if ( DEBUG)
-                	e.printStackTrace();
-                throw new EvalError(
-					"Sourced file: "+sourceFileInfo+" unknown error: " 
-					+ e.getMessage(), node, callstack);
-            } catch(TokenMgrError e) {
-                throw new EvalError(
-					"Sourced file: "+sourceFileInfo+" Token Parsing Error: " 
-					+ e.getMessage(), node, callstack );
-            } finally {
-                localInterpreter.get_jjtree().reset();
-
-				// reinit the callstack
-				if ( callstack.depth() > 1 ) {
-					callstack.clear();
-					callstack.push( nameSpace );
-				}
-            }
-        }
-		return Primitive.unwrap( retVal );
-    }
-
 	/**
 		Evaluate the inputstream in this interpreter's global namespace.
 	*/
@@ -1230,5 +1135,127 @@
 	public boolean getShowResults()  {
 		return showResults;
 	}
-}
+   
+	/**
+	 * Inner class to represent a parsed source file and its line number information
+	 * 
+	 * TODO: use ArrayList instead of Vector for simpleNodeList if no concurrency issues?
+	 */
+	public static class ParsedScript implements Serializable {
+		private String sourceFileInfo;
+		private Vector simpleNodeList;  //already-parsed expressions
+		
+		public ParsedScript(String sourceFileInfo, Vector simpleNodeList) {
+			this.sourceFileInfo = sourceFileInfo;
+			this.simpleNodeList = simpleNodeList;
+		}
+		
+		String getSourceFileInfo() { return sourceFileInfo; }
+		Vector getSimpleNodeList() { return simpleNodeList; }
+	}
+   
+	/**
+	 * Parse a script, and return the parsed representation as a ParsedScript,
+	 *  which can later on be passed to evalParsedScript for efficient, repeated evaluation.
+	 * 
+	 * @param sourceFileInfo - filename/path/system identifier of the script
+	 */
+	public ParsedScript parseScript(String sourceFileInfo, Reader in) throws ParseException {
+		Vector simpleNodeList = new Vector();  //will collect AST nodes as they are parsed
+		Parser parser = new Parser(in);
 
+		boolean eof = false;
+		while(!eof) {
+			try {
+				eof = parser.Line();
+				if(parser.jjtree.nodeArity() > 0) {
+					SimpleNode node = (SimpleNode) parser.jjtree.rootNode();
+					// nodes remember from where they were sourced
+					node.setSourceFile(sourceFileInfo);
+					simpleNodeList.addElement(node);
+					if ( TRACE ) { println( "// " + node.getText() ); }
+				}
+			} catch(ParseException e) {
+				// show extra "expecting..." info
+				if ( DEBUG ) { error( e.getMessage(DEBUG) ); }
+  
+				// add the source file info and throw again
+				e.setErrorSourceFile( sourceFileInfo );
+				throw e;
+			} finally {  parser.jjtree.reset(); }
+		}
+		
+		return new ParsedScript(sourceFileInfo, simpleNodeList);
+	}
+	
+	/**
+	 * Convenience method which calls evalParsedScript with global namespace
+	 */
+	public Object evalParsedScript(ParsedScript script) throws EvalError {
+		return evalParsedScript(script, getNameSpace());
+	}
+	
+	/**
+	 * Evaluate the given already-parsed script and return its results
+	 * 
+	 * @param script - should have been prepared earlier by parseScript
+	 * @see parseScript
+	 */
+	public Object evalParsedScript(ParsedScript script, NameSpace nameSpace) throws EvalError {
+		//1. Prepare and validate passed-in script info
+		String sourceFileInfo = script.getSourceFileInfo();
+		Vector simpleNodeList = script.getSimpleNodeList();
+		
+		if (simpleNodeList == null) { return null; }  //bail early as nothing to do!
+		
+		//2. Prepare helper objects for parsing process
+		CallStack callstack = new CallStack();
+		callstack.push(nameSpace);
+		Object retVal = null;  //will eventually old result of script execution
+		
+		//3. Evaluated each already-parsed node in order
+		int listSize = simpleNodeList.size();
+		for (int i = 0; i < listSize; i++) {
+			SimpleNode node = (SimpleNode)simpleNodeList.elementAt(i);
+			try {
+				retVal = node.eval(callstack, this);
+
+				// sanity check during development
+				if(callstack.depth() > 1) { throw new InterpreterError("Callstack growing: " + callstack); }
+
+				if(retVal instanceof ReturnControl) {
+					retVal = ((ReturnControl)retVal).value;
+					break; // non-interactive, return control now
+				}
+			} catch(InterpreterError e) {
+				e.printStackTrace();
+				throw new EvalError("Sourced file: " + sourceFileInfo + " internal Error: " + e.getMessage(), node, callstack);
+			} catch(TargetError e) {
+				// failsafe, set the Line as the origin of the error.
+				if(e.getNode()==null) { e.setNode( node ); }
+				if(e.getTarget() != null) { e.getTarget().printStackTrace(); }
+				e.reThrow("Sourced file: " + sourceFileInfo);
+			} catch(EvalError e) {
+				if ( DEBUG ) { e.printStackTrace(); }
+				// failsafe, set the Line as the origin of the error.
+				if (e.getNode()==null) { e.setNode( node ); }
+				e.reThrow( "Sourced file: "+ sourceFileInfo );
+			} catch(Exception e) {
+				if ( DEBUG ) { e.printStackTrace(); }
+				throw new EvalError("Sourced file: " + sourceFileInfo + " unknown error: " + e.getMessage(), node, callstack);
+			} catch(TokenMgrError e) {
+				if ( DEBUG ) { e.printStackTrace(); }
+				throw new EvalError("Sourced file: " + sourceFileInfo + " Token Parsing Error: " + e.getMessage(), node, callstack);
+			} finally {
+				// reinit the callstack
+				if (callstack.depth() > 1) {
+					callstack.clear();
+					callstack.push(nameSpace);
+				}
+			}
+		}
+		
+		//4. return the final result of the evaluation
+		return Primitive.unwrap(retVal);
+	}
+}
\ No newline at end of file
Index: BeanShell/src/bsh/BshClassManager.java
===================================================================
--- BeanShell/src/bsh/BshClassManager.java	(revision 21)
+++ BeanShell/src/bsh/BshClassManager.java	(working copy)
@@ -647,4 +647,16 @@
 			return true;
 		}
 	}
-}
+
+	//=== OFBiz EXTENSIONS ===
+   
+	/**
+	 * Convenience method to create a new class manager with its own default internal interpreter  
+	 *
+	 * @see bsh.Interpreter.getClassManager()
+	 * @see bsh.Interpreter.setClassLoader( ClassLoader )
+	 */
+	public static BshClassManager createClassManager() {
+		return createClassManager(null);
+	}
+}
\ No newline at end of file
